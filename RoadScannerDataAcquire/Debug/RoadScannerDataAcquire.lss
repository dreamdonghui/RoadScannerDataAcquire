
RoadScannerDataAcquire.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002ca4  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000014  20000000  00002ca4  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000b94  20000014  00002cb8  00020014  2**2
                  ALLOC
  3 .stack        00002000  20000ba8  0000384c  00020014  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00020014  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  0002003c  2**0
                  CONTENTS, READONLY
  6 .debug_info   0002078c  00000000  00000000  00020095  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003829  00000000  00000000  00040821  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    000102f1  00000000  00000000  0004404a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000e20  00000000  00000000  0005433b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00001488  00000000  00000000  0005515b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  000212fd  00000000  00000000  000565e3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00014be8  00000000  00000000  000778e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000a73c4  00000000  00000000  0008c4c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00002530  00000000  00000000  0013388c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	a8 2b 00 20 2d 01 00 00 29 01 00 00 29 01 00 00     .+. -...)...)...
	...
      2c:	55 14 00 00 00 00 00 00 00 00 00 00 21 15 00 00     U...........!...
      3c:	65 15 00 00 29 01 00 00 29 01 00 00 29 01 00 00     e...)...)...)...
      4c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
      5c:	29 01 00 00 29 01 00 00 29 01 00 00 f9 0e 00 00     )...)...).......
      6c:	29 01 00 00 29 01 00 00 8d 0e 00 00 29 01 00 00     )...).......)...
      7c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
      8c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
      9c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
      ac:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...

000000bc <__do_global_dtors_aux>:
      bc:	b510      	push	{r4, lr}
      be:	4c06      	ldr	r4, [pc, #24]	; (d8 <__do_global_dtors_aux+0x1c>)
      c0:	7823      	ldrb	r3, [r4, #0]
      c2:	2b00      	cmp	r3, #0
      c4:	d107      	bne.n	d6 <__do_global_dtors_aux+0x1a>
      c6:	4b05      	ldr	r3, [pc, #20]	; (dc <__do_global_dtors_aux+0x20>)
      c8:	2b00      	cmp	r3, #0
      ca:	d002      	beq.n	d2 <__do_global_dtors_aux+0x16>
      cc:	4804      	ldr	r0, [pc, #16]	; (e0 <__do_global_dtors_aux+0x24>)
      ce:	e000      	b.n	d2 <__do_global_dtors_aux+0x16>
      d0:	bf00      	nop
      d2:	2301      	movs	r3, #1
      d4:	7023      	strb	r3, [r4, #0]
      d6:	bd10      	pop	{r4, pc}
      d8:	20000014 	.word	0x20000014
      dc:	00000000 	.word	0x00000000
      e0:	00002ca4 	.word	0x00002ca4

000000e4 <frame_dummy>:
      e4:	4b08      	ldr	r3, [pc, #32]	; (108 <frame_dummy+0x24>)
      e6:	b510      	push	{r4, lr}
      e8:	2b00      	cmp	r3, #0
      ea:	d003      	beq.n	f4 <frame_dummy+0x10>
      ec:	4907      	ldr	r1, [pc, #28]	; (10c <frame_dummy+0x28>)
      ee:	4808      	ldr	r0, [pc, #32]	; (110 <frame_dummy+0x2c>)
      f0:	e000      	b.n	f4 <frame_dummy+0x10>
      f2:	bf00      	nop
      f4:	4807      	ldr	r0, [pc, #28]	; (114 <frame_dummy+0x30>)
      f6:	6803      	ldr	r3, [r0, #0]
      f8:	2b00      	cmp	r3, #0
      fa:	d100      	bne.n	fe <frame_dummy+0x1a>
      fc:	bd10      	pop	{r4, pc}
      fe:	4b06      	ldr	r3, [pc, #24]	; (118 <frame_dummy+0x34>)
     100:	2b00      	cmp	r3, #0
     102:	d0fb      	beq.n	fc <frame_dummy+0x18>
     104:	4798      	blx	r3
     106:	e7f9      	b.n	fc <frame_dummy+0x18>
     108:	00000000 	.word	0x00000000
     10c:	20000018 	.word	0x20000018
     110:	00002ca4 	.word	0x00002ca4
     114:	00002ca4 	.word	0x00002ca4
     118:	00000000 	.word	0x00000000

0000011c <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     11c:	b510      	push	{r4, lr}
	system_init();
     11e:	4b01      	ldr	r3, [pc, #4]	; (124 <atmel_start_init+0x8>)
     120:	4798      	blx	r3
}
     122:	bd10      	pop	{r4, pc}
     124:	000003e1 	.word	0x000003e1

00000128 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     128:	e7fe      	b.n	128 <Dummy_Handler>
	...

0000012c <Reset_Handler>:
{
     12c:	b510      	push	{r4, lr}
        if (pSrc != pDest) {
     12e:	4a17      	ldr	r2, [pc, #92]	; (18c <Reset_Handler+0x60>)
     130:	4b17      	ldr	r3, [pc, #92]	; (190 <Reset_Handler+0x64>)
     132:	429a      	cmp	r2, r3
     134:	d011      	beq.n	15a <Reset_Handler+0x2e>
                for (; pDest < &_erelocate;) {
     136:	001a      	movs	r2, r3
     138:	4b16      	ldr	r3, [pc, #88]	; (194 <Reset_Handler+0x68>)
     13a:	429a      	cmp	r2, r3
     13c:	d20d      	bcs.n	15a <Reset_Handler+0x2e>
     13e:	4a16      	ldr	r2, [pc, #88]	; (198 <Reset_Handler+0x6c>)
     140:	3303      	adds	r3, #3
     142:	1a9b      	subs	r3, r3, r2
     144:	089b      	lsrs	r3, r3, #2
     146:	3301      	adds	r3, #1
     148:	009b      	lsls	r3, r3, #2
     14a:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
     14c:	4810      	ldr	r0, [pc, #64]	; (190 <Reset_Handler+0x64>)
     14e:	490f      	ldr	r1, [pc, #60]	; (18c <Reset_Handler+0x60>)
     150:	588c      	ldr	r4, [r1, r2]
     152:	5084      	str	r4, [r0, r2]
     154:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     156:	429a      	cmp	r2, r3
     158:	d1fa      	bne.n	150 <Reset_Handler+0x24>
        for (pDest = &_szero; pDest < &_ezero;) {
     15a:	4a10      	ldr	r2, [pc, #64]	; (19c <Reset_Handler+0x70>)
     15c:	4b10      	ldr	r3, [pc, #64]	; (1a0 <Reset_Handler+0x74>)
     15e:	429a      	cmp	r2, r3
     160:	d20a      	bcs.n	178 <Reset_Handler+0x4c>
     162:	43d3      	mvns	r3, r2
     164:	490e      	ldr	r1, [pc, #56]	; (1a0 <Reset_Handler+0x74>)
     166:	185b      	adds	r3, r3, r1
     168:	2103      	movs	r1, #3
     16a:	438b      	bics	r3, r1
     16c:	3304      	adds	r3, #4
     16e:	189b      	adds	r3, r3, r2
                *pDest++ = 0;
     170:	2100      	movs	r1, #0
     172:	c202      	stmia	r2!, {r1}
        for (pDest = &_szero; pDest < &_ezero;) {
     174:	4293      	cmp	r3, r2
     176:	d1fc      	bne.n	172 <Reset_Handler+0x46>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     178:	4a0a      	ldr	r2, [pc, #40]	; (1a4 <Reset_Handler+0x78>)
     17a:	21ff      	movs	r1, #255	; 0xff
     17c:	4b0a      	ldr	r3, [pc, #40]	; (1a8 <Reset_Handler+0x7c>)
     17e:	438b      	bics	r3, r1
     180:	6093      	str	r3, [r2, #8]
        __libc_init_array();
     182:	4b0a      	ldr	r3, [pc, #40]	; (1ac <Reset_Handler+0x80>)
     184:	4798      	blx	r3
        main();
     186:	4b0a      	ldr	r3, [pc, #40]	; (1b0 <Reset_Handler+0x84>)
     188:	4798      	blx	r3
     18a:	e7fe      	b.n	18a <Reset_Handler+0x5e>
     18c:	00002ca4 	.word	0x00002ca4
     190:	20000000 	.word	0x20000000
     194:	20000014 	.word	0x20000014
     198:	20000004 	.word	0x20000004
     19c:	20000014 	.word	0x20000014
     1a0:	20000ba8 	.word	0x20000ba8
     1a4:	e000ed00 	.word	0xe000ed00
     1a8:	00000000 	.word	0x00000000
     1ac:	00002afd 	.word	0x00002afd
     1b0:	0000133d 	.word	0x0000133d

000001b4 <USART_On_USBPort_CLOCK_init>:
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
     1b4:	4b06      	ldr	r3, [pc, #24]	; (1d0 <USART_On_USBPort_CLOCK_init+0x1c>)
     1b6:	2140      	movs	r1, #64	; 0x40
     1b8:	22dc      	movs	r2, #220	; 0xdc
     1ba:	5099      	str	r1, [r3, r2]
     1bc:	3103      	adds	r1, #3
     1be:	3a14      	subs	r2, #20
     1c0:	5099      	str	r1, [r3, r2]
}

static inline void hri_mclk_set_APBCMASK_SERCOM4_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_SERCOM4;
     1c2:	4a04      	ldr	r2, [pc, #16]	; (1d4 <USART_On_USBPort_CLOCK_init+0x20>)
     1c4:	69d3      	ldr	r3, [r2, #28]
     1c6:	3923      	subs	r1, #35	; 0x23
     1c8:	430b      	orrs	r3, r1
     1ca:	61d3      	str	r3, [r2, #28]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM4_GCLK_ID_CORE, CONF_GCLK_SERCOM4_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM4_GCLK_ID_SLOW, CONF_GCLK_SERCOM4_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBCMASK_SERCOM4_bit(MCLK);
}
     1cc:	4770      	bx	lr
     1ce:	46c0      	nop			; (mov r8, r8)
     1d0:	40001c00 	.word	0x40001c00
     1d4:	40000800 	.word	0x40000800

000001d8 <USART_On_USBPort_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_On_USBPort_PORT_init()
{
     1d8:	b530      	push	{r4, r5, lr}
static inline void hri_port_write_PINCFG_PMUXEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                    bool value)
{
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     1da:	2382      	movs	r3, #130	; 0x82
     1dc:	05db      	lsls	r3, r3, #23
     1de:	22ca      	movs	r2, #202	; 0xca
     1e0:	5c99      	ldrb	r1, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
     1e2:	2501      	movs	r5, #1
     1e4:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     1e6:	2401      	movs	r4, #1
     1e8:	4321      	orrs	r1, r4
     1ea:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     1ec:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     1ee:	20b5      	movs	r0, #181	; 0xb5
     1f0:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     1f2:	3abb      	subs	r2, #187	; 0xbb
     1f4:	4391      	bics	r1, r2
	tmp |= PORT_PMUX_PMUXE(data);
     1f6:	3a0c      	subs	r2, #12
     1f8:	4311      	orrs	r1, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     1fa:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     1fc:	21cb      	movs	r1, #203	; 0xcb
     1fe:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     200:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     202:	4322      	orrs	r2, r4
     204:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     206:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     208:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     20a:	39bc      	subs	r1, #188	; 0xbc
     20c:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
     20e:	3121      	adds	r1, #33	; 0x21
     210:	430a      	orrs	r2, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     212:	541a      	strb	r2, [r3, r0]

	gpio_set_pin_function(PB10, PINMUX_PB10D_SERCOM4_PAD2);

	gpio_set_pin_function(PB11, PINMUX_PB11D_SERCOM4_PAD3);
}
     214:	bd30      	pop	{r4, r5, pc}
	...

00000218 <USART_On_USBPort_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_On_USBPort_init(void)
{
     218:	b510      	push	{r4, lr}
     21a:	b082      	sub	sp, #8
	USART_On_USBPort_CLOCK_init();
     21c:	4b06      	ldr	r3, [pc, #24]	; (238 <USART_On_USBPort_init+0x20>)
     21e:	4798      	blx	r3
	usart_async_init(&USART_On_USBPort, SERCOM4, USART_On_USBPort_buffer, USART_ON_USBPORT_BUFFER_SIZE, (void *)NULL);
     220:	2300      	movs	r3, #0
     222:	9300      	str	r3, [sp, #0]
     224:	3310      	adds	r3, #16
     226:	4a05      	ldr	r2, [pc, #20]	; (23c <USART_On_USBPort_init+0x24>)
     228:	4905      	ldr	r1, [pc, #20]	; (240 <USART_On_USBPort_init+0x28>)
     22a:	4806      	ldr	r0, [pc, #24]	; (244 <USART_On_USBPort_init+0x2c>)
     22c:	4c06      	ldr	r4, [pc, #24]	; (248 <USART_On_USBPort_init+0x30>)
     22e:	47a0      	blx	r4
	USART_On_USBPort_PORT_init();
     230:	4b06      	ldr	r3, [pc, #24]	; (24c <USART_On_USBPort_init+0x34>)
     232:	4798      	blx	r3
}
     234:	b002      	add	sp, #8
     236:	bd10      	pop	{r4, pc}
     238:	000001b5 	.word	0x000001b5
     23c:	20000030 	.word	0x20000030
     240:	42001400 	.word	0x42001400
     244:	20000b00 	.word	0x20000b00
     248:	00000901 	.word	0x00000901
     24c:	000001d9 	.word	0x000001d9

00000250 <SPI_0_PORT_init>:

void SPI_0_PORT_init(void)
{
     250:	b5f0      	push	{r4, r5, r6, r7, lr}
     252:	46de      	mov	lr, fp
     254:	4657      	mov	r7, sl
     256:	464e      	mov	r6, r9
     258:	4645      	mov	r5, r8
     25a:	b5e0      	push	{r5, r6, r7, lr}
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     25c:	21c0      	movs	r1, #192	; 0xc0
     25e:	05c9      	lsls	r1, r1, #23
     260:	2380      	movs	r3, #128	; 0x80
     262:	015b      	lsls	r3, r3, #5
     264:	228a      	movs	r2, #138	; 0x8a
     266:	0052      	lsls	r2, r2, #1
     268:	508b      	str	r3, [r1, r2]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     26a:	3a0c      	subs	r2, #12
     26c:	508b      	str	r3, [r1, r2]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     26e:	2382      	movs	r3, #130	; 0x82
     270:	05db      	lsls	r3, r3, #23
     272:	3220      	adds	r2, #32
     274:	483a      	ldr	r0, [pc, #232]	; (360 <SPI_0_PORT_init+0x110>)
     276:	5098      	str	r0, [r3, r2]
     278:	20c0      	movs	r0, #192	; 0xc0
     27a:	0600      	lsls	r0, r0, #24
     27c:	4683      	mov	fp, r0
     27e:	5098      	str	r0, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     280:	26a6      	movs	r6, #166	; 0xa6
     282:	0076      	lsls	r6, r6, #1
     284:	5d98      	ldrb	r0, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     286:	2501      	movs	r5, #1
     288:	43a8      	bics	r0, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     28a:	2401      	movs	r4, #1
     28c:	4320      	orrs	r0, r4
     28e:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     290:	5598      	strb	r0, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     292:	3e16      	subs	r6, #22
     294:	5d98      	ldrb	r0, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     296:	270f      	movs	r7, #15
     298:	46bc      	mov	ip, r7
     29a:	43b8      	bics	r0, r7
	tmp |= PORT_PMUX_PMUXE(data);
     29c:	3f0d      	subs	r7, #13
     29e:	4338      	orrs	r0, r7
     2a0:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     2a2:	5598      	strb	r0, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     2a4:	2082      	movs	r0, #130	; 0x82
     2a6:	0040      	lsls	r0, r0, #1
     2a8:	4682      	mov	sl, r0
     2aa:	2080      	movs	r0, #128	; 0x80
     2ac:	0180      	lsls	r0, r0, #6
     2ae:	4657      	mov	r7, sl
     2b0:	51c8      	str	r0, [r1, r7]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     2b2:	482c      	ldr	r0, [pc, #176]	; (364 <SPI_0_PORT_init+0x114>)
     2b4:	5098      	str	r0, [r3, r2]
     2b6:	482c      	ldr	r0, [pc, #176]	; (368 <SPI_0_PORT_init+0x118>)
     2b8:	4681      	mov	r9, r0
     2ba:	5098      	str	r0, [r3, r2]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     2bc:	274e      	movs	r7, #78	; 0x4e
     2be:	37ff      	adds	r7, #255	; 0xff
     2c0:	5dd8      	ldrb	r0, [r3, r7]
     2c2:	3403      	adds	r4, #3
     2c4:	46a0      	mov	r8, r4
     2c6:	43a0      	bics	r0, r4
     2c8:	55d8      	strb	r0, [r3, r7]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     2ca:	5dd8      	ldrb	r0, [r3, r7]
	tmp &= ~PORT_PINCFG_PMUXEN;
     2cc:	43a8      	bics	r0, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     2ce:	3c03      	subs	r4, #3
     2d0:	4320      	orrs	r0, r4
     2d2:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     2d4:	55d8      	strb	r0, [r3, r7]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     2d6:	5d98      	ldrb	r0, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     2d8:	3f3f      	subs	r7, #63	; 0x3f
     2da:	3fff      	subs	r7, #255	; 0xff
     2dc:	4038      	ands	r0, r7
	tmp |= PORT_PMUX_PMUXO(data);
     2de:	341f      	adds	r4, #31
     2e0:	4320      	orrs	r0, r4
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     2e2:	5598      	strb	r0, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     2e4:	2080      	movs	r0, #128	; 0x80
     2e6:	01c0      	lsls	r0, r0, #7
     2e8:	4654      	mov	r4, sl
     2ea:	5108      	str	r0, [r1, r4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     2ec:	481f      	ldr	r0, [pc, #124]	; (36c <SPI_0_PORT_init+0x11c>)
     2ee:	5098      	str	r0, [r3, r2]
     2f0:	4648      	mov	r0, r9
     2f2:	5098      	str	r0, [r3, r2]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     2f4:	20a7      	movs	r0, #167	; 0xa7
     2f6:	0040      	lsls	r0, r0, #1
     2f8:	5c1e      	ldrb	r6, [r3, r0]
     2fa:	4644      	mov	r4, r8
     2fc:	43a6      	bics	r6, r4
     2fe:	541e      	strb	r6, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     300:	5c1e      	ldrb	r6, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
     302:	43ae      	bics	r6, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     304:	3c03      	subs	r4, #3
     306:	4326      	orrs	r6, r4
     308:	b2f6      	uxtb	r6, r6
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     30a:	541e      	strb	r6, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     30c:	2638      	movs	r6, #56	; 0x38
     30e:	36ff      	adds	r6, #255	; 0xff
     310:	5d98      	ldrb	r0, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     312:	4664      	mov	r4, ip
     314:	43a0      	bics	r0, r4
	tmp |= PORT_PMUX_PMUXE(data);
     316:	3c0d      	subs	r4, #13
     318:	4320      	orrs	r0, r4
     31a:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     31c:	5598      	strb	r0, [r3, r6]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     31e:	2080      	movs	r0, #128	; 0x80
     320:	0100      	lsls	r0, r0, #4
     322:	3413      	adds	r4, #19
     324:	34ff      	adds	r4, #255	; 0xff
     326:	5108      	str	r0, [r1, r4]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     328:	3c0c      	subs	r4, #12
     32a:	5108      	str	r0, [r1, r4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     32c:	4910      	ldr	r1, [pc, #64]	; (370 <SPI_0_PORT_init+0x120>)
     32e:	5099      	str	r1, [r3, r2]
     330:	4659      	mov	r1, fp
     332:	5099      	str	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     334:	214c      	movs	r1, #76	; 0x4c
     336:	31ff      	adds	r1, #255	; 0xff
     338:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     33a:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     33c:	3c08      	subs	r4, #8
     33e:	3cff      	subs	r4, #255	; 0xff
     340:	4314      	orrs	r4, r2
     342:	b2e4      	uxtb	r4, r4
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     344:	545c      	strb	r4, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     346:	2136      	movs	r1, #54	; 0x36
     348:	31ff      	adds	r1, #255	; 0xff
     34a:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     34c:	4017      	ands	r7, r2
	tmp |= PORT_PMUX_PMUXO(data);
     34e:	2230      	movs	r2, #48	; 0x30
     350:	4317      	orrs	r7, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     352:	545f      	strb	r7, [r3, r1]

	// Set pin direction to output
	gpio_set_pin_direction(PC11, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(PC11, PINMUX_PC11D_SERCOM7_PAD3);
}
     354:	bc3c      	pop	{r2, r3, r4, r5}
     356:	4690      	mov	r8, r2
     358:	4699      	mov	r9, r3
     35a:	46a2      	mov	sl, r4
     35c:	46ab      	mov	fp, r5
     35e:	bdf0      	pop	{r4, r5, r6, r7, pc}
     360:	40001000 	.word	0x40001000
     364:	40022000 	.word	0x40022000
     368:	c0020000 	.word	0xc0020000
     36c:	40024000 	.word	0x40024000
     370:	40000800 	.word	0x40000800

00000374 <SPI_0_CLOCK_init>:
     374:	4b06      	ldr	r3, [pc, #24]	; (390 <SPI_0_CLOCK_init+0x1c>)
     376:	2140      	movs	r1, #64	; 0x40
     378:	2294      	movs	r2, #148	; 0x94
     37a:	0052      	lsls	r2, r2, #1
     37c:	5099      	str	r1, [r3, r2]
     37e:	3103      	adds	r1, #3
     380:	3a60      	subs	r2, #96	; 0x60
     382:	5099      	str	r1, [r3, r2]
}

static inline void hri_mclk_set_APBDMASK_SERCOM7_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM7;
     384:	4a03      	ldr	r2, [pc, #12]	; (394 <SPI_0_CLOCK_init+0x20>)
     386:	6a13      	ldr	r3, [r2, #32]
     388:	3941      	subs	r1, #65	; 0x41
     38a:	430b      	orrs	r3, r1
     38c:	6213      	str	r3, [r2, #32]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM7_GCLK_ID_CORE, CONF_GCLK_SERCOM7_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM7_GCLK_ID_SLOW, CONF_GCLK_SERCOM7_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM7_bit(MCLK);
}
     38e:	4770      	bx	lr
     390:	40001c00 	.word	0x40001c00
     394:	40000800 	.word	0x40000800

00000398 <SPI_0_init>:

void SPI_0_init(void)
{
     398:	b510      	push	{r4, lr}
	SPI_0_CLOCK_init();
     39a:	4b06      	ldr	r3, [pc, #24]	; (3b4 <SPI_0_init+0x1c>)
     39c:	4798      	blx	r3
	spi_s_async_init(&SPI_0, SERCOM7, (uint8_t *)SPI_0_buf, 32);
     39e:	2320      	movs	r3, #32
     3a0:	4a05      	ldr	r2, [pc, #20]	; (3b8 <SPI_0_init+0x20>)
     3a2:	3210      	adds	r2, #16
     3a4:	4905      	ldr	r1, [pc, #20]	; (3bc <SPI_0_init+0x24>)
     3a6:	4806      	ldr	r0, [pc, #24]	; (3c0 <SPI_0_init+0x28>)
     3a8:	4c06      	ldr	r4, [pc, #24]	; (3c4 <SPI_0_init+0x2c>)
     3aa:	47a0      	blx	r4
	SPI_0_PORT_init();
     3ac:	4b06      	ldr	r3, [pc, #24]	; (3c8 <SPI_0_init+0x30>)
     3ae:	4798      	blx	r3
}
     3b0:	bd10      	pop	{r4, pc}
     3b2:	46c0      	nop			; (mov r8, r8)
     3b4:	00000375 	.word	0x00000375
     3b8:	20000030 	.word	0x20000030
     3bc:	43000400 	.word	0x43000400
     3c0:	20000b50 	.word	0x20000b50
     3c4:	00000679 	.word	0x00000679
     3c8:	00000251 	.word	0x00000251

000003cc <delay_driver_init>:

void delay_driver_init(void)
{
     3cc:	b510      	push	{r4, lr}
	delay_init(SysTick);
     3ce:	4802      	ldr	r0, [pc, #8]	; (3d8 <delay_driver_init+0xc>)
     3d0:	4b02      	ldr	r3, [pc, #8]	; (3dc <delay_driver_init+0x10>)
     3d2:	4798      	blx	r3
}
     3d4:	bd10      	pop	{r4, pc}
     3d6:	46c0      	nop			; (mov r8, r8)
     3d8:	e000e010 	.word	0xe000e010
     3dc:	00000421 	.word	0x00000421

000003e0 <system_init>:

void system_init(void)
{
     3e0:	b510      	push	{r4, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
     3e2:	4b04      	ldr	r3, [pc, #16]	; (3f4 <system_init+0x14>)
     3e4:	4798      	blx	r3
	init_mcu();

	USART_On_USBPort_init();
     3e6:	4b04      	ldr	r3, [pc, #16]	; (3f8 <system_init+0x18>)
     3e8:	4798      	blx	r3

	SPI_0_init();
     3ea:	4b04      	ldr	r3, [pc, #16]	; (3fc <system_init+0x1c>)
     3ec:	4798      	blx	r3

	delay_driver_init();
     3ee:	4b04      	ldr	r3, [pc, #16]	; (400 <system_init+0x20>)
     3f0:	4798      	blx	r3
}
     3f2:	bd10      	pop	{r4, pc}
     3f4:	00000b71 	.word	0x00000b71
     3f8:	00000219 	.word	0x00000219
     3fc:	00000399 	.word	0x00000399
     400:	000003cd 	.word	0x000003cd

00000404 <atomic_enter_critical>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
     404:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
     408:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
     40a:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
     40c:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
     410:	4770      	bx	lr

00000412 <atomic_leave_critical>:
     412:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
     416:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
     418:	f383 8810 	msr	PRIMASK, r3
}
     41c:	4770      	bx	lr
	...

00000420 <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
     420:	b510      	push	{r4, lr}
	_delay_init(hardware = hw);
     422:	4b02      	ldr	r3, [pc, #8]	; (42c <delay_init+0xc>)
     424:	6018      	str	r0, [r3, #0]
     426:	4b02      	ldr	r3, [pc, #8]	; (430 <delay_init+0x10>)
     428:	4798      	blx	r3
}
     42a:	bd10      	pop	{r4, pc}
     42c:	20000060 	.word	0x20000060
     430:	0000123d 	.word	0x0000123d

00000434 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
     434:	b570      	push	{r4, r5, r6, lr}
     436:	0006      	movs	r6, r0
     438:	000c      	movs	r4, r1
     43a:	0015      	movs	r5, r2
	ASSERT(io_descr && buf);
     43c:	2800      	cmp	r0, #0
     43e:	d00d      	beq.n	45c <io_write+0x28>
     440:	0008      	movs	r0, r1
     442:	1e43      	subs	r3, r0, #1
     444:	4198      	sbcs	r0, r3
     446:	b2c0      	uxtb	r0, r0
     448:	2234      	movs	r2, #52	; 0x34
     44a:	4905      	ldr	r1, [pc, #20]	; (460 <io_write+0x2c>)
     44c:	4b05      	ldr	r3, [pc, #20]	; (464 <io_write+0x30>)
     44e:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
     450:	6833      	ldr	r3, [r6, #0]
     452:	002a      	movs	r2, r5
     454:	0021      	movs	r1, r4
     456:	0030      	movs	r0, r6
     458:	4798      	blx	r3
}
     45a:	bd70      	pop	{r4, r5, r6, pc}
     45c:	2000      	movs	r0, #0
     45e:	e7f3      	b.n	448 <io_write+0x14>
     460:	00002b68 	.word	0x00002b68
     464:	00000a69 	.word	0x00000a69

00000468 <spi_s_async_dev_complete>:

	spi->callbacks.rx(spi);
}

static void spi_s_async_dev_complete(struct _spi_s_async_dev *dev)
{
     468:	b510      	push	{r4, lr}
	struct spi_s_async_descriptor *spi = CONTAINER_OF(dev, struct spi_s_async_descriptor, dev);
     46a:	3804      	subs	r0, #4

	spi->callbacks.complete(spi);
     46c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
     46e:	4798      	blx	r3
}
     470:	bd10      	pop	{r4, pc}

00000472 <spi_s_async_dummy_func>:
 */
static void spi_s_async_dummy_func(struct spi_s_async_descriptor *spi, uint32_t param)
{
	(void)spi;
	(void)param;
}
     472:	4770      	bx	lr

00000474 <_spi_s_async_io_write>:
{
     474:	b5f0      	push	{r4, r5, r6, r7, lr}
     476:	b083      	sub	sp, #12
     478:	0004      	movs	r4, r0
     47a:	000d      	movs	r5, r1
     47c:	0016      	movs	r6, r2
	ASSERT(io);
     47e:	1e43      	subs	r3, r0, #1
     480:	4198      	sbcs	r0, r3
     482:	b2c0      	uxtb	r0, r0
     484:	2288      	movs	r2, #136	; 0x88
     486:	4917      	ldr	r1, [pc, #92]	; (4e4 <_spi_s_async_io_write+0x70>)
     488:	4b17      	ldr	r3, [pc, #92]	; (4e8 <_spi_s_async_io_write+0x74>)
     48a:	4798      	blx	r3
		return ERR_NONE;
     48c:	2000      	movs	r0, #0
	if (size == 0) {
     48e:	2e00      	cmp	r6, #0
     490:	d101      	bne.n	496 <_spi_s_async_io_write+0x22>
}
     492:	b003      	add	sp, #12
     494:	bdf0      	pop	{r4, r5, r6, r7, pc}
	atomic_enter_critical(&flags);
     496:	a801      	add	r0, sp, #4
     498:	4b14      	ldr	r3, [pc, #80]	; (4ec <_spi_s_async_io_write+0x78>)
     49a:	4798      	blx	r3
	if (spi->busy) {
     49c:	2255      	movs	r2, #85	; 0x55
     49e:	0023      	movs	r3, r4
     4a0:	3b24      	subs	r3, #36	; 0x24
     4a2:	5c9b      	ldrb	r3, [r3, r2]
     4a4:	07db      	lsls	r3, r3, #31
     4a6:	d416      	bmi.n	4d6 <_spi_s_async_io_write+0x62>
	spi->busy = 1;
     4a8:	0027      	movs	r7, r4
     4aa:	3f24      	subs	r7, #36	; 0x24
     4ac:	2255      	movs	r2, #85	; 0x55
     4ae:	5cbb      	ldrb	r3, [r7, r2]
     4b0:	2101      	movs	r1, #1
     4b2:	430b      	orrs	r3, r1
     4b4:	54bb      	strb	r3, [r7, r2]
	atomic_leave_critical(&flags);
     4b6:	a801      	add	r0, sp, #4
     4b8:	4b0d      	ldr	r3, [pc, #52]	; (4f0 <_spi_s_async_io_write+0x7c>)
     4ba:	4798      	blx	r3
	spi->txbuf  = (uint8_t *)buf;
     4bc:	63fd      	str	r5, [r7, #60]	; 0x3c
	spi->txcnt  = 0;
     4be:	2200      	movs	r2, #0
     4c0:	2342      	movs	r3, #66	; 0x42
     4c2:	52fa      	strh	r2, [r7, r3]
	spi->txsize = size;
     4c4:	3b02      	subs	r3, #2
     4c6:	52fe      	strh	r6, [r7, r3]
	_spi_s_async_enable_tx(&spi->dev, true);
     4c8:	0020      	movs	r0, r4
     4ca:	3820      	subs	r0, #32
     4cc:	2101      	movs	r1, #1
     4ce:	4b09      	ldr	r3, [pc, #36]	; (4f4 <_spi_s_async_io_write+0x80>)
     4d0:	4798      	blx	r3
	return ERR_NONE;
     4d2:	2000      	movs	r0, #0
     4d4:	e7dd      	b.n	492 <_spi_s_async_io_write+0x1e>
		atomic_leave_critical(&flags);
     4d6:	a801      	add	r0, sp, #4
     4d8:	4b05      	ldr	r3, [pc, #20]	; (4f0 <_spi_s_async_io_write+0x7c>)
     4da:	4798      	blx	r3
		return ERR_BUSY;
     4dc:	2004      	movs	r0, #4
     4de:	4240      	negs	r0, r0
     4e0:	e7d7      	b.n	492 <_spi_s_async_io_write+0x1e>
     4e2:	46c0      	nop			; (mov r8, r8)
     4e4:	00002b7c 	.word	0x00002b7c
     4e8:	00000a69 	.word	0x00000a69
     4ec:	00000405 	.word	0x00000405
     4f0:	00000413 	.word	0x00000413
     4f4:	000010e5 	.word	0x000010e5

000004f8 <_spi_s_async_io_read>:
{
     4f8:	b5f0      	push	{r4, r5, r6, r7, lr}
     4fa:	46c6      	mov	lr, r8
     4fc:	b500      	push	{lr}
     4fe:	b084      	sub	sp, #16
     500:	0007      	movs	r7, r0
     502:	000c      	movs	r4, r1
     504:	0016      	movs	r6, r2
	ASSERT(io);
     506:	1e43      	subs	r3, r0, #1
     508:	4198      	sbcs	r0, r3
     50a:	b2c0      	uxtb	r0, r0
     50c:	22b6      	movs	r2, #182	; 0xb6
     50e:	4920      	ldr	r1, [pc, #128]	; (590 <_spi_s_async_io_read+0x98>)
     510:	4b20      	ldr	r3, [pc, #128]	; (594 <_spi_s_async_io_read+0x9c>)
     512:	4798      	blx	r3
		return 0;
     514:	2000      	movs	r0, #0
	if (size == 0) {
     516:	2e00      	cmp	r6, #0
     518:	d103      	bne.n	522 <_spi_s_async_io_read+0x2a>
}
     51a:	b004      	add	sp, #16
     51c:	bc04      	pop	{r2}
     51e:	4690      	mov	r8, r2
     520:	bdf0      	pop	{r4, r5, r6, r7, pc}
	n_bytes = ringbuffer_num(&spi->rx_rb);
     522:	2320      	movs	r3, #32
     524:	469c      	mov	ip, r3
     526:	44bc      	add	ip, r7
     528:	4663      	mov	r3, ip
     52a:	9301      	str	r3, [sp, #4]
     52c:	4660      	mov	r0, ip
     52e:	4b1a      	ldr	r3, [pc, #104]	; (598 <_spi_s_async_io_read+0xa0>)
     530:	4798      	blx	r3
     532:	0003      	movs	r3, r0
		return 0;
     534:	2000      	movs	r0, #0
	if (n_bytes == 0) {
     536:	2b00      	cmp	r3, #0
     538:	d0ef      	beq.n	51a <_spi_s_async_io_read+0x22>
		switch (spi->dev.char_size) {
     53a:	003a      	movs	r2, r7
     53c:	3a24      	subs	r2, #36	; 0x24
     53e:	7a12      	ldrb	r2, [r2, #8]
     540:	2a02      	cmp	r2, #2
     542:	d101      	bne.n	548 <_spi_s_async_io_read+0x50>
			n <<= 1;
     544:	0076      	lsls	r6, r6, #1
     546:	b2b6      	uxth	r6, r6
     548:	429e      	cmp	r6, r3
     54a:	d900      	bls.n	54e <_spi_s_async_io_read+0x56>
     54c:	001e      	movs	r6, r3
	if (p == NULL) {
     54e:	2c00      	cmp	r4, #0
     550:	d012      	beq.n	578 <_spi_s_async_io_read+0x80>
     552:	19a3      	adds	r3, r4, r6
     554:	4698      	mov	r8, r3
		for (i = 0; i < n_bytes; i++) {
     556:	0021      	movs	r1, r4
     558:	2e00      	cmp	r6, #0
     55a:	d006      	beq.n	56a <_spi_s_async_io_read+0x72>
			ringbuffer_get(&spi->rx_rb, p++);
     55c:	4d0f      	ldr	r5, [pc, #60]	; (59c <_spi_s_async_io_read+0xa4>)
     55e:	1c4c      	adds	r4, r1, #1
     560:	9801      	ldr	r0, [sp, #4]
     562:	47a8      	blx	r5
     564:	0021      	movs	r1, r4
		for (i = 0; i < n_bytes; i++) {
     566:	4544      	cmp	r4, r8
     568:	d1f9      	bne.n	55e <_spi_s_async_io_read+0x66>
	switch (spi->dev.char_size) {
     56a:	3f24      	subs	r7, #36	; 0x24
     56c:	7a3b      	ldrb	r3, [r7, #8]
		return (int32_t)(n_bytes >> 1);
     56e:	0870      	lsrs	r0, r6, #1
	switch (spi->dev.char_size) {
     570:	2b02      	cmp	r3, #2
     572:	d0d2      	beq.n	51a <_spi_s_async_io_read+0x22>
		return (int32_t)n_bytes;
     574:	0030      	movs	r0, r6
     576:	e7d0      	b.n	51a <_spi_s_async_io_read+0x22>
		for (i = 0; i < n_bytes; i++) {
     578:	2e00      	cmp	r6, #0
     57a:	d0f6      	beq.n	56a <_spi_s_async_io_read+0x72>
     57c:	2400      	movs	r4, #0
			ringbuffer_get(&spi->rx_rb, &tmp);
     57e:	4d07      	ldr	r5, [pc, #28]	; (59c <_spi_s_async_io_read+0xa4>)
     580:	ab02      	add	r3, sp, #8
     582:	1dd9      	adds	r1, r3, #7
     584:	9801      	ldr	r0, [sp, #4]
     586:	47a8      	blx	r5
		for (i = 0; i < n_bytes; i++) {
     588:	3401      	adds	r4, #1
     58a:	42a6      	cmp	r6, r4
     58c:	d1f8      	bne.n	580 <_spi_s_async_io_read+0x88>
     58e:	e7ec      	b.n	56a <_spi_s_async_io_read+0x72>
     590:	00002b7c 	.word	0x00002b7c
     594:	00000a69 	.word	0x00000a69
     598:	00000b4d 	.word	0x00000b4d
     59c:	00000ac5 	.word	0x00000ac5

000005a0 <spi_s_async_dev_error>:
{
     5a0:	b570      	push	{r4, r5, r6, lr}
     5a2:	0004      	movs	r4, r0
     5a4:	000d      	movs	r5, r1
	_spi_s_async_enable_tx(dev, false);
     5a6:	2100      	movs	r1, #0
     5a8:	4b09      	ldr	r3, [pc, #36]	; (5d0 <spi_s_async_dev_error+0x30>)
     5aa:	4798      	blx	r3
	_spi_s_async_enable_rx(dev, false);
     5ac:	2100      	movs	r1, #0
     5ae:	0020      	movs	r0, r4
     5b0:	4b08      	ldr	r3, [pc, #32]	; (5d4 <spi_s_async_dev_error+0x34>)
     5b2:	4798      	blx	r3
	_spi_s_async_enable_ss_detect(dev, false);
     5b4:	2100      	movs	r1, #0
     5b6:	0020      	movs	r0, r4
     5b8:	4b07      	ldr	r3, [pc, #28]	; (5d8 <spi_s_async_dev_error+0x38>)
     5ba:	4798      	blx	r3
	spi->busy = 0;
     5bc:	1f20      	subs	r0, r4, #4
     5be:	2255      	movs	r2, #85	; 0x55
     5c0:	5c83      	ldrb	r3, [r0, r2]
     5c2:	2101      	movs	r1, #1
     5c4:	438b      	bics	r3, r1
     5c6:	5483      	strb	r3, [r0, r2]
	spi->callbacks.err(spi, status);
     5c8:	6b83      	ldr	r3, [r0, #56]	; 0x38
     5ca:	0029      	movs	r1, r5
     5cc:	4798      	blx	r3
}
     5ce:	bd70      	pop	{r4, r5, r6, pc}
     5d0:	000010e5 	.word	0x000010e5
     5d4:	00001139 	.word	0x00001139
     5d8:	00001185 	.word	0x00001185

000005dc <spi_s_async_dev_rx>:
{
     5dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     5de:	0004      	movs	r4, r0
	struct spi_s_async_descriptor *spi = CONTAINER_OF(dev, struct spi_s_async_descriptor, dev);
     5e0:	1f07      	subs	r7, r0, #4
	tmp.u16 = _spi_s_async_read_one(dev);
     5e2:	4b0a      	ldr	r3, [pc, #40]	; (60c <spi_s_async_dev_rx+0x30>)
     5e4:	4798      	blx	r3
     5e6:	0005      	movs	r5, r0
	ringbuffer_put(&spi->rx_rb, tmp.u8[0]);
     5e8:	0026      	movs	r6, r4
     5ea:	3640      	adds	r6, #64	; 0x40
     5ec:	b2c1      	uxtb	r1, r0
     5ee:	0030      	movs	r0, r6
     5f0:	4b07      	ldr	r3, [pc, #28]	; (610 <spi_s_async_dev_rx+0x34>)
     5f2:	4798      	blx	r3
	if (dev->char_size > 1) {
     5f4:	7923      	ldrb	r3, [r4, #4]
     5f6:	2b01      	cmp	r3, #1
     5f8:	d904      	bls.n	604 <spi_s_async_dev_rx+0x28>
		ringbuffer_put(&spi->rx_rb, tmp.u8[1]);
     5fa:	0429      	lsls	r1, r5, #16
     5fc:	0e09      	lsrs	r1, r1, #24
     5fe:	0030      	movs	r0, r6
     600:	4b03      	ldr	r3, [pc, #12]	; (610 <spi_s_async_dev_rx+0x34>)
     602:	4798      	blx	r3
	spi->callbacks.rx(spi);
     604:	6b23      	ldr	r3, [r4, #48]	; 0x30
     606:	0038      	movs	r0, r7
     608:	4798      	blx	r3
}
     60a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     60c:	000011c5 	.word	0x000011c5
     610:	00000b0d 	.word	0x00000b0d

00000614 <spi_s_async_dev_tx>:
{
     614:	b570      	push	{r4, r5, r6, lr}
     616:	0004      	movs	r4, r0
	if (dev->char_size > 1) {
     618:	7903      	ldrb	r3, [r0, #4]
     61a:	2b01      	cmp	r3, #1
     61c:	d90f      	bls.n	63e <spi_s_async_dev_tx+0x2a>
		_spi_s_async_write_one(dev, ((uint16_t *)spi->txbuf)[spi->txcnt++]);
     61e:	1f02      	subs	r2, r0, #4
     620:	6b80      	ldr	r0, [r0, #56]	; 0x38
     622:	2142      	movs	r1, #66	; 0x42
     624:	5a53      	ldrh	r3, [r2, r1]
     626:	1c5d      	adds	r5, r3, #1
     628:	5255      	strh	r5, [r2, r1]
     62a:	005b      	lsls	r3, r3, #1
     62c:	5a19      	ldrh	r1, [r3, r0]
     62e:	0020      	movs	r0, r4
     630:	4b0f      	ldr	r3, [pc, #60]	; (670 <spi_s_async_dev_tx+0x5c>)
     632:	4798      	blx	r3
	if (spi->txcnt >= spi->txsize) {
     634:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
     636:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
     638:	429a      	cmp	r2, r3
     63a:	d20b      	bcs.n	654 <spi_s_async_dev_tx+0x40>
}
     63c:	bd70      	pop	{r4, r5, r6, pc}
		_spi_s_async_write_one(dev, spi->txbuf[spi->txcnt++]);
     63e:	1f03      	subs	r3, r0, #4
     640:	6b80      	ldr	r0, [r0, #56]	; 0x38
     642:	2142      	movs	r1, #66	; 0x42
     644:	5a5a      	ldrh	r2, [r3, r1]
     646:	1c55      	adds	r5, r2, #1
     648:	525d      	strh	r5, [r3, r1]
     64a:	5c81      	ldrb	r1, [r0, r2]
     64c:	0020      	movs	r0, r4
     64e:	4b08      	ldr	r3, [pc, #32]	; (670 <spi_s_async_dev_tx+0x5c>)
     650:	4798      	blx	r3
     652:	e7ef      	b.n	634 <spi_s_async_dev_tx+0x20>
		_spi_s_async_enable_tx(dev, false);
     654:	2100      	movs	r1, #0
     656:	0020      	movs	r0, r4
     658:	4b06      	ldr	r3, [pc, #24]	; (674 <spi_s_async_dev_tx+0x60>)
     65a:	4798      	blx	r3
		spi->busy = 0;
     65c:	1f20      	subs	r0, r4, #4
     65e:	2255      	movs	r2, #85	; 0x55
     660:	5c83      	ldrb	r3, [r0, r2]
     662:	2101      	movs	r1, #1
     664:	438b      	bics	r3, r1
     666:	5483      	strb	r3, [r0, r2]
		spi->callbacks.tx(spi);
     668:	6b03      	ldr	r3, [r0, #48]	; 0x30
     66a:	4798      	blx	r3
}
     66c:	e7e6      	b.n	63c <spi_s_async_dev_tx+0x28>
     66e:	46c0      	nop			; (mov r8, r8)
     670:	00001191 	.word	0x00001191
     674:	000010e5 	.word	0x000010e5

00000678 <spi_s_async_init>:
	ASSERT(spi);
	spi->func = (struct _spi_s_async_hpl_interface *)func;
}

int32_t spi_s_async_init(struct spi_s_async_descriptor *spi, void *const hw, uint8_t *const rxbuf, int16_t bufsize)
{
     678:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     67a:	0004      	movs	r4, r0
     67c:	000d      	movs	r5, r1
     67e:	0016      	movs	r6, r2
     680:	001f      	movs	r7, r3
	int32_t rc;
	ASSERT(spi && hw && rxbuf && bufsize);
     682:	2800      	cmp	r0, #0
     684:	d03c      	beq.n	700 <spi_s_async_init+0x88>
     686:	2900      	cmp	r1, #0
     688:	d03c      	beq.n	704 <spi_s_async_init+0x8c>
     68a:	2a00      	cmp	r2, #0
     68c:	d03c      	beq.n	708 <spi_s_async_init+0x90>
     68e:	0018      	movs	r0, r3
     690:	1e43      	subs	r3, r0, #1
     692:	4198      	sbcs	r0, r3
     694:	22fb      	movs	r2, #251	; 0xfb
     696:	491d      	ldr	r1, [pc, #116]	; (70c <spi_s_async_init+0x94>)
     698:	4b1d      	ldr	r3, [pc, #116]	; (710 <spi_s_async_init+0x98>)
     69a:	4798      	blx	r3

	rc = ringbuffer_init(&spi->rx_rb, rxbuf, bufsize);
     69c:	0020      	movs	r0, r4
     69e:	3044      	adds	r0, #68	; 0x44
     6a0:	003a      	movs	r2, r7
     6a2:	0031      	movs	r1, r6
     6a4:	4b1b      	ldr	r3, [pc, #108]	; (714 <spi_s_async_init+0x9c>)
     6a6:	4798      	blx	r3
	if (rc < 0) {
     6a8:	2800      	cmp	r0, #0
     6aa:	db28      	blt.n	6fe <spi_s_async_init+0x86>
		return rc;
	}
	rc = _spi_s_async_init(&spi->dev, hw);
     6ac:	1d26      	adds	r6, r4, #4
     6ae:	0029      	movs	r1, r5
     6b0:	0030      	movs	r0, r6
     6b2:	4b19      	ldr	r3, [pc, #100]	; (718 <spi_s_async_init+0xa0>)
     6b4:	4798      	blx	r3

	if (rc < 0) {
     6b6:	2800      	cmp	r0, #0
     6b8:	db21      	blt.n	6fe <spi_s_async_init+0x86>
		return rc;
	}
	_spi_s_async_register_callback(&spi->dev, SPI_DEV_CB_TX, (const FUNC_PTR)spi_s_async_dev_tx);
     6ba:	4a18      	ldr	r2, [pc, #96]	; (71c <spi_s_async_init+0xa4>)
     6bc:	2100      	movs	r1, #0
     6be:	0030      	movs	r0, r6
     6c0:	4d17      	ldr	r5, [pc, #92]	; (720 <spi_s_async_init+0xa8>)
     6c2:	47a8      	blx	r5
	_spi_s_async_register_callback(&spi->dev, SPI_DEV_CB_RX, (const FUNC_PTR)spi_s_async_dev_rx);
     6c4:	4a17      	ldr	r2, [pc, #92]	; (724 <spi_s_async_init+0xac>)
     6c6:	2101      	movs	r1, #1
     6c8:	0030      	movs	r0, r6
     6ca:	47a8      	blx	r5
	_spi_s_async_register_callback(&spi->dev, SPI_DEV_CB_COMPLETE, (const FUNC_PTR)spi_s_async_dev_complete);
     6cc:	4a16      	ldr	r2, [pc, #88]	; (728 <spi_s_async_init+0xb0>)
     6ce:	2102      	movs	r1, #2
     6d0:	0030      	movs	r0, r6
     6d2:	47a8      	blx	r5
	_spi_s_async_register_callback(&spi->dev, SPI_DEV_CB_ERROR, (const FUNC_PTR)spi_s_async_dev_error);
     6d4:	4a15      	ldr	r2, [pc, #84]	; (72c <spi_s_async_init+0xb4>)
     6d6:	2103      	movs	r1, #3
     6d8:	0030      	movs	r0, r6
     6da:	47a8      	blx	r5

	spi->enabled = 0;
     6dc:	2255      	movs	r2, #85	; 0x55
     6de:	5ca3      	ldrb	r3, [r4, r2]
	spi->busy    = 0;
     6e0:	2102      	movs	r1, #2
     6e2:	438b      	bics	r3, r1
     6e4:	3901      	subs	r1, #1
     6e6:	438b      	bics	r3, r1
     6e8:	54a3      	strb	r3, [r4, r2]

	spi->callbacks.err      = (spi_s_async_cb_error_t)spi_s_async_dummy_func;
     6ea:	4b11      	ldr	r3, [pc, #68]	; (730 <spi_s_async_init+0xb8>)
     6ec:	63a3      	str	r3, [r4, #56]	; 0x38
	spi->callbacks.complete = (spi_s_async_cb_xfer_t)spi_s_async_dummy_func;
     6ee:	62e3      	str	r3, [r4, #44]	; 0x2c
	spi->callbacks.tx       = (spi_s_async_cb_xfer_t)spi_s_async_dummy_func;
     6f0:	6323      	str	r3, [r4, #48]	; 0x30
	spi->callbacks.rx       = (spi_s_async_cb_xfer_t)spi_s_async_dummy_func;
     6f2:	6363      	str	r3, [r4, #52]	; 0x34

	spi->io.read  = _spi_s_async_io_read;
     6f4:	4b0f      	ldr	r3, [pc, #60]	; (734 <spi_s_async_init+0xbc>)
     6f6:	62a3      	str	r3, [r4, #40]	; 0x28
	spi->io.write = _spi_s_async_io_write;
     6f8:	4b0f      	ldr	r3, [pc, #60]	; (738 <spi_s_async_init+0xc0>)
     6fa:	6263      	str	r3, [r4, #36]	; 0x24

	return ERR_NONE;
     6fc:	2000      	movs	r0, #0
}
     6fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(spi && hw && rxbuf && bufsize);
     700:	2000      	movs	r0, #0
     702:	e7c7      	b.n	694 <spi_s_async_init+0x1c>
     704:	2000      	movs	r0, #0
     706:	e7c5      	b.n	694 <spi_s_async_init+0x1c>
     708:	2000      	movs	r0, #0
     70a:	e7c3      	b.n	694 <spi_s_async_init+0x1c>
     70c:	00002b7c 	.word	0x00002b7c
     710:	00000a69 	.word	0x00000a69
     714:	00000a71 	.word	0x00000a71
     718:	0000109d 	.word	0x0000109d
     71c:	00000615 	.word	0x00000615
     720:	00001231 	.word	0x00001231
     724:	000005dd 	.word	0x000005dd
     728:	00000469 	.word	0x00000469
     72c:	000005a1 	.word	0x000005a1
     730:	00000473 	.word	0x00000473
     734:	000004f9 	.word	0x000004f9
     738:	00000475 	.word	0x00000475

0000073c <usart_transmission_complete>:
 * \brief Process completion of data sending
 *
 * \param[in] device The pointer to device structure
 */
static void usart_transmission_complete(struct _usart_async_device *device)
{
     73c:	b510      	push	{r4, lr}
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
     73e:	3808      	subs	r0, #8

	descr->stat = 0;
     740:	2300      	movs	r3, #0
     742:	6303      	str	r3, [r0, #48]	; 0x30
	if (descr->usart_cb.tx_done) {
     744:	6a43      	ldr	r3, [r0, #36]	; 0x24
     746:	2b00      	cmp	r3, #0
     748:	d000      	beq.n	74c <usart_transmission_complete+0x10>
		descr->usart_cb.tx_done(descr);
     74a:	4798      	blx	r3
	}
}
     74c:	bd10      	pop	{r4, pc}

0000074e <usart_error>:
 * \brief Process error interrupt
 *
 * \param[in] device The pointer to device structure
 */
static void usart_error(struct _usart_async_device *device)
{
     74e:	b510      	push	{r4, lr}
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
     750:	3808      	subs	r0, #8

	descr->stat = 0;
     752:	2300      	movs	r3, #0
     754:	6303      	str	r3, [r0, #48]	; 0x30
	if (descr->usart_cb.error) {
     756:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
     758:	2b00      	cmp	r3, #0
     75a:	d000      	beq.n	75e <usart_error+0x10>
		descr->usart_cb.error(descr);
     75c:	4798      	blx	r3
	}
}
     75e:	bd10      	pop	{r4, pc}

00000760 <usart_fill_rx_buffer>:
{
     760:	b510      	push	{r4, lr}
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
     762:	0004      	movs	r4, r0
	ringbuffer_put(&descr->rx, data);
     764:	302c      	adds	r0, #44	; 0x2c
     766:	4b04      	ldr	r3, [pc, #16]	; (778 <usart_fill_rx_buffer+0x18>)
     768:	4798      	blx	r3
	if (descr->usart_cb.rx_done) {
     76a:	6a23      	ldr	r3, [r4, #32]
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
     76c:	3c08      	subs	r4, #8
	if (descr->usart_cb.rx_done) {
     76e:	2b00      	cmp	r3, #0
     770:	d001      	beq.n	776 <usart_fill_rx_buffer+0x16>
		descr->usart_cb.rx_done(descr);
     772:	0020      	movs	r0, r4
     774:	4798      	blx	r3
}
     776:	bd10      	pop	{r4, pc}
     778:	00000b0d 	.word	0x00000b0d

0000077c <usart_async_write>:
{
     77c:	b570      	push	{r4, r5, r6, lr}
     77e:	0004      	movs	r4, r0
     780:	000e      	movs	r6, r1
     782:	0015      	movs	r5, r2
	ASSERT(descr && buf && length);
     784:	2800      	cmp	r0, #0
     786:	d01d      	beq.n	7c4 <usart_async_write+0x48>
     788:	2900      	cmp	r1, #0
     78a:	d01d      	beq.n	7c8 <usart_async_write+0x4c>
     78c:	0010      	movs	r0, r2
     78e:	1e43      	subs	r3, r0, #1
     790:	4198      	sbcs	r0, r3
     792:	223c      	movs	r2, #60	; 0x3c
     794:	32ff      	adds	r2, #255	; 0xff
     796:	490f      	ldr	r1, [pc, #60]	; (7d4 <usart_async_write+0x58>)
     798:	4b0f      	ldr	r3, [pc, #60]	; (7d8 <usart_async_write+0x5c>)
     79a:	4798      	blx	r3
	if (descr->tx_por != descr->tx_buffer_length) {
     79c:	2344      	movs	r3, #68	; 0x44
     79e:	5ae2      	ldrh	r2, [r4, r3]
     7a0:	3308      	adds	r3, #8
     7a2:	5ae3      	ldrh	r3, [r4, r3]
     7a4:	429a      	cmp	r2, r3
     7a6:	d111      	bne.n	7cc <usart_async_write+0x50>
	descr->tx_buffer        = (uint8_t *)buf;
     7a8:	64a6      	str	r6, [r4, #72]	; 0x48
	descr->tx_buffer_length = length;
     7aa:	234c      	movs	r3, #76	; 0x4c
     7ac:	52e5      	strh	r5, [r4, r3]
	descr->tx_por           = 0;
     7ae:	2200      	movs	r2, #0
     7b0:	3b08      	subs	r3, #8
     7b2:	52e2      	strh	r2, [r4, r3]
	descr->stat             = USART_ASYNC_STATUS_BUSY;
     7b4:	3b43      	subs	r3, #67	; 0x43
     7b6:	6323      	str	r3, [r4, #48]	; 0x30
	_usart_async_enable_byte_sent_irq(&descr->device);
     7b8:	0020      	movs	r0, r4
     7ba:	3008      	adds	r0, #8
     7bc:	4b07      	ldr	r3, [pc, #28]	; (7dc <usart_async_write+0x60>)
     7be:	4798      	blx	r3
	return (int32_t)length;
     7c0:	0028      	movs	r0, r5
}
     7c2:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && buf && length);
     7c4:	2000      	movs	r0, #0
     7c6:	e7e4      	b.n	792 <usart_async_write+0x16>
     7c8:	2000      	movs	r0, #0
     7ca:	e7e2      	b.n	792 <usart_async_write+0x16>
		return ERR_NO_RESOURCE;
     7cc:	201c      	movs	r0, #28
     7ce:	4240      	negs	r0, r0
     7d0:	e7f7      	b.n	7c2 <usart_async_write+0x46>
     7d2:	46c0      	nop			; (mov r8, r8)
     7d4:	00002b9c 	.word	0x00002b9c
     7d8:	00000a69 	.word	0x00000a69
     7dc:	00000e09 	.word	0x00000e09

000007e0 <usart_process_byte_sent>:
{
     7e0:	b570      	push	{r4, r5, r6, lr}
     7e2:	0004      	movs	r4, r0
	if (descr->tx_por != descr->tx_buffer_length) {
     7e4:	0001      	movs	r1, r0
     7e6:	3908      	subs	r1, #8
     7e8:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
     7ea:	224c      	movs	r2, #76	; 0x4c
     7ec:	5a8a      	ldrh	r2, [r1, r2]
     7ee:	429a      	cmp	r2, r3
     7f0:	d00c      	beq.n	80c <usart_process_byte_sent+0x2c>
		_usart_async_write_byte(&descr->device, descr->tx_buffer[descr->tx_por++]);
     7f2:	000a      	movs	r2, r1
     7f4:	6c89      	ldr	r1, [r1, #72]	; 0x48
     7f6:	1c5d      	adds	r5, r3, #1
     7f8:	2044      	movs	r0, #68	; 0x44
     7fa:	5215      	strh	r5, [r2, r0]
     7fc:	5cc9      	ldrb	r1, [r1, r3]
     7fe:	0020      	movs	r0, r4
     800:	4b04      	ldr	r3, [pc, #16]	; (814 <usart_process_byte_sent+0x34>)
     802:	4798      	blx	r3
		_usart_async_enable_byte_sent_irq(&descr->device);
     804:	0020      	movs	r0, r4
     806:	4b04      	ldr	r3, [pc, #16]	; (818 <usart_process_byte_sent+0x38>)
     808:	4798      	blx	r3
}
     80a:	bd70      	pop	{r4, r5, r6, pc}
		_usart_async_enable_tx_done_irq(&descr->device);
     80c:	4b03      	ldr	r3, [pc, #12]	; (81c <usart_process_byte_sent+0x3c>)
     80e:	4798      	blx	r3
}
     810:	e7fb      	b.n	80a <usart_process_byte_sent+0x2a>
     812:	46c0      	nop			; (mov r8, r8)
     814:	00000e01 	.word	0x00000e01
     818:	00000e09 	.word	0x00000e09
     81c:	00000e11 	.word	0x00000e11

00000820 <usart_async_read>:
{
     820:	b5f0      	push	{r4, r5, r6, r7, lr}
     822:	46ce      	mov	lr, r9
     824:	4647      	mov	r7, r8
     826:	b580      	push	{r7, lr}
     828:	b085      	sub	sp, #20
     82a:	0005      	movs	r5, r0
     82c:	000e      	movs	r6, r1
     82e:	0017      	movs	r7, r2
	ASSERT(descr && buf && length);
     830:	2800      	cmp	r0, #0
     832:	d015      	beq.n	860 <usart_async_read+0x40>
     834:	2900      	cmp	r1, #0
     836:	d013      	beq.n	860 <usart_async_read+0x40>
     838:	2a00      	cmp	r2, #0
     83a:	d12a      	bne.n	892 <usart_async_read+0x72>
     83c:	22ac      	movs	r2, #172	; 0xac
     83e:	0052      	lsls	r2, r2, #1
     840:	4929      	ldr	r1, [pc, #164]	; (8e8 <usart_async_read+0xc8>)
     842:	2000      	movs	r0, #0
     844:	4b29      	ldr	r3, [pc, #164]	; (8ec <usart_async_read+0xcc>)
     846:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
     848:	a803      	add	r0, sp, #12
     84a:	4b29      	ldr	r3, [pc, #164]	; (8f0 <usart_async_read+0xd0>)
     84c:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
     84e:	0028      	movs	r0, r5
     850:	3034      	adds	r0, #52	; 0x34
     852:	4b28      	ldr	r3, [pc, #160]	; (8f4 <usart_async_read+0xd4>)
     854:	4798      	blx	r3
	CRITICAL_SECTION_LEAVE()
     856:	a803      	add	r0, sp, #12
     858:	4b27      	ldr	r3, [pc, #156]	; (8f8 <usart_async_read+0xd8>)
     85a:	4798      	blx	r3
	uint16_t                       was_read = 0;
     85c:	2500      	movs	r5, #0
	return (int32_t)was_read;
     85e:	e03c      	b.n	8da <usart_async_read+0xba>
	ASSERT(descr && buf && length);
     860:	22ac      	movs	r2, #172	; 0xac
     862:	0052      	lsls	r2, r2, #1
     864:	4920      	ldr	r1, [pc, #128]	; (8e8 <usart_async_read+0xc8>)
     866:	2000      	movs	r0, #0
     868:	4b20      	ldr	r3, [pc, #128]	; (8ec <usart_async_read+0xcc>)
     86a:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
     86c:	a803      	add	r0, sp, #12
     86e:	4b20      	ldr	r3, [pc, #128]	; (8f0 <usart_async_read+0xd0>)
     870:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
     872:	3534      	adds	r5, #52	; 0x34
     874:	0028      	movs	r0, r5
     876:	9501      	str	r5, [sp, #4]
     878:	4b1e      	ldr	r3, [pc, #120]	; (8f4 <usart_async_read+0xd4>)
     87a:	4798      	blx	r3
     87c:	4680      	mov	r8, r0
	CRITICAL_SECTION_LEAVE()
     87e:	a803      	add	r0, sp, #12
     880:	4b1d      	ldr	r3, [pc, #116]	; (8f8 <usart_async_read+0xd8>)
     882:	4798      	blx	r3
	uint16_t                       was_read = 0;
     884:	2500      	movs	r5, #0
	while ((was_read < num) && (was_read < length)) {
     886:	4643      	mov	r3, r8
     888:	2b00      	cmp	r3, #0
     88a:	d026      	beq.n	8da <usart_async_read+0xba>
     88c:	2f00      	cmp	r7, #0
     88e:	d116      	bne.n	8be <usart_async_read+0x9e>
     890:	e023      	b.n	8da <usart_async_read+0xba>
	ASSERT(descr && buf && length);
     892:	22ac      	movs	r2, #172	; 0xac
     894:	0052      	lsls	r2, r2, #1
     896:	4914      	ldr	r1, [pc, #80]	; (8e8 <usart_async_read+0xc8>)
     898:	2001      	movs	r0, #1
     89a:	4b14      	ldr	r3, [pc, #80]	; (8ec <usart_async_read+0xcc>)
     89c:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
     89e:	a803      	add	r0, sp, #12
     8a0:	4b13      	ldr	r3, [pc, #76]	; (8f0 <usart_async_read+0xd0>)
     8a2:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
     8a4:	3534      	adds	r5, #52	; 0x34
     8a6:	0028      	movs	r0, r5
     8a8:	9501      	str	r5, [sp, #4]
     8aa:	4b12      	ldr	r3, [pc, #72]	; (8f4 <usart_async_read+0xd4>)
     8ac:	4798      	blx	r3
     8ae:	4680      	mov	r8, r0
	CRITICAL_SECTION_LEAVE()
     8b0:	a803      	add	r0, sp, #12
     8b2:	4b11      	ldr	r3, [pc, #68]	; (8f8 <usart_async_read+0xd8>)
     8b4:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
     8b6:	4643      	mov	r3, r8
	uint16_t                       was_read = 0;
     8b8:	2500      	movs	r5, #0
	while ((was_read < num) && (was_read < length)) {
     8ba:	2b00      	cmp	r3, #0
     8bc:	d00d      	beq.n	8da <usart_async_read+0xba>
{
     8be:	2400      	movs	r4, #0
		ringbuffer_get(&descr->rx, &buf[was_read++]);
     8c0:	4b0e      	ldr	r3, [pc, #56]	; (8fc <usart_async_read+0xdc>)
     8c2:	4699      	mov	r9, r3
     8c4:	1c65      	adds	r5, r4, #1
     8c6:	b2ad      	uxth	r5, r5
     8c8:	1931      	adds	r1, r6, r4
     8ca:	9801      	ldr	r0, [sp, #4]
     8cc:	47c8      	blx	r9
     8ce:	3401      	adds	r4, #1
	while ((was_read < num) && (was_read < length)) {
     8d0:	4544      	cmp	r4, r8
     8d2:	d202      	bcs.n	8da <usart_async_read+0xba>
     8d4:	b2a3      	uxth	r3, r4
     8d6:	429f      	cmp	r7, r3
     8d8:	d8f4      	bhi.n	8c4 <usart_async_read+0xa4>
}
     8da:	0028      	movs	r0, r5
     8dc:	b005      	add	sp, #20
     8de:	bc0c      	pop	{r2, r3}
     8e0:	4690      	mov	r8, r2
     8e2:	4699      	mov	r9, r3
     8e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
     8e6:	46c0      	nop			; (mov r8, r8)
     8e8:	00002b9c 	.word	0x00002b9c
     8ec:	00000a69 	.word	0x00000a69
     8f0:	00000405 	.word	0x00000405
     8f4:	00000b4d 	.word	0x00000b4d
     8f8:	00000413 	.word	0x00000413
     8fc:	00000ac5 	.word	0x00000ac5

00000900 <usart_async_init>:
{
     900:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     902:	0004      	movs	r4, r0
     904:	000d      	movs	r5, r1
     906:	0016      	movs	r6, r2
     908:	001f      	movs	r7, r3
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
     90a:	2800      	cmp	r0, #0
     90c:	d026      	beq.n	95c <usart_async_init+0x5c>
     90e:	2900      	cmp	r1, #0
     910:	d026      	beq.n	960 <usart_async_init+0x60>
     912:	2a00      	cmp	r2, #0
     914:	d026      	beq.n	964 <usart_async_init+0x64>
     916:	0018      	movs	r0, r3
     918:	1e43      	subs	r3, r0, #1
     91a:	4198      	sbcs	r0, r3
     91c:	223a      	movs	r2, #58	; 0x3a
     91e:	4914      	ldr	r1, [pc, #80]	; (970 <usart_async_init+0x70>)
     920:	4b14      	ldr	r3, [pc, #80]	; (974 <usart_async_init+0x74>)
     922:	4798      	blx	r3
	if (ERR_NONE != ringbuffer_init(&descr->rx, rx_buffer, rx_buffer_length)) {
     924:	0020      	movs	r0, r4
     926:	3034      	adds	r0, #52	; 0x34
     928:	003a      	movs	r2, r7
     92a:	0031      	movs	r1, r6
     92c:	4b12      	ldr	r3, [pc, #72]	; (978 <usart_async_init+0x78>)
     92e:	4798      	blx	r3
     930:	2800      	cmp	r0, #0
     932:	d119      	bne.n	968 <usart_async_init+0x68>
	init_status = _usart_async_init(&descr->device, hw);
     934:	0020      	movs	r0, r4
     936:	3008      	adds	r0, #8
     938:	0029      	movs	r1, r5
     93a:	4b10      	ldr	r3, [pc, #64]	; (97c <usart_async_init+0x7c>)
     93c:	4798      	blx	r3
	if (init_status) {
     93e:	2800      	cmp	r0, #0
     940:	d10b      	bne.n	95a <usart_async_init+0x5a>
	descr->io.read  = usart_async_read;
     942:	4b0f      	ldr	r3, [pc, #60]	; (980 <usart_async_init+0x80>)
     944:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_async_write;
     946:	4b0f      	ldr	r3, [pc, #60]	; (984 <usart_async_init+0x84>)
     948:	6023      	str	r3, [r4, #0]
	descr->device.usart_cb.tx_byte_sent = usart_process_byte_sent;
     94a:	4b0f      	ldr	r3, [pc, #60]	; (988 <usart_async_init+0x88>)
     94c:	60a3      	str	r3, [r4, #8]
	descr->device.usart_cb.rx_done_cb   = usart_fill_rx_buffer;
     94e:	4b0f      	ldr	r3, [pc, #60]	; (98c <usart_async_init+0x8c>)
     950:	60e3      	str	r3, [r4, #12]
	descr->device.usart_cb.tx_done_cb   = usart_transmission_complete;
     952:	4b0f      	ldr	r3, [pc, #60]	; (990 <usart_async_init+0x90>)
     954:	6123      	str	r3, [r4, #16]
	descr->device.usart_cb.error_cb     = usart_error;
     956:	4b0f      	ldr	r3, [pc, #60]	; (994 <usart_async_init+0x94>)
     958:	6163      	str	r3, [r4, #20]
}
     95a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
     95c:	2000      	movs	r0, #0
     95e:	e7dd      	b.n	91c <usart_async_init+0x1c>
     960:	2000      	movs	r0, #0
     962:	e7db      	b.n	91c <usart_async_init+0x1c>
     964:	2000      	movs	r0, #0
     966:	e7d9      	b.n	91c <usart_async_init+0x1c>
		return ERR_INVALID_ARG;
     968:	200d      	movs	r0, #13
     96a:	4240      	negs	r0, r0
     96c:	e7f5      	b.n	95a <usart_async_init+0x5a>
     96e:	46c0      	nop			; (mov r8, r8)
     970:	00002b9c 	.word	0x00002b9c
     974:	00000a69 	.word	0x00000a69
     978:	00000a71 	.word	0x00000a71
     97c:	00000d7d 	.word	0x00000d7d
     980:	00000821 	.word	0x00000821
     984:	0000077d 	.word	0x0000077d
     988:	000007e1 	.word	0x000007e1
     98c:	00000761 	.word	0x00000761
     990:	0000073d 	.word	0x0000073d
     994:	0000074f 	.word	0x0000074f

00000998 <usart_async_enable>:
{
     998:	b510      	push	{r4, lr}
     99a:	0004      	movs	r4, r0
	ASSERT(descr);
     99c:	1e43      	subs	r3, r0, #1
     99e:	4198      	sbcs	r0, r3
     9a0:	b2c0      	uxtb	r0, r0
     9a2:	2261      	movs	r2, #97	; 0x61
     9a4:	4904      	ldr	r1, [pc, #16]	; (9b8 <usart_async_enable+0x20>)
     9a6:	4b05      	ldr	r3, [pc, #20]	; (9bc <usart_async_enable+0x24>)
     9a8:	4798      	blx	r3
	_usart_async_enable(&descr->device);
     9aa:	0020      	movs	r0, r4
     9ac:	3008      	adds	r0, #8
     9ae:	4b04      	ldr	r3, [pc, #16]	; (9c0 <usart_async_enable+0x28>)
     9b0:	4798      	blx	r3
}
     9b2:	2000      	movs	r0, #0
     9b4:	bd10      	pop	{r4, pc}
     9b6:	46c0      	nop			; (mov r8, r8)
     9b8:	00002b9c 	.word	0x00002b9c
     9bc:	00000a69 	.word	0x00000a69
     9c0:	00000ded 	.word	0x00000ded

000009c4 <usart_async_get_io_descriptor>:
{
     9c4:	b570      	push	{r4, r5, r6, lr}
     9c6:	0004      	movs	r4, r0
     9c8:	000d      	movs	r5, r1
	ASSERT(descr && io);
     9ca:	2800      	cmp	r0, #0
     9cc:	d00a      	beq.n	9e4 <usart_async_get_io_descriptor+0x20>
     9ce:	0008      	movs	r0, r1
     9d0:	1e43      	subs	r3, r0, #1
     9d2:	4198      	sbcs	r0, r3
     9d4:	b2c0      	uxtb	r0, r0
     9d6:	2277      	movs	r2, #119	; 0x77
     9d8:	4903      	ldr	r1, [pc, #12]	; (9e8 <usart_async_get_io_descriptor+0x24>)
     9da:	4b04      	ldr	r3, [pc, #16]	; (9ec <usart_async_get_io_descriptor+0x28>)
     9dc:	4798      	blx	r3
	*io = &descr->io;
     9de:	602c      	str	r4, [r5, #0]
}
     9e0:	2000      	movs	r0, #0
     9e2:	bd70      	pop	{r4, r5, r6, pc}
     9e4:	2000      	movs	r0, #0
     9e6:	e7f6      	b.n	9d6 <usart_async_get_io_descriptor+0x12>
     9e8:	00002b9c 	.word	0x00002b9c
     9ec:	00000a69 	.word	0x00000a69

000009f0 <usart_async_register_callback>:
{
     9f0:	b570      	push	{r4, r5, r6, lr}
     9f2:	0005      	movs	r5, r0
     9f4:	000e      	movs	r6, r1
     9f6:	0014      	movs	r4, r2
	ASSERT(descr);
     9f8:	1e43      	subs	r3, r0, #1
     9fa:	4198      	sbcs	r0, r3
     9fc:	b2c0      	uxtb	r0, r0
     9fe:	2283      	movs	r2, #131	; 0x83
     a00:	4916      	ldr	r1, [pc, #88]	; (a5c <usart_async_register_callback+0x6c>)
     a02:	4b17      	ldr	r3, [pc, #92]	; (a60 <usart_async_register_callback+0x70>)
     a04:	4798      	blx	r3
	switch (type) {
     a06:	2e01      	cmp	r6, #1
     a08:	d011      	beq.n	a2e <usart_async_register_callback+0x3e>
     a0a:	2e00      	cmp	r6, #0
     a0c:	d004      	beq.n	a18 <usart_async_register_callback+0x28>
     a0e:	2e02      	cmp	r6, #2
     a10:	d018      	beq.n	a44 <usart_async_register_callback+0x54>
		return ERR_INVALID_ARG;
     a12:	200d      	movs	r0, #13
     a14:	4240      	negs	r0, r0
     a16:	e009      	b.n	a2c <usart_async_register_callback+0x3c>
		descr->usart_cb.rx_done = cb;
     a18:	62ac      	str	r4, [r5, #40]	; 0x28
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, NULL != cb);
     a1a:	1e62      	subs	r2, r4, #1
     a1c:	4194      	sbcs	r4, r2
     a1e:	b2e2      	uxtb	r2, r4
     a20:	0028      	movs	r0, r5
     a22:	3008      	adds	r0, #8
     a24:	2101      	movs	r1, #1
     a26:	4b0f      	ldr	r3, [pc, #60]	; (a64 <usart_async_register_callback+0x74>)
     a28:	4798      	blx	r3
	return ERR_NONE;
     a2a:	2000      	movs	r0, #0
}
     a2c:	bd70      	pop	{r4, r5, r6, pc}
		descr->usart_cb.tx_done = cb;
     a2e:	626c      	str	r4, [r5, #36]	; 0x24
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_TX_DONE, NULL != cb);
     a30:	1e62      	subs	r2, r4, #1
     a32:	4194      	sbcs	r4, r2
     a34:	b2e2      	uxtb	r2, r4
     a36:	0028      	movs	r0, r5
     a38:	3008      	adds	r0, #8
     a3a:	2102      	movs	r1, #2
     a3c:	4b09      	ldr	r3, [pc, #36]	; (a64 <usart_async_register_callback+0x74>)
     a3e:	4798      	blx	r3
	return ERR_NONE;
     a40:	2000      	movs	r0, #0
		break;
     a42:	e7f3      	b.n	a2c <usart_async_register_callback+0x3c>
		descr->usart_cb.error = cb;
     a44:	62ec      	str	r4, [r5, #44]	; 0x2c
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
     a46:	1e62      	subs	r2, r4, #1
     a48:	4194      	sbcs	r4, r2
     a4a:	b2e2      	uxtb	r2, r4
     a4c:	0028      	movs	r0, r5
     a4e:	3008      	adds	r0, #8
     a50:	2103      	movs	r1, #3
     a52:	4b04      	ldr	r3, [pc, #16]	; (a64 <usart_async_register_callback+0x74>)
     a54:	4798      	blx	r3
	return ERR_NONE;
     a56:	2000      	movs	r0, #0
		break;
     a58:	e7e8      	b.n	a2c <usart_async_register_callback+0x3c>
     a5a:	46c0      	nop			; (mov r8, r8)
     a5c:	00002b9c 	.word	0x00002b9c
     a60:	00000a69 	.word	0x00000a69
     a64:	00000e19 	.word	0x00000e19

00000a68 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
     a68:	2800      	cmp	r0, #0
     a6a:	d100      	bne.n	a6e <assert+0x6>
		__asm("BKPT #0");
     a6c:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
     a6e:	4770      	bx	lr

00000a70 <ringbuffer_init>:

/**
 * \brief Ringbuffer init
 */
int32_t ringbuffer_init(struct ringbuffer *const rb, void *buf, uint32_t size)
{
     a70:	b570      	push	{r4, r5, r6, lr}
     a72:	0004      	movs	r4, r0
     a74:	000e      	movs	r6, r1
     a76:	0015      	movs	r5, r2
	ASSERT(rb && buf && size);
     a78:	2800      	cmp	r0, #0
     a7a:	d00b      	beq.n	a94 <ringbuffer_init+0x24>
     a7c:	2900      	cmp	r1, #0
     a7e:	d018      	beq.n	ab2 <ringbuffer_init+0x42>
     a80:	2001      	movs	r0, #1
     a82:	2a00      	cmp	r2, #0
     a84:	d107      	bne.n	a96 <ringbuffer_init+0x26>
     a86:	2228      	movs	r2, #40	; 0x28
     a88:	490c      	ldr	r1, [pc, #48]	; (abc <ringbuffer_init+0x4c>)
     a8a:	2000      	movs	r0, #0
     a8c:	4b0c      	ldr	r3, [pc, #48]	; (ac0 <ringbuffer_init+0x50>)
     a8e:	4798      	blx	r3

	/*
	 * buf size must be aligned to power of 2
	 */
	if ((size & (size - 1)) != 0) {
     a90:	1e6b      	subs	r3, r5, #1
     a92:	e007      	b.n	aa4 <ringbuffer_init+0x34>
	ASSERT(rb && buf && size);
     a94:	2000      	movs	r0, #0
     a96:	2228      	movs	r2, #40	; 0x28
     a98:	4908      	ldr	r1, [pc, #32]	; (abc <ringbuffer_init+0x4c>)
     a9a:	4b09      	ldr	r3, [pc, #36]	; (ac0 <ringbuffer_init+0x50>)
     a9c:	4798      	blx	r3
	if ((size & (size - 1)) != 0) {
     a9e:	1e6b      	subs	r3, r5, #1
     aa0:	422b      	tst	r3, r5
     aa2:	d108      	bne.n	ab6 <ringbuffer_init+0x46>
		return ERR_INVALID_ARG;
	}

	/* size - 1 is faster in calculation */
	rb->size        = size - 1;
     aa4:	6063      	str	r3, [r4, #4]
	rb->read_index  = 0;
     aa6:	2300      	movs	r3, #0
     aa8:	60a3      	str	r3, [r4, #8]
	rb->write_index = rb->read_index;
     aaa:	60e3      	str	r3, [r4, #12]
	rb->buf         = (uint8_t *)buf;
     aac:	6026      	str	r6, [r4, #0]

	return ERR_NONE;
     aae:	2000      	movs	r0, #0
}
     ab0:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
     ab2:	2000      	movs	r0, #0
     ab4:	e7ef      	b.n	a96 <ringbuffer_init+0x26>
		return ERR_INVALID_ARG;
     ab6:	200d      	movs	r0, #13
     ab8:	4240      	negs	r0, r0
     aba:	e7f9      	b.n	ab0 <ringbuffer_init+0x40>
     abc:	00002bbc 	.word	0x00002bbc
     ac0:	00000a69 	.word	0x00000a69

00000ac4 <ringbuffer_get>:
/**
 * \brief Get one byte from ringbuffer
 *
 */
int32_t ringbuffer_get(struct ringbuffer *const rb, uint8_t *data)
{
     ac4:	b570      	push	{r4, r5, r6, lr}
     ac6:	0004      	movs	r4, r0
     ac8:	000d      	movs	r5, r1
	ASSERT(rb && data);
     aca:	2800      	cmp	r0, #0
     acc:	d015      	beq.n	afa <ringbuffer_get+0x36>
     ace:	0008      	movs	r0, r1
     ad0:	1e43      	subs	r3, r0, #1
     ad2:	4198      	sbcs	r0, r3
     ad4:	b2c0      	uxtb	r0, r0
     ad6:	2240      	movs	r2, #64	; 0x40
     ad8:	490a      	ldr	r1, [pc, #40]	; (b04 <ringbuffer_get+0x40>)
     ada:	4b0b      	ldr	r3, [pc, #44]	; (b08 <ringbuffer_get+0x44>)
     adc:	4798      	blx	r3

	if (rb->write_index != rb->read_index) {
     ade:	68a3      	ldr	r3, [r4, #8]
     ae0:	68e2      	ldr	r2, [r4, #12]
     ae2:	429a      	cmp	r2, r3
     ae4:	d00b      	beq.n	afe <ringbuffer_get+0x3a>
		*data = rb->buf[rb->read_index & rb->size];
     ae6:	6862      	ldr	r2, [r4, #4]
     ae8:	4013      	ands	r3, r2
     aea:	6822      	ldr	r2, [r4, #0]
     aec:	5cd3      	ldrb	r3, [r2, r3]
     aee:	702b      	strb	r3, [r5, #0]
		rb->read_index++;
     af0:	68a3      	ldr	r3, [r4, #8]
     af2:	3301      	adds	r3, #1
     af4:	60a3      	str	r3, [r4, #8]
		return ERR_NONE;
     af6:	2000      	movs	r0, #0
	}

	return ERR_NOT_FOUND;
}
     af8:	bd70      	pop	{r4, r5, r6, pc}
     afa:	2000      	movs	r0, #0
     afc:	e7eb      	b.n	ad6 <ringbuffer_get+0x12>
	return ERR_NOT_FOUND;
     afe:	200a      	movs	r0, #10
     b00:	4240      	negs	r0, r0
     b02:	e7f9      	b.n	af8 <ringbuffer_get+0x34>
     b04:	00002bbc 	.word	0x00002bbc
     b08:	00000a69 	.word	0x00000a69

00000b0c <ringbuffer_put>:
/**
 * \brief Put one byte to ringbuffer
 *
 */
int32_t ringbuffer_put(struct ringbuffer *const rb, uint8_t data)
{
     b0c:	b570      	push	{r4, r5, r6, lr}
     b0e:	0004      	movs	r4, r0
     b10:	000d      	movs	r5, r1
	ASSERT(rb);
     b12:	1e43      	subs	r3, r0, #1
     b14:	4198      	sbcs	r0, r3
     b16:	b2c0      	uxtb	r0, r0
     b18:	2251      	movs	r2, #81	; 0x51
     b1a:	490a      	ldr	r1, [pc, #40]	; (b44 <ringbuffer_put+0x38>)
     b1c:	4b0a      	ldr	r3, [pc, #40]	; (b48 <ringbuffer_put+0x3c>)
     b1e:	4798      	blx	r3

	rb->buf[rb->write_index & rb->size] = data;
     b20:	6863      	ldr	r3, [r4, #4]
     b22:	68e2      	ldr	r2, [r4, #12]
     b24:	4013      	ands	r3, r2
     b26:	6822      	ldr	r2, [r4, #0]
     b28:	54d5      	strb	r5, [r2, r3]

	/*
	 * buffer full strategy: new data will overwrite the oldest data in
	 * the buffer
	 */
	if ((rb->write_index - rb->read_index) > rb->size) {
     b2a:	68e3      	ldr	r3, [r4, #12]
     b2c:	6861      	ldr	r1, [r4, #4]
     b2e:	68a2      	ldr	r2, [r4, #8]
     b30:	1a9a      	subs	r2, r3, r2
     b32:	428a      	cmp	r2, r1
     b34:	d901      	bls.n	b3a <ringbuffer_put+0x2e>
		rb->read_index = rb->write_index - rb->size;
     b36:	1a59      	subs	r1, r3, r1
     b38:	60a1      	str	r1, [r4, #8]
	}

	rb->write_index++;
     b3a:	3301      	adds	r3, #1
     b3c:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
}
     b3e:	2000      	movs	r0, #0
     b40:	bd70      	pop	{r4, r5, r6, pc}
     b42:	46c0      	nop			; (mov r8, r8)
     b44:	00002bbc 	.word	0x00002bbc
     b48:	00000a69 	.word	0x00000a69

00000b4c <ringbuffer_num>:

/**
 * \brief Return the element number of ringbuffer
 */
uint32_t ringbuffer_num(const struct ringbuffer *const rb)
{
     b4c:	b510      	push	{r4, lr}
     b4e:	0004      	movs	r4, r0
	ASSERT(rb);
     b50:	1e43      	subs	r3, r0, #1
     b52:	4198      	sbcs	r0, r3
     b54:	b2c0      	uxtb	r0, r0
     b56:	2267      	movs	r2, #103	; 0x67
     b58:	4903      	ldr	r1, [pc, #12]	; (b68 <ringbuffer_num+0x1c>)
     b5a:	4b04      	ldr	r3, [pc, #16]	; (b6c <ringbuffer_num+0x20>)
     b5c:	4798      	blx	r3

	return rb->write_index - rb->read_index;
     b5e:	68e0      	ldr	r0, [r4, #12]
     b60:	68a3      	ldr	r3, [r4, #8]
     b62:	1ac0      	subs	r0, r0, r3
}
     b64:	bd10      	pop	{r4, pc}
     b66:	46c0      	nop			; (mov r8, r8)
     b68:	00002bbc 	.word	0x00002bbc
     b6c:	00000a69 	.word	0x00000a69

00000b70 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
     b70:	b510      	push	{r4, lr}
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
     b72:	4b08      	ldr	r3, [pc, #32]	; (b94 <_init_chip+0x24>)
     b74:	685a      	ldr	r2, [r3, #4]
     b76:	605a      	str	r2, [r3, #4]
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
     b78:	4b07      	ldr	r3, [pc, #28]	; (b98 <_init_chip+0x28>)
     b7a:	4798      	blx	r3
	_oscctrl_init_sources();
     b7c:	4b07      	ldr	r3, [pc, #28]	; (b9c <_init_chip+0x2c>)
     b7e:	4798      	blx	r3
	_mclk_init();
     b80:	4b07      	ldr	r3, [pc, #28]	; (ba0 <_init_chip+0x30>)
     b82:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
#endif
	_oscctrl_init_referenced_generators();
     b84:	4b07      	ldr	r3, [pc, #28]	; (ba4 <_init_chip+0x34>)
     b86:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
     b88:	20ff      	movs	r0, #255	; 0xff
     b8a:	4b07      	ldr	r3, [pc, #28]	; (ba8 <_init_chip+0x38>)
     b8c:	4798      	blx	r3

	_div_init();
     b8e:	4b07      	ldr	r3, [pc, #28]	; (bac <_init_chip+0x3c>)
     b90:	4798      	blx	r3
#endif

#if (CONF_PORT_EVCTRL_PORT_0 | CONF_PORT_EVCTRL_PORT_1 | CONF_PORT_EVCTRL_PORT_2 | CONF_PORT_EVCTRL_PORT_3)
	_port_event_init();
#endif
}
     b92:	bd10      	pop	{r4, pc}
     b94:	41004000 	.word	0x41004000
     b98:	00000bf1 	.word	0x00000bf1
     b9c:	00000c09 	.word	0x00000c09
     ba0:	00000be5 	.word	0x00000be5
     ba4:	00000c49 	.word	0x00000c49
     ba8:	00000bc1 	.word	0x00000bc1
     bac:	00000bb1 	.word	0x00000bb1

00000bb0 <_div_init>:

static inline void hri_divas_write_CTRLA_DLZ_bit(const void *const hw, bool value)
{
	uint8_t tmp;
	DIVAS_CRITICAL_SECTION_ENTER();
	tmp = ((Divas *)hw)->CTRLA.reg;
     bb0:	2290      	movs	r2, #144	; 0x90
     bb2:	05d2      	lsls	r2, r2, #23
     bb4:	7813      	ldrb	r3, [r2, #0]
	tmp &= ~DIVAS_CTRLA_DLZ;
     bb6:	2102      	movs	r1, #2
     bb8:	438b      	bics	r3, r1
	tmp |= value << DIVAS_CTRLA_DLZ_Pos;
	((Divas *)hw)->CTRLA.reg = tmp;
     bba:	7013      	strb	r3, [r2, #0]
 * \brief Initialize hardware for division operation
 */
void _div_init(void)
{
	hri_divas_write_CTRLA_DLZ_bit(DIVAS, CONF_DIVAS_DLZ);
}
     bbc:	4770      	bx	lr
	...

00000bc0 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
     bc0:	07c3      	lsls	r3, r0, #31
     bc2:	d507      	bpl.n	bd4 <_gclk_init_generators_by_fref+0x14>
	((Gclk *)hw)->GENCTRL[index].reg = data;
     bc4:	4a04      	ldr	r2, [pc, #16]	; (bd8 <_gclk_init_generators_by_fref+0x18>)
     bc6:	4b05      	ldr	r3, [pc, #20]	; (bdc <_gclk_init_generators_by_fref+0x1c>)
     bc8:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
     bca:	0019      	movs	r1, r3
     bcc:	4a04      	ldr	r2, [pc, #16]	; (be0 <_gclk_init_generators_by_fref+0x20>)
     bce:	684b      	ldr	r3, [r1, #4]
     bd0:	4213      	tst	r3, r2
     bd2:	d1fc      	bne.n	bce <_gclk_init_generators_by_fref+0xe>
		        | (CONF_GCLK_GEN_8_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_8_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_8_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_8_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_8_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_8_SOURCE);
	}
#endif
}
     bd4:	4770      	bx	lr
     bd6:	46c0      	nop			; (mov r8, r8)
     bd8:	00010106 	.word	0x00010106
     bdc:	40001c00 	.word	0x40001c00
     be0:	000007fd 	.word	0x000007fd

00000be4 <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
     be4:	2201      	movs	r2, #1
     be6:	4b01      	ldr	r3, [pc, #4]	; (bec <_mclk_init+0x8>)
     be8:	711a      	strb	r2, [r3, #4]
 */
void _mclk_init(void)
{
	void *hw = (void *)MCLK;
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_CPUDIV(CONF_MCLK_CPUDIV));
}
     bea:	4770      	bx	lr
     bec:	40000800 	.word	0x40000800

00000bf0 <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
     bf0:	4b04      	ldr	r3, [pc, #16]	; (c04 <_osc32kctrl_init_sources+0x14>)
     bf2:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSC32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSC32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
     bf4:	21f8      	movs	r1, #248	; 0xf8
     bf6:	0149      	lsls	r1, r1, #5
     bf8:	400a      	ands	r2, r1
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
     bfa:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
     bfc:	2201      	movs	r2, #1
     bfe:	611a      	str	r2, [r3, #16]
		;
#endif
#endif
	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
	(void)calib;
}
     c00:	4770      	bx	lr
     c02:	46c0      	nop			; (mov r8, r8)
     c04:	40001400 	.word	0x40001400

00000c08 <_oscctrl_init_sources>:
}

static inline void hri_oscctrl_write_OSC48MCTRL_reg(const void *const hw, hri_oscctrl_osc48mctrl_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MCTRL.reg = data;
     c08:	4b0e      	ldr	r3, [pc, #56]	; (c44 <_oscctrl_init_sources+0x3c>)
     c0a:	2202      	movs	r2, #2
     c0c:	751a      	strb	r2, [r3, #20]
}

static inline void hri_oscctrl_write_OSC48MDIV_reg(const void *const hw, hri_oscctrl_osc48mdiv_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MDIV.reg = data;
     c0e:	3209      	adds	r2, #9
     c10:	755a      	strb	r2, [r3, #21]
	while (((Oscctrl *)hw)->OSC48MSYNCBUSY.reg & reg) {
     c12:	0019      	movs	r1, r3
     c14:	3a07      	subs	r2, #7
     c16:	698b      	ldr	r3, [r1, #24]
     c18:	421a      	tst	r2, r3
     c1a:	d1fc      	bne.n	c16 <_oscctrl_init_sources+0xe>
	return (((Oscctrl *)hw)->OSC48MSYNCBUSY.reg & OSCCTRL_OSC48MSYNCBUSY_OSC48MDIV)
     c1c:	4909      	ldr	r1, [pc, #36]	; (c44 <_oscctrl_init_sources+0x3c>)
#if CONF_OSC48M_CONFIG == 1
	hri_oscctrl_write_OSC48MCTRL_reg(hw,
	                                 (CONF_OSC48M_RUNSTDBY << OSCCTRL_OSC48MCTRL_RUNSTDBY_Pos)
	                                     | (CONF_OSC48M_ENABLE << OSCCTRL_OSC48MCTRL_ENABLE_Pos));
	hri_oscctrl_write_OSC48MDIV_reg(hw, OSCCTRL_OSC48MDIV_DIV(CONF_OSC48M_DIV));
	while (hri_oscctrl_get_OSC48MSYNCBUSY_OSC48MDIV_bit(hw))
     c1e:	2204      	movs	r2, #4
     c20:	698b      	ldr	r3, [r1, #24]
     c22:	421a      	tst	r2, r3
     c24:	d1fc      	bne.n	c20 <_oscctrl_init_sources+0x18>
}

static inline void hri_oscctrl_write_OSC48MSTUP_reg(const void *const hw, hri_oscctrl_osc48mstup_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MSTUP.reg = data;
     c26:	2207      	movs	r2, #7
     c28:	4b06      	ldr	r3, [pc, #24]	; (c44 <_oscctrl_init_sources+0x3c>)
     c2a:	759a      	strb	r2, [r3, #22]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_OSC48MRDY) >> OSCCTRL_STATUS_OSC48MRDY_Pos;
     c2c:	0019      	movs	r1, r3
#endif
#endif

#if CONF_OSC48M_CONFIG == 1
#if CONF_OSC48M_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_OSC48MRDY_bit(hw))
     c2e:	3209      	adds	r2, #9
     c30:	68cb      	ldr	r3, [r1, #12]
     c32:	421a      	tst	r2, r3
     c34:	d0fc      	beq.n	c30 <_oscctrl_init_sources+0x28>
	((Oscctrl *)hw)->OSC48MCTRL.reg |= OSCCTRL_OSC48MCTRL_ONDEMAND;
     c36:	4a03      	ldr	r2, [pc, #12]	; (c44 <_oscctrl_init_sources+0x3c>)
     c38:	7d13      	ldrb	r3, [r2, #20]
     c3a:	2180      	movs	r1, #128	; 0x80
     c3c:	430b      	orrs	r3, r1
     c3e:	7513      	strb	r3, [r2, #20]
#if CONF_OSC48M_ONDEMAND == 1
	hri_oscctrl_set_OSC48MCTRL_ONDEMAND_bit(hw);
#endif
#endif
	(void)hw;
}
     c40:	4770      	bx	lr
     c42:	46c0      	nop			; (mov r8, r8)
     c44:	40001000 	.word	0x40001000

00000c48 <_oscctrl_init_referenced_generators>:
#if CONF_DPLL_ONDEMAND == 1
	hri_oscctrl_set_DPLLCTRLA_ONDEMAND_bit(hw);
#endif
#endif
	(void)hw;
}
     c48:	4770      	bx	lr
	...

00000c4c <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
     c4c:	b530      	push	{r4, r5, lr}
     c4e:	b089      	sub	sp, #36	; 0x24
	Sercom *const sercom_modules[] = SERCOM_INSTS;
     c50:	4b0c      	ldr	r3, [pc, #48]	; (c84 <_sercom_get_hardware_index+0x38>)
     c52:	466a      	mov	r2, sp
     c54:	cb32      	ldmia	r3!, {r1, r4, r5}
     c56:	c232      	stmia	r2!, {r1, r4, r5}
     c58:	cb32      	ldmia	r3!, {r1, r4, r5}
     c5a:	c232      	stmia	r2!, {r1, r4, r5}
     c5c:	cb12      	ldmia	r3!, {r1, r4}
     c5e:	c212      	stmia	r2!, {r1, r4}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
     c60:	9b00      	ldr	r3, [sp, #0]
     c62:	4283      	cmp	r3, r0
     c64:	d00b      	beq.n	c7e <_sercom_get_hardware_index+0x32>
     c66:	2301      	movs	r3, #1
     c68:	009a      	lsls	r2, r3, #2
     c6a:	4669      	mov	r1, sp
     c6c:	5852      	ldr	r2, [r2, r1]
     c6e:	4282      	cmp	r2, r0
     c70:	d006      	beq.n	c80 <_sercom_get_hardware_index+0x34>
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     c72:	3301      	adds	r3, #1
     c74:	2b08      	cmp	r3, #8
     c76:	d1f7      	bne.n	c68 <_sercom_get_hardware_index+0x1c>
			return i;
		}
	}
	return 0;
     c78:	2000      	movs	r0, #0
}
     c7a:	b009      	add	sp, #36	; 0x24
     c7c:	bd30      	pop	{r4, r5, pc}
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     c7e:	2300      	movs	r3, #0
			return i;
     c80:	b2d8      	uxtb	r0, r3
     c82:	e7fa      	b.n	c7a <_sercom_get_hardware_index+0x2e>
     c84:	00002be0 	.word	0x00002be0

00000c88 <_sercom_init_irq_param>:
 * \brief Init irq param with the given sercom hardware instance
 */
static void _sercom_init_irq_param(const void *const hw, void *dev)
{

	if (hw == SERCOM4) {
     c88:	4b06      	ldr	r3, [pc, #24]	; (ca4 <_sercom_init_irq_param+0x1c>)
     c8a:	4298      	cmp	r0, r3
     c8c:	d003      	beq.n	c96 <_sercom_init_irq_param+0xe>
		_sercom4_dev = (struct _usart_async_device *)dev;
	}

	if (hw == SERCOM7) {
     c8e:	4b06      	ldr	r3, [pc, #24]	; (ca8 <_sercom_init_irq_param+0x20>)
     c90:	4298      	cmp	r0, r3
     c92:	d003      	beq.n	c9c <_sercom_init_irq_param+0x14>
		_sercom7_dev = (struct _spi_async_dev *)dev;
	}
}
     c94:	4770      	bx	lr
		_sercom4_dev = (struct _usart_async_device *)dev;
     c96:	4b05      	ldr	r3, [pc, #20]	; (cac <_sercom_init_irq_param+0x24>)
     c98:	6019      	str	r1, [r3, #0]
     c9a:	e7fb      	b.n	c94 <_sercom_init_irq_param+0xc>
		_sercom7_dev = (struct _spi_async_dev *)dev;
     c9c:	4b03      	ldr	r3, [pc, #12]	; (cac <_sercom_init_irq_param+0x24>)
     c9e:	6059      	str	r1, [r3, #4]
}
     ca0:	e7f8      	b.n	c94 <_sercom_init_irq_param+0xc>
     ca2:	46c0      	nop			; (mov r8, r8)
     ca4:	42001400 	.word	0x42001400
     ca8:	43000400 	.word	0x43000400
     cac:	20000064 	.word	0x20000064

00000cb0 <_sercom_get_irq_num>:

/**
 * \brief Retrieve IRQ number for the given hardware instance
 */
static uint8_t _sercom_get_irq_num(const void *const hw)
{
     cb0:	b510      	push	{r4, lr}
	if (SERCOM6 == hw || SERCOM7 == hw) {
     cb2:	2386      	movs	r3, #134	; 0x86
     cb4:	05db      	lsls	r3, r3, #23
     cb6:	4298      	cmp	r0, r3
     cb8:	d007      	beq.n	cca <_sercom_get_irq_num+0x1a>
     cba:	4b08      	ldr	r3, [pc, #32]	; (cdc <_sercom_get_irq_num+0x2c>)
     cbc:	4298      	cmp	r0, r3
     cbe:	d004      	beq.n	cca <_sercom_get_irq_num+0x1a>
		return SERCOM6_IRQn + (((uint32_t)hw - (uint32_t)SERCOM6) >> 10);
	} else {
		return SERCOM0_IRQn + _sercom_get_hardware_index(hw);
     cc0:	4b07      	ldr	r3, [pc, #28]	; (ce0 <_sercom_get_irq_num+0x30>)
     cc2:	4798      	blx	r3
     cc4:	3009      	adds	r0, #9
     cc6:	b2c0      	uxtb	r0, r0
	}
}
     cc8:	bd10      	pop	{r4, pc}
		return SERCOM6_IRQn + (((uint32_t)hw - (uint32_t)SERCOM6) >> 10);
     cca:	23bd      	movs	r3, #189	; 0xbd
     ccc:	061b      	lsls	r3, r3, #24
     cce:	469c      	mov	ip, r3
     cd0:	4460      	add	r0, ip
     cd2:	0a80      	lsrs	r0, r0, #10
     cd4:	3009      	adds	r0, #9
     cd6:	b2c0      	uxtb	r0, r0
     cd8:	e7f6      	b.n	cc8 <_sercom_get_irq_num+0x18>
     cda:	46c0      	nop			; (mov r8, r8)
     cdc:	43000400 	.word	0x43000400
     ce0:	00000c4d 	.word	0x00000c4d

00000ce4 <_usart_init>:
{
     ce4:	b510      	push	{r4, lr}
     ce6:	0004      	movs	r4, r0
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
     ce8:	4b1e      	ldr	r3, [pc, #120]	; (d64 <_usart_init+0x80>)
     cea:	4798      	blx	r3
		if (_usarts[i].number == sercom_offset) {
     cec:	2804      	cmp	r0, #4
     cee:	d004      	beq.n	cfa <_usart_init+0x16>
	ASSERT(false);
     cf0:	4a1d      	ldr	r2, [pc, #116]	; (d68 <_usart_init+0x84>)
     cf2:	491e      	ldr	r1, [pc, #120]	; (d6c <_usart_init+0x88>)
     cf4:	2000      	movs	r0, #0
     cf6:	4b1e      	ldr	r3, [pc, #120]	; (d70 <_usart_init+0x8c>)
     cf8:	4798      	blx	r3
	};
}

static inline bool hri_sercomusart_is_syncing(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
     cfa:	69e3      	ldr	r3, [r4, #28]
	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
     cfc:	07db      	lsls	r3, r3, #31
     cfe:	d418      	bmi.n	d32 <_usart_init+0x4e>
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     d00:	2203      	movs	r2, #3
     d02:	69e3      	ldr	r3, [r4, #28]
     d04:	421a      	tst	r2, r3
     d06:	d1fc      	bne.n	d02 <_usart_init+0x1e>
static inline hri_sercomusart_ctrla_reg_t hri_sercomusart_get_CTRLA_reg(const void *const           hw,
                                                                        hri_sercomusart_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
     d08:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
     d0a:	079b      	lsls	r3, r3, #30
     d0c:	d50b      	bpl.n	d26 <_usart_init+0x42>
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
     d0e:	6823      	ldr	r3, [r4, #0]
     d10:	2202      	movs	r2, #2
     d12:	4393      	bics	r3, r2
     d14:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     d16:	3201      	adds	r2, #1
     d18:	69e3      	ldr	r3, [r4, #28]
     d1a:	421a      	tst	r2, r3
     d1c:	d1fc      	bne.n	d18 <_usart_init+0x34>
     d1e:	2202      	movs	r2, #2
     d20:	69e3      	ldr	r3, [r4, #28]
     d22:	421a      	tst	r2, r3
     d24:	d1fc      	bne.n	d20 <_usart_init+0x3c>
}

static inline void hri_sercomusart_write_CTRLA_reg(const void *const hw, hri_sercomusart_ctrla_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg = data;
     d26:	2305      	movs	r3, #5
     d28:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     d2a:	2203      	movs	r2, #3
     d2c:	69e3      	ldr	r3, [r4, #28]
     d2e:	421a      	tst	r2, r3
     d30:	d1fc      	bne.n	d2c <_usart_init+0x48>
     d32:	2201      	movs	r2, #1
     d34:	69e3      	ldr	r3, [r4, #28]
     d36:	421a      	tst	r2, r3
     d38:	d1fc      	bne.n	d34 <_usart_init+0x50>
	((Sercom *)hw)->USART.CTRLA.reg = data;
     d3a:	4b0e      	ldr	r3, [pc, #56]	; (d74 <_usart_init+0x90>)
     d3c:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     d3e:	2203      	movs	r2, #3
     d40:	69e3      	ldr	r3, [r4, #28]
     d42:	421a      	tst	r2, r3
     d44:	d1fc      	bne.n	d40 <_usart_init+0x5c>
}

static inline void hri_sercomusart_write_CTRLB_reg(const void *const hw, hri_sercomusart_ctrlb_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLB.reg = data;
     d46:	23c0      	movs	r3, #192	; 0xc0
     d48:	029b      	lsls	r3, r3, #10
     d4a:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     d4c:	2207      	movs	r2, #7
     d4e:	69e3      	ldr	r3, [r4, #28]
     d50:	421a      	tst	r2, r3
     d52:	d1fc      	bne.n	d4e <_usart_init+0x6a>
}

static inline void hri_sercomusart_write_BAUD_reg(const void *const hw, hri_sercomusart_baud_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.BAUD.reg = data;
     d54:	4b08      	ldr	r3, [pc, #32]	; (d78 <_usart_init+0x94>)
     d56:	81a3      	strh	r3, [r4, #12]
}

static inline void hri_sercomusart_write_RXPL_reg(const void *const hw, hri_sercomusart_rxpl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.RXPL.reg = data;
     d58:	2300      	movs	r3, #0
     d5a:	73a3      	strb	r3, [r4, #14]
}

static inline void hri_sercomusart_write_DBGCTRL_reg(const void *const hw, hri_sercomusart_dbgctrl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
     d5c:	2230      	movs	r2, #48	; 0x30
     d5e:	54a3      	strb	r3, [r4, r2]
}
     d60:	2000      	movs	r0, #0
     d62:	bd10      	pop	{r4, pc}
     d64:	00000c4d 	.word	0x00000c4d
     d68:	00000263 	.word	0x00000263
     d6c:	00002c18 	.word	0x00002c18
     d70:	00000a69 	.word	0x00000a69
     d74:	40310004 	.word	0x40310004
     d78:	fffff62b 	.word	0xfffff62b

00000d7c <_usart_async_init>:
{
     d7c:	b570      	push	{r4, r5, r6, lr}
     d7e:	0006      	movs	r6, r0
     d80:	000c      	movs	r4, r1
	ASSERT(device);
     d82:	1e43      	subs	r3, r0, #1
     d84:	4198      	sbcs	r0, r3
     d86:	b2c0      	uxtb	r0, r0
     d88:	22c6      	movs	r2, #198	; 0xc6
     d8a:	4912      	ldr	r1, [pc, #72]	; (dd4 <_usart_async_init+0x58>)
     d8c:	4b12      	ldr	r3, [pc, #72]	; (dd8 <_usart_async_init+0x5c>)
     d8e:	4798      	blx	r3
	init_status = _usart_init(hw);
     d90:	0020      	movs	r0, r4
     d92:	4b12      	ldr	r3, [pc, #72]	; (ddc <_usart_async_init+0x60>)
     d94:	4798      	blx	r3
     d96:	1e05      	subs	r5, r0, #0
	if (init_status) {
     d98:	d001      	beq.n	d9e <_usart_async_init+0x22>
}
     d9a:	0028      	movs	r0, r5
     d9c:	bd70      	pop	{r4, r5, r6, pc}
	device->hw = hw;
     d9e:	61b4      	str	r4, [r6, #24]
	_sercom_init_irq_param(hw, (void *)device);
     da0:	0031      	movs	r1, r6
     da2:	0020      	movs	r0, r4
     da4:	4b0e      	ldr	r3, [pc, #56]	; (de0 <_usart_async_init+0x64>)
     da6:	4798      	blx	r3
	NVIC_DisableIRQ((IRQn_Type)_sercom_get_irq_num(hw));
     da8:	0020      	movs	r0, r4
     daa:	4b0e      	ldr	r3, [pc, #56]	; (de4 <_usart_async_init+0x68>)
     dac:	4798      	blx	r3
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
     dae:	0603      	lsls	r3, r0, #24
     db0:	d4f3      	bmi.n	d9a <_usart_async_init+0x1e>
  {
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     db2:	231f      	movs	r3, #31
     db4:	4018      	ands	r0, r3
     db6:	3b1e      	subs	r3, #30
     db8:	4083      	lsls	r3, r0
     dba:	4a0b      	ldr	r2, [pc, #44]	; (de8 <_usart_async_init+0x6c>)
     dbc:	2180      	movs	r1, #128	; 0x80
     dbe:	5053      	str	r3, [r2, r1]
  __ASM volatile ("dsb 0xF":::"memory");
     dc0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     dc4:	f3bf 8f6f 	isb	sy
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     dc8:	3101      	adds	r1, #1
     dca:	31ff      	adds	r1, #255	; 0xff
     dcc:	5053      	str	r3, [r2, r1]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     dce:	6013      	str	r3, [r2, #0]
     dd0:	e7e3      	b.n	d9a <_usart_async_init+0x1e>
     dd2:	46c0      	nop			; (mov r8, r8)
     dd4:	00002c18 	.word	0x00002c18
     dd8:	00000a69 	.word	0x00000a69
     ddc:	00000ce5 	.word	0x00000ce5
     de0:	00000c89 	.word	0x00000c89
     de4:	00000cb1 	.word	0x00000cb1
     de8:	e000e100 	.word	0xe000e100

00000dec <_usart_async_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
     dec:	6982      	ldr	r2, [r0, #24]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
     dee:	6813      	ldr	r3, [r2, #0]
     df0:	2102      	movs	r1, #2
     df2:	430b      	orrs	r3, r1
     df4:	6013      	str	r3, [r2, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     df6:	3101      	adds	r1, #1
     df8:	69d3      	ldr	r3, [r2, #28]
     dfa:	4219      	tst	r1, r3
     dfc:	d1fc      	bne.n	df8 <_usart_async_enable+0xc>
}
     dfe:	4770      	bx	lr

00000e00 <_usart_async_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
     e00:	6983      	ldr	r3, [r0, #24]
     e02:	b289      	uxth	r1, r1
	((Sercom *)hw)->USART.DATA.reg = data;
     e04:	8519      	strh	r1, [r3, #40]	; 0x28
}
     e06:	4770      	bx	lr

00000e08 <_usart_async_enable_byte_sent_irq>:
	hri_sercomusart_set_INTEN_DRE_bit(device->hw);
     e08:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
     e0a:	2201      	movs	r2, #1
     e0c:	759a      	strb	r2, [r3, #22]
}
     e0e:	4770      	bx	lr

00000e10 <_usart_async_enable_tx_done_irq>:
	hri_sercomusart_set_INTEN_TXC_bit(device->hw);
     e10:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
     e12:	2202      	movs	r2, #2
     e14:	759a      	strb	r2, [r3, #22]
}
     e16:	4770      	bx	lr

00000e18 <_usart_async_set_irq_state>:
{
     e18:	b570      	push	{r4, r5, r6, lr}
     e1a:	0004      	movs	r4, r0
     e1c:	000d      	movs	r5, r1
     e1e:	0016      	movs	r6, r2
	ASSERT(device);
     e20:	1e43      	subs	r3, r0, #1
     e22:	4198      	sbcs	r0, r3
     e24:	b2c0      	uxtb	r0, r0
     e26:	4a16      	ldr	r2, [pc, #88]	; (e80 <_usart_async_set_irq_state+0x68>)
     e28:	4916      	ldr	r1, [pc, #88]	; (e84 <_usart_async_set_irq_state+0x6c>)
     e2a:	4b17      	ldr	r3, [pc, #92]	; (e88 <_usart_async_set_irq_state+0x70>)
     e2c:	4798      	blx	r3
	if (USART_ASYNC_BYTE_SENT == type || USART_ASYNC_TX_DONE == type) {
     e2e:	2302      	movs	r3, #2
     e30:	002a      	movs	r2, r5
     e32:	439a      	bics	r2, r3
     e34:	d10e      	bne.n	e54 <_usart_async_set_irq_state+0x3c>
		hri_sercomusart_write_INTEN_DRE_bit(device->hw, state);
     e36:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
     e38:	2e00      	cmp	r6, #0
     e3a:	d105      	bne.n	e48 <_usart_async_set_irq_state+0x30>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
     e3c:	2201      	movs	r2, #1
     e3e:	751a      	strb	r2, [r3, #20]
		hri_sercomusart_write_INTEN_TXC_bit(device->hw, state);
     e40:	69a3      	ldr	r3, [r4, #24]
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
     e42:	3201      	adds	r2, #1
     e44:	751a      	strb	r2, [r3, #20]
}
     e46:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
     e48:	2201      	movs	r2, #1
     e4a:	759a      	strb	r2, [r3, #22]
		hri_sercomusart_write_INTEN_TXC_bit(device->hw, state);
     e4c:	69a3      	ldr	r3, [r4, #24]
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
     e4e:	3201      	adds	r2, #1
     e50:	759a      	strb	r2, [r3, #22]
     e52:	e7f8      	b.n	e46 <_usart_async_set_irq_state+0x2e>
	} else if (USART_ASYNC_RX_DONE == type) {
     e54:	2d01      	cmp	r5, #1
     e56:	d007      	beq.n	e68 <_usart_async_set_irq_state+0x50>
	} else if (USART_ASYNC_ERROR == type) {
     e58:	2d03      	cmp	r5, #3
     e5a:	d1f4      	bne.n	e46 <_usart_async_set_irq_state+0x2e>
		hri_sercomusart_write_INTEN_ERROR_bit(device->hw, state);
     e5c:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
     e5e:	2e00      	cmp	r6, #0
     e60:	d00b      	beq.n	e7a <_usart_async_set_irq_state+0x62>
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_ERROR;
     e62:	2280      	movs	r2, #128	; 0x80
     e64:	759a      	strb	r2, [r3, #22]
}
     e66:	e7ee      	b.n	e46 <_usart_async_set_irq_state+0x2e>
		hri_sercomusart_write_INTEN_RXC_bit(device->hw, state);
     e68:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
     e6a:	2e00      	cmp	r6, #0
     e6c:	d102      	bne.n	e74 <_usart_async_set_irq_state+0x5c>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_RXC;
     e6e:	2204      	movs	r2, #4
     e70:	751a      	strb	r2, [r3, #20]
     e72:	e7e8      	b.n	e46 <_usart_async_set_irq_state+0x2e>
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_RXC;
     e74:	2204      	movs	r2, #4
     e76:	759a      	strb	r2, [r3, #22]
     e78:	e7e5      	b.n	e46 <_usart_async_set_irq_state+0x2e>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_ERROR;
     e7a:	2280      	movs	r2, #128	; 0x80
     e7c:	751a      	strb	r2, [r3, #20]
     e7e:	e7e2      	b.n	e46 <_usart_async_set_irq_state+0x2e>
     e80:	00000223 	.word	0x00000223
     e84:	00002c18 	.word	0x00002c18
     e88:	00000a69 	.word	0x00000a69

00000e8c <SERCOM4_Handler>:
		dev->callbacks.err(dev, ERR_OVERFLOW);
	}
}

void SERCOM4_Handler(void)
{
     e8c:	b510      	push	{r4, lr}
	_sercom_usart_interrupt_handler(_sercom4_dev);
     e8e:	4b19      	ldr	r3, [pc, #100]	; (ef4 <SERCOM4_Handler+0x68>)
     e90:	6818      	ldr	r0, [r3, #0]
	void *hw = device->hw;
     e92:	6984      	ldr	r4, [r0, #24]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
     e94:	7e23      	ldrb	r3, [r4, #24]
	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
     e96:	07db      	lsls	r3, r3, #31
     e98:	d502      	bpl.n	ea0 <SERCOM4_Handler+0x14>
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_DRE) >> SERCOM_USART_INTENSET_DRE_Pos;
     e9a:	7da3      	ldrb	r3, [r4, #22]
     e9c:	07db      	lsls	r3, r3, #31
     e9e:	d40f      	bmi.n	ec0 <SERCOM4_Handler+0x34>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
     ea0:	7e23      	ldrb	r3, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_TXC_bit(hw) && hri_sercomusart_get_INTEN_TXC_bit(hw)) {
     ea2:	079b      	lsls	r3, r3, #30
     ea4:	d502      	bpl.n	eac <SERCOM4_Handler+0x20>
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_TXC) >> SERCOM_USART_INTENSET_TXC_Pos;
     ea6:	7da3      	ldrb	r3, [r4, #22]
     ea8:	079b      	lsls	r3, r3, #30
     eaa:	d40e      	bmi.n	eca <SERCOM4_Handler+0x3e>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
     eac:	7e23      	ldrb	r3, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_RXC_bit(hw)) {
     eae:	075b      	lsls	r3, r3, #29
     eb0:	d515      	bpl.n	ede <SERCOM4_Handler+0x52>
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_status_reg_t hri_sercomusart_read_STATUS_reg(const void *const hw)
{
	return ((Sercom *)hw)->USART.STATUS.reg;
     eb2:	8b62      	ldrh	r2, [r4, #26]
		if (hri_sercomusart_read_STATUS_reg(hw)
     eb4:	2337      	movs	r3, #55	; 0x37
     eb6:	421a      	tst	r2, r3
     eb8:	d00c      	beq.n	ed4 <SERCOM4_Handler+0x48>
	((Sercom *)hw)->USART.STATUS.reg = mask;
     eba:	3348      	adds	r3, #72	; 0x48
     ebc:	8363      	strh	r3, [r4, #26]
}
     ebe:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
     ec0:	2301      	movs	r3, #1
     ec2:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_byte_sent(device);
     ec4:	6803      	ldr	r3, [r0, #0]
     ec6:	4798      	blx	r3
     ec8:	e7f9      	b.n	ebe <SERCOM4_Handler+0x32>
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
     eca:	2302      	movs	r3, #2
     ecc:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_done_cb(device);
     ece:	6883      	ldr	r3, [r0, #8]
     ed0:	4798      	blx	r3
     ed2:	e7f4      	b.n	ebe <SERCOM4_Handler+0x32>
	return ((Sercom *)hw)->USART.DATA.reg;
     ed4:	8d21      	ldrh	r1, [r4, #40]	; 0x28
		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
     ed6:	b2c9      	uxtb	r1, r1
     ed8:	6843      	ldr	r3, [r0, #4]
     eda:	4798      	blx	r3
     edc:	e7ef      	b.n	ebe <SERCOM4_Handler+0x32>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_ERROR) >> SERCOM_USART_INTFLAG_ERROR_Pos;
     ede:	7e23      	ldrb	r3, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_ERROR_bit(hw)) {
     ee0:	09db      	lsrs	r3, r3, #7
     ee2:	d0ec      	beq.n	ebe <SERCOM4_Handler+0x32>
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
     ee4:	2380      	movs	r3, #128	; 0x80
     ee6:	7623      	strb	r3, [r4, #24]
		device->usart_cb.error_cb(device);
     ee8:	68c3      	ldr	r3, [r0, #12]
     eea:	4798      	blx	r3
	return ((Sercom *)hw)->USART.STATUS.reg;
     eec:	8b63      	ldrh	r3, [r4, #26]
     eee:	b29b      	uxth	r3, r3
	((Sercom *)hw)->USART.STATUS.reg = mask;
     ef0:	8363      	strh	r3, [r4, #26]
}
     ef2:	e7e4      	b.n	ebe <SERCOM4_Handler+0x32>
     ef4:	20000064 	.word	0x20000064

00000ef8 <INT10_Handler>:

void SERCOM7_Handler(void)
{
     ef8:	b510      	push	{r4, lr}
	_spi_handler(_sercom7_dev);
     efa:	4b12      	ldr	r3, [pc, #72]	; (f44 <INT10_Handler+0x4c>)
     efc:	6858      	ldr	r0, [r3, #4]
	void *                      hw = dev->prvt;
     efe:	6802      	ldr	r2, [r0, #0]
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
     f00:	7e11      	ldrb	r1, [r2, #24]
	return ((Sercom *)hw)->SPI.INTENSET.reg;
     f02:	7d93      	ldrb	r3, [r2, #22]
	st &= hri_sercomspi_read_INTEN_reg(hw);
     f04:	400b      	ands	r3, r1
	if (st & SERCOM_SPI_INTFLAG_DRE) {
     f06:	07d9      	lsls	r1, r3, #31
     f08:	d407      	bmi.n	f1a <INT10_Handler+0x22>
	} else if (st & SERCOM_SPI_INTFLAG_RXC) {
     f0a:	0759      	lsls	r1, r3, #29
     f0c:	d408      	bmi.n	f20 <INT10_Handler+0x28>
	} else if (st & SERCOM_SPI_INTFLAG_TXC) {
     f0e:	0799      	lsls	r1, r3, #30
     f10:	d409      	bmi.n	f26 <INT10_Handler+0x2e>
	} else if (st & SERCOM_SPI_INTFLAG_ERROR) {
     f12:	b25b      	sxtb	r3, r3
     f14:	2b00      	cmp	r3, #0
     f16:	db0b      	blt.n	f30 <INT10_Handler+0x38>
}
     f18:	bd10      	pop	{r4, pc}
		dev->callbacks.tx(dev);
     f1a:	6883      	ldr	r3, [r0, #8]
     f1c:	4798      	blx	r3
     f1e:	e7fb      	b.n	f18 <INT10_Handler+0x20>
		dev->callbacks.rx(dev);
     f20:	68c3      	ldr	r3, [r0, #12]
     f22:	4798      	blx	r3
     f24:	e7f8      	b.n	f18 <INT10_Handler+0x20>
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
     f26:	2302      	movs	r3, #2
     f28:	7613      	strb	r3, [r2, #24]
		dev->callbacks.complete(dev);
     f2a:	6903      	ldr	r3, [r0, #16]
     f2c:	4798      	blx	r3
     f2e:	e7f3      	b.n	f18 <INT10_Handler+0x20>
	((Sercom *)hw)->SPI.STATUS.reg = mask;
     f30:	2304      	movs	r3, #4
     f32:	8353      	strh	r3, [r2, #26]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
     f34:	337c      	adds	r3, #124	; 0x7c
     f36:	7613      	strb	r3, [r2, #24]
		dev->callbacks.err(dev, ERR_OVERFLOW);
     f38:	6943      	ldr	r3, [r0, #20]
     f3a:	2113      	movs	r1, #19
     f3c:	4249      	negs	r1, r1
     f3e:	4798      	blx	r3
}
     f40:	e7ea      	b.n	f18 <INT10_Handler+0x20>
     f42:	46c0      	nop			; (mov r8, r8)
     f44:	20000064 	.word	0x20000064

00000f48 <_spi_m_sync_init>:

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
     f48:	b570      	push	{r4, r5, r6, lr}
     f4a:	0005      	movs	r5, r0
     f4c:	000c      	movs	r4, r1
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
     f4e:	0008      	movs	r0, r1
     f50:	4b34      	ldr	r3, [pc, #208]	; (1024 <_spi_m_sync_init+0xdc>)
     f52:	4798      	blx	r3
		if (sercomspi_regs[i].n == n) {
     f54:	2807      	cmp	r0, #7
     f56:	d00b      	beq.n	f70 <_spi_m_sync_init+0x28>
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);

	ASSERT(dev && hw);
     f58:	2d00      	cmp	r5, #0
     f5a:	d052      	beq.n	1002 <_spi_m_sync_init+0xba>
     f5c:	1e60      	subs	r0, r4, #1
     f5e:	4184      	sbcs	r4, r0
     f60:	b2e0      	uxtb	r0, r4
     f62:	4a31      	ldr	r2, [pc, #196]	; (1028 <_spi_m_sync_init+0xe0>)
     f64:	4931      	ldr	r1, [pc, #196]	; (102c <_spi_m_sync_init+0xe4>)
     f66:	4b32      	ldr	r3, [pc, #200]	; (1030 <_spi_m_sync_init+0xe8>)
     f68:	4798      	blx	r3

	if (regs == NULL) {
		return ERR_INVALID_ARG;
     f6a:	200d      	movs	r0, #13
     f6c:	4240      	negs	r0, r0
     f6e:	e047      	b.n	1000 <_spi_m_sync_init+0xb8>
	ASSERT(dev && hw);
     f70:	2d00      	cmp	r5, #0
     f72:	d14e      	bne.n	1012 <_spi_m_sync_init+0xca>
     f74:	4a2c      	ldr	r2, [pc, #176]	; (1028 <_spi_m_sync_init+0xe0>)
     f76:	492d      	ldr	r1, [pc, #180]	; (102c <_spi_m_sync_init+0xe4>)
     f78:	2000      	movs	r0, #0
     f7a:	4b2d      	ldr	r3, [pc, #180]	; (1030 <_spi_m_sync_init+0xe8>)
     f7c:	4798      	blx	r3
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
     f7e:	69e3      	ldr	r3, [r4, #28]
	}

	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
     f80:	07db      	lsls	r3, r3, #31
     f82:	d418      	bmi.n	fb6 <_spi_m_sync_init+0x6e>
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
     f84:	2203      	movs	r2, #3
     f86:	69e3      	ldr	r3, [r4, #28]
     f88:	421a      	tst	r2, r3
     f8a:	d1fc      	bne.n	f86 <_spi_m_sync_init+0x3e>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
     f8c:	6823      	ldr	r3, [r4, #0]
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
     f8e:	079b      	lsls	r3, r3, #30
     f90:	d50b      	bpl.n	faa <_spi_m_sync_init+0x62>
	((Sercom *)hw)->SPI.CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
     f92:	6823      	ldr	r3, [r4, #0]
     f94:	2202      	movs	r2, #2
     f96:	4393      	bics	r3, r2
     f98:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
     f9a:	3201      	adds	r2, #1
     f9c:	69e3      	ldr	r3, [r4, #28]
     f9e:	421a      	tst	r2, r3
     fa0:	d1fc      	bne.n	f9c <_spi_m_sync_init+0x54>
     fa2:	2202      	movs	r2, #2
     fa4:	69e3      	ldr	r3, [r4, #28]
     fa6:	421a      	tst	r2, r3
     fa8:	d1fc      	bne.n	fa4 <_spi_m_sync_init+0x5c>
	((Sercom *)hw)->SPI.CTRLA.reg = data;
     faa:	2309      	movs	r3, #9
     fac:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
     fae:	2203      	movs	r2, #3
     fb0:	69e3      	ldr	r3, [r4, #28]
     fb2:	421a      	tst	r2, r3
     fb4:	d1fc      	bne.n	fb0 <_spi_m_sync_init+0x68>
     fb6:	2201      	movs	r2, #1
     fb8:	69e3      	ldr	r3, [r4, #28]
     fba:	421a      	tst	r2, r3
     fbc:	d1fc      	bne.n	fb8 <_spi_m_sync_init+0x70>
		}
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
	}
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);

	dev->prvt = hw;
     fbe:	602c      	str	r4, [r5, #0]
	ASSERT(hw && regs);
     fc0:	0020      	movs	r0, r4
     fc2:	1e43      	subs	r3, r0, #1
     fc4:	4198      	sbcs	r0, r3
     fc6:	b2c0      	uxtb	r0, r0
     fc8:	4a1a      	ldr	r2, [pc, #104]	; (1034 <_spi_m_sync_init+0xec>)
     fca:	4918      	ldr	r1, [pc, #96]	; (102c <_spi_m_sync_init+0xe4>)
     fcc:	4b18      	ldr	r3, [pc, #96]	; (1030 <_spi_m_sync_init+0xe8>)
     fce:	4798      	blx	r3
	((Sercom *)hw)->SPI.CTRLA.reg = data;
     fd0:	4b19      	ldr	r3, [pc, #100]	; (1038 <_spi_m_sync_init+0xf0>)
     fd2:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
     fd4:	2203      	movs	r2, #3
     fd6:	69e3      	ldr	r3, [r4, #28]
     fd8:	421a      	tst	r2, r3
     fda:	d1fc      	bne.n	fd6 <_spi_m_sync_init+0x8e>
	((Sercom *)hw)->SPI.CTRLB.reg = data;
     fdc:	4b17      	ldr	r3, [pc, #92]	; (103c <_spi_m_sync_init+0xf4>)
     fde:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
     fe0:	2207      	movs	r2, #7
     fe2:	69e3      	ldr	r3, [r4, #28]
     fe4:	421a      	tst	r2, r3
     fe6:	d1fc      	bne.n	fe2 <_spi_m_sync_init+0x9a>
	((Sercom *)hw)->SPI.ADDR.reg = data;
     fe8:	2300      	movs	r3, #0
     fea:	6263      	str	r3, [r4, #36]	; 0x24
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
     fec:	2230      	movs	r2, #48	; 0x30
     fee:	54a3      	strb	r3, [r4, r2]
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
     ff0:	69e3      	ldr	r3, [r4, #28]
	while (hri_sercomspi_is_syncing(hw, 0xFFFFFFFF))
     ff2:	2b00      	cmp	r3, #0
     ff4:	d1fc      	bne.n	ff0 <_spi_m_sync_init+0xa8>
	} else {
		_spi_load_regs_master(hw, regs);
	}

	/* Load character size from default hardware configuration */
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
     ff6:	3301      	adds	r3, #1
     ff8:	712b      	strb	r3, [r5, #4]

	dev->dummy_byte = regs->dummy_byte;
     ffa:	2300      	movs	r3, #0
     ffc:	80eb      	strh	r3, [r5, #6]

	return ERR_NONE;
     ffe:	2000      	movs	r0, #0
}
    1000:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(dev && hw);
    1002:	4a09      	ldr	r2, [pc, #36]	; (1028 <_spi_m_sync_init+0xe0>)
    1004:	4909      	ldr	r1, [pc, #36]	; (102c <_spi_m_sync_init+0xe4>)
    1006:	2000      	movs	r0, #0
    1008:	4b09      	ldr	r3, [pc, #36]	; (1030 <_spi_m_sync_init+0xe8>)
    100a:	4798      	blx	r3
		return ERR_INVALID_ARG;
    100c:	200d      	movs	r0, #13
    100e:	4240      	negs	r0, r0
    1010:	e7f6      	b.n	1000 <_spi_m_sync_init+0xb8>
	ASSERT(dev && hw);
    1012:	0020      	movs	r0, r4
    1014:	1e43      	subs	r3, r0, #1
    1016:	4198      	sbcs	r0, r3
    1018:	b2c0      	uxtb	r0, r0
    101a:	4a03      	ldr	r2, [pc, #12]	; (1028 <_spi_m_sync_init+0xe0>)
    101c:	4903      	ldr	r1, [pc, #12]	; (102c <_spi_m_sync_init+0xe4>)
    101e:	4b04      	ldr	r3, [pc, #16]	; (1030 <_spi_m_sync_init+0xe8>)
    1020:	4798      	blx	r3
    1022:	e7ac      	b.n	f7e <_spi_m_sync_init+0x36>
    1024:	00000c4d 	.word	0x00000c4d
    1028:	0000097a 	.word	0x0000097a
    102c:	00002c18 	.word	0x00002c18
    1030:	00000a69 	.word	0x00000a69
    1034:	00000934 	.word	0x00000934
    1038:	20230008 	.word	0x20230008
    103c:	00020240 	.word	0x00020240

00001040 <_spi_m_async_init>:
{
	return _spi_m_sync_init(dev, hw);
}

int32_t _spi_m_async_init(struct _spi_async_dev *dev, void *const hw)
{
    1040:	b570      	push	{r4, r5, r6, lr}
    1042:	0004      	movs	r4, r0
    1044:	000d      	movs	r5, r1
	struct _spi_async_dev *spid = dev;
	/* Do hardware initialize. */
	int32_t rc = _spi_m_sync_init((struct _spi_m_sync_dev *)dev, hw);
    1046:	4b11      	ldr	r3, [pc, #68]	; (108c <_spi_m_async_init+0x4c>)
    1048:	4798      	blx	r3

	if (rc < 0) {
    104a:	2800      	cmp	r0, #0
    104c:	db1b      	blt.n	1086 <_spi_m_async_init+0x46>
		return rc;
	}

	_sercom_init_irq_param(hw, (void *)dev);
    104e:	0021      	movs	r1, r4
    1050:	0028      	movs	r0, r5
    1052:	4b0f      	ldr	r3, [pc, #60]	; (1090 <_spi_m_async_init+0x50>)
    1054:	4798      	blx	r3
	/* Initialize callbacks: must use them */
	spid->callbacks.complete = NULL;
    1056:	2300      	movs	r3, #0
    1058:	6123      	str	r3, [r4, #16]
	spid->callbacks.rx       = NULL;
    105a:	60e3      	str	r3, [r4, #12]
	spid->callbacks.tx       = NULL;
    105c:	60a3      	str	r3, [r4, #8]
	NVIC_DisableIRQ((IRQn_Type)_sercom_get_irq_num(hw));
    105e:	0028      	movs	r0, r5
    1060:	4b0c      	ldr	r3, [pc, #48]	; (1094 <_spi_m_async_init+0x54>)
    1062:	4798      	blx	r3
  if ((int32_t)(IRQn) >= 0)
    1064:	0603      	lsls	r3, r0, #24
    1066:	d40f      	bmi.n	1088 <_spi_m_async_init+0x48>
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1068:	231f      	movs	r3, #31
    106a:	4018      	ands	r0, r3
    106c:	3b1e      	subs	r3, #30
    106e:	4083      	lsls	r3, r0
    1070:	4a09      	ldr	r2, [pc, #36]	; (1098 <_spi_m_async_init+0x58>)
    1072:	2180      	movs	r1, #128	; 0x80
    1074:	5053      	str	r3, [r2, r1]
  __ASM volatile ("dsb 0xF":::"memory");
    1076:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    107a:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    107e:	3101      	adds	r1, #1
    1080:	31ff      	adds	r1, #255	; 0xff
    1082:	5053      	str	r3, [r2, r1]
	NVIC_ClearPendingIRQ((IRQn_Type)_sercom_get_irq_num(hw));

	return ERR_NONE;
    1084:	2000      	movs	r0, #0
}
    1086:	bd70      	pop	{r4, r5, r6, pc}
	return ERR_NONE;
    1088:	2000      	movs	r0, #0
    108a:	e7fc      	b.n	1086 <_spi_m_async_init+0x46>
    108c:	00000f49 	.word	0x00000f49
    1090:	00000c89 	.word	0x00000c89
    1094:	00000cb1 	.word	0x00000cb1
    1098:	e000e100 	.word	0xe000e100

0000109c <_spi_s_async_init>:

int32_t _spi_s_async_init(struct _spi_s_async_dev *dev, void *const hw)
{
    109c:	b510      	push	{r4, lr}
	return _spi_m_async_init(dev, hw);
    109e:	4b01      	ldr	r3, [pc, #4]	; (10a4 <_spi_s_async_init+0x8>)
    10a0:	4798      	blx	r3
}
    10a2:	bd10      	pop	{r4, pc}
    10a4:	00001041 	.word	0x00001041

000010a8 <_spi_m_async_enable_tx>:

	return rc;
}

int32_t _spi_m_async_enable_tx(struct _spi_async_dev *dev, bool state)
{
    10a8:	b570      	push	{r4, r5, r6, lr}
    10aa:	000d      	movs	r5, r1
	void *hw = dev->prvt;
    10ac:	6804      	ldr	r4, [r0, #0]

	ASSERT(dev && hw);
    10ae:	2800      	cmp	r0, #0
    10b0:	d00d      	beq.n	10ce <_spi_m_async_enable_tx+0x26>
    10b2:	0020      	movs	r0, r4
    10b4:	1e43      	subs	r3, r0, #1
    10b6:	4198      	sbcs	r0, r3
    10b8:	b2c0      	uxtb	r0, r0
    10ba:	4a07      	ldr	r2, [pc, #28]	; (10d8 <_spi_m_async_enable_tx+0x30>)
    10bc:	4907      	ldr	r1, [pc, #28]	; (10dc <_spi_m_async_enable_tx+0x34>)
    10be:	4b08      	ldr	r3, [pc, #32]	; (10e0 <_spi_m_async_enable_tx+0x38>)
    10c0:	4798      	blx	r3

	if (state) {
    10c2:	2d00      	cmp	r5, #0
    10c4:	d105      	bne.n	10d2 <_spi_m_async_enable_tx+0x2a>
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_DRE;
    10c6:	2301      	movs	r3, #1
    10c8:	7523      	strb	r3, [r4, #20]
	} else {
		hri_sercomspi_clear_INTEN_DRE_bit(hw);
	}

	return ERR_NONE;
}
    10ca:	2000      	movs	r0, #0
    10cc:	bd70      	pop	{r4, r5, r6, pc}
    10ce:	2000      	movs	r0, #0
    10d0:	e7f3      	b.n	10ba <_spi_m_async_enable_tx+0x12>
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_DRE;
    10d2:	2301      	movs	r3, #1
    10d4:	75a3      	strb	r3, [r4, #22]
    10d6:	e7f8      	b.n	10ca <_spi_m_async_enable_tx+0x22>
    10d8:	00000b06 	.word	0x00000b06
    10dc:	00002c18 	.word	0x00002c18
    10e0:	00000a69 	.word	0x00000a69

000010e4 <_spi_s_async_enable_tx>:

int32_t _spi_s_async_enable_tx(struct _spi_s_async_dev *dev, bool state)
{
    10e4:	b510      	push	{r4, lr}
	return _spi_m_async_enable_tx(dev, state);
    10e6:	4b01      	ldr	r3, [pc, #4]	; (10ec <_spi_s_async_enable_tx+0x8>)
    10e8:	4798      	blx	r3
}
    10ea:	bd10      	pop	{r4, pc}
    10ec:	000010a9 	.word	0x000010a9

000010f0 <_spi_m_async_enable_rx>:

int32_t _spi_m_async_enable_rx(struct _spi_async_dev *dev, bool state)
{
    10f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    10f2:	000e      	movs	r6, r1
	void *hw = dev->prvt;
    10f4:	6805      	ldr	r5, [r0, #0]

	ASSERT(dev);
    10f6:	4c0c      	ldr	r4, [pc, #48]	; (1128 <_spi_m_async_enable_rx+0x38>)
    10f8:	1e43      	subs	r3, r0, #1
    10fa:	4198      	sbcs	r0, r3
    10fc:	b2c0      	uxtb	r0, r0
    10fe:	4a0b      	ldr	r2, [pc, #44]	; (112c <_spi_m_async_enable_rx+0x3c>)
    1100:	0021      	movs	r1, r4
    1102:	4f0b      	ldr	r7, [pc, #44]	; (1130 <_spi_m_async_enable_rx+0x40>)
    1104:	47b8      	blx	r7
	ASSERT(hw);
    1106:	0028      	movs	r0, r5
    1108:	1e43      	subs	r3, r0, #1
    110a:	4198      	sbcs	r0, r3
    110c:	b2c0      	uxtb	r0, r0
    110e:	4a09      	ldr	r2, [pc, #36]	; (1134 <_spi_m_async_enable_rx+0x44>)
    1110:	0021      	movs	r1, r4
    1112:	47b8      	blx	r7

	if (state) {
    1114:	2e00      	cmp	r6, #0
    1116:	d103      	bne.n	1120 <_spi_m_async_enable_rx+0x30>
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_RXC;
    1118:	2304      	movs	r3, #4
    111a:	752b      	strb	r3, [r5, #20]
	} else {
		hri_sercomspi_clear_INTEN_RXC_bit(hw);
	}

	return ERR_NONE;
}
    111c:	2000      	movs	r0, #0
    111e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_RXC;
    1120:	2304      	movs	r3, #4
    1122:	75ab      	strb	r3, [r5, #22]
    1124:	e7fa      	b.n	111c <_spi_m_async_enable_rx+0x2c>
    1126:	46c0      	nop			; (mov r8, r8)
    1128:	00002c18 	.word	0x00002c18
    112c:	00000b1a 	.word	0x00000b1a
    1130:	00000a69 	.word	0x00000a69
    1134:	00000b1b 	.word	0x00000b1b

00001138 <_spi_s_async_enable_rx>:

int32_t _spi_s_async_enable_rx(struct _spi_s_async_dev *dev, bool state)
{
    1138:	b510      	push	{r4, lr}
	return _spi_m_async_enable_rx(dev, state);
    113a:	4b01      	ldr	r3, [pc, #4]	; (1140 <_spi_s_async_enable_rx+0x8>)
    113c:	4798      	blx	r3
}
    113e:	bd10      	pop	{r4, pc}
    1140:	000010f1 	.word	0x000010f1

00001144 <_spi_m_async_enable_tx_complete>:

int32_t _spi_m_async_enable_tx_complete(struct _spi_async_dev *dev, bool state)
{
    1144:	b570      	push	{r4, r5, r6, lr}
    1146:	0004      	movs	r4, r0
    1148:	000d      	movs	r5, r1
	ASSERT(dev && dev->prvt);
    114a:	2800      	cmp	r0, #0
    114c:	d00e      	beq.n	116c <_spi_m_async_enable_tx_complete+0x28>
    114e:	6800      	ldr	r0, [r0, #0]
    1150:	1e43      	subs	r3, r0, #1
    1152:	4198      	sbcs	r0, r3
    1154:	b2c0      	uxtb	r0, r0
    1156:	4a08      	ldr	r2, [pc, #32]	; (1178 <_spi_m_async_enable_tx_complete+0x34>)
    1158:	4908      	ldr	r1, [pc, #32]	; (117c <_spi_m_async_enable_tx_complete+0x38>)
    115a:	4b09      	ldr	r3, [pc, #36]	; (1180 <_spi_m_async_enable_tx_complete+0x3c>)
    115c:	4798      	blx	r3

	if (state) {
    115e:	2d00      	cmp	r5, #0
    1160:	d106      	bne.n	1170 <_spi_m_async_enable_tx_complete+0x2c>
		hri_sercomspi_set_INTEN_TXC_bit(dev->prvt);
	} else {
		hri_sercomspi_clear_INTEN_TXC_bit(dev->prvt);
    1162:	6823      	ldr	r3, [r4, #0]
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_TXC;
    1164:	2202      	movs	r2, #2
    1166:	751a      	strb	r2, [r3, #20]
	}

	return ERR_NONE;
}
    1168:	2000      	movs	r0, #0
    116a:	bd70      	pop	{r4, r5, r6, pc}
    116c:	2000      	movs	r0, #0
    116e:	e7f2      	b.n	1156 <_spi_m_async_enable_tx_complete+0x12>
		hri_sercomspi_set_INTEN_TXC_bit(dev->prvt);
    1170:	6823      	ldr	r3, [r4, #0]
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_TXC;
    1172:	2202      	movs	r2, #2
    1174:	759a      	strb	r2, [r3, #22]
    1176:	e7f7      	b.n	1168 <_spi_m_async_enable_tx_complete+0x24>
    1178:	00000b2d 	.word	0x00000b2d
    117c:	00002c18 	.word	0x00002c18
    1180:	00000a69 	.word	0x00000a69

00001184 <_spi_s_async_enable_ss_detect>:

int32_t _spi_s_async_enable_ss_detect(struct _spi_s_async_dev *dev, bool state)
{
    1184:	b510      	push	{r4, lr}
	return _spi_m_async_enable_tx_complete(dev, state);
    1186:	4b01      	ldr	r3, [pc, #4]	; (118c <_spi_s_async_enable_ss_detect+0x8>)
    1188:	4798      	blx	r3
}
    118a:	bd10      	pop	{r4, pc}
    118c:	00001145 	.word	0x00001145

00001190 <_spi_s_async_write_one>:

	return ERR_NONE;
}

int32_t _spi_s_async_write_one(struct _spi_s_async_dev *dev, uint16_t data)
{
    1190:	b570      	push	{r4, r5, r6, lr}
    1192:	0004      	movs	r4, r0
    1194:	000d      	movs	r5, r1
	ASSERT(dev && dev->prvt);
    1196:	2800      	cmp	r0, #0
    1198:	d00b      	beq.n	11b2 <_spi_s_async_write_one+0x22>
    119a:	6800      	ldr	r0, [r0, #0]
    119c:	1e43      	subs	r3, r0, #1
    119e:	4198      	sbcs	r0, r3
    11a0:	b2c0      	uxtb	r0, r0
    11a2:	4a05      	ldr	r2, [pc, #20]	; (11b8 <_spi_s_async_write_one+0x28>)
    11a4:	4905      	ldr	r1, [pc, #20]	; (11bc <_spi_s_async_write_one+0x2c>)
    11a6:	4b06      	ldr	r3, [pc, #24]	; (11c0 <_spi_s_async_write_one+0x30>)
    11a8:	4798      	blx	r3

	hri_sercomspi_write_DATA_reg(dev->prvt, data);
    11aa:	6823      	ldr	r3, [r4, #0]
	((Sercom *)hw)->SPI.DATA.reg = data;
    11ac:	629d      	str	r5, [r3, #40]	; 0x28

	return ERR_NONE;
}
    11ae:	2000      	movs	r0, #0
    11b0:	bd70      	pop	{r4, r5, r6, pc}
    11b2:	2000      	movs	r0, #0
    11b4:	e7f5      	b.n	11a2 <_spi_s_async_write_one+0x12>
    11b6:	46c0      	nop			; (mov r8, r8)
    11b8:	00000b48 	.word	0x00000b48
    11bc:	00002c18 	.word	0x00002c18
    11c0:	00000a69 	.word	0x00000a69

000011c4 <_spi_s_async_read_one>:

	return hri_sercomspi_read_DATA_reg(dev->prvt);
}

uint16_t _spi_s_async_read_one(struct _spi_s_async_dev *dev)
{
    11c4:	b510      	push	{r4, lr}
    11c6:	1e04      	subs	r4, r0, #0
	ASSERT(dev && dev->prvt);
    11c8:	d00b      	beq.n	11e2 <_spi_s_async_read_one+0x1e>
    11ca:	6800      	ldr	r0, [r0, #0]
    11cc:	1e43      	subs	r3, r0, #1
    11ce:	4198      	sbcs	r0, r3
    11d0:	b2c0      	uxtb	r0, r0
    11d2:	4a05      	ldr	r2, [pc, #20]	; (11e8 <_spi_s_async_read_one+0x24>)
    11d4:	4905      	ldr	r1, [pc, #20]	; (11ec <_spi_s_async_read_one+0x28>)
    11d6:	4b06      	ldr	r3, [pc, #24]	; (11f0 <_spi_s_async_read_one+0x2c>)
    11d8:	4798      	blx	r3

	return hri_sercomspi_read_DATA_reg(dev->prvt);
    11da:	6823      	ldr	r3, [r4, #0]
	return ((Sercom *)hw)->SPI.DATA.reg;
    11dc:	6a98      	ldr	r0, [r3, #40]	; 0x28
    11de:	b280      	uxth	r0, r0
}
    11e0:	bd10      	pop	{r4, pc}
    11e2:	2000      	movs	r0, #0
    11e4:	e7f5      	b.n	11d2 <_spi_s_async_read_one+0xe>
    11e6:	46c0      	nop			; (mov r8, r8)
    11e8:	00000b61 	.word	0x00000b61
    11ec:	00002c18 	.word	0x00002c18
    11f0:	00000a69 	.word	0x00000a69

000011f4 <_spi_m_async_register_callback>:
	return hri_sercomspi_read_DATA_reg(dev->prvt);
}

int32_t _spi_m_async_register_callback(struct _spi_async_dev *dev, const enum _spi_async_dev_cb_type cb_type,
                                       const FUNC_PTR func)
{
    11f4:	b570      	push	{r4, r5, r6, lr}
    11f6:	0004      	movs	r4, r0
    11f8:	000d      	movs	r5, r1
    11fa:	0016      	movs	r6, r2
	typedef void (*func_t)(void);
	struct _spi_async_dev *spid = dev;

	ASSERT(dev && (cb_type < SPI_DEV_CB_N));
    11fc:	2800      	cmp	r0, #0
    11fe:	d00f      	beq.n	1220 <_spi_m_async_register_callback+0x2c>
    1200:	2000      	movs	r0, #0
    1202:	2303      	movs	r3, #3
    1204:	428b      	cmp	r3, r1
    1206:	4140      	adcs	r0, r0
    1208:	b2c0      	uxtb	r0, r0
    120a:	2301      	movs	r3, #1
    120c:	4018      	ands	r0, r3
    120e:	4a05      	ldr	r2, [pc, #20]	; (1224 <_spi_m_async_register_callback+0x30>)
    1210:	4905      	ldr	r1, [pc, #20]	; (1228 <_spi_m_async_register_callback+0x34>)
    1212:	4b06      	ldr	r3, [pc, #24]	; (122c <_spi_m_async_register_callback+0x38>)
    1214:	4798      	blx	r3

	func_t *p_ls  = (func_t *)&spid->callbacks;
	p_ls[cb_type] = (func_t)func;
    1216:	00ad      	lsls	r5, r5, #2
    1218:	1964      	adds	r4, r4, r5
    121a:	60a6      	str	r6, [r4, #8]

	return ERR_NONE;
}
    121c:	2000      	movs	r0, #0
    121e:	bd70      	pop	{r4, r5, r6, pc}
    1220:	2000      	movs	r0, #0
    1222:	e7f2      	b.n	120a <_spi_m_async_register_callback+0x16>
    1224:	00000b73 	.word	0x00000b73
    1228:	00002c18 	.word	0x00002c18
    122c:	00000a69 	.word	0x00000a69

00001230 <_spi_s_async_register_callback>:

int32_t _spi_s_async_register_callback(struct _spi_s_async_dev *dev, const enum _spi_s_async_dev_cb_type cb_type,
                                       const FUNC_PTR func)
{
    1230:	b510      	push	{r4, lr}
	return _spi_m_async_register_callback(dev, cb_type, func);
    1232:	4b01      	ldr	r3, [pc, #4]	; (1238 <_spi_s_async_register_callback+0x8>)
    1234:	4798      	blx	r3
}
    1236:	bd10      	pop	{r4, pc}
    1238:	000011f5 	.word	0x000011f5

0000123c <_delay_init>:
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
    123c:	4b02      	ldr	r3, [pc, #8]	; (1248 <_delay_init+0xc>)
    123e:	4a03      	ldr	r2, [pc, #12]	; (124c <_delay_init+0x10>)
    1240:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
    1242:	2205      	movs	r2, #5
    1244:	601a      	str	r2, [r3, #0]
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
	_system_time_init(hw);
}
    1246:	4770      	bx	lr
    1248:	e000e010 	.word	0xe000e010
    124c:	00ffffff 	.word	0x00ffffff

00001250 <example_task>:
 *
 * \param[in] p The void pointer for OS task Standard model.
 *
 */
static void example_task(void *p)
{
    1250:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	(void)p;
	while (1) {
		if (xSemaphoreTake(disp_mutex, ~0)) {
    1252:	4e0d      	ldr	r6, [pc, #52]	; (1288 <example_task+0x38>)
    1254:	4c0d      	ldr	r4, [pc, #52]	; (128c <example_task+0x3c>)
			/* add your code */
			static uint8_t example_USART_On_USBPort[ ] = "He00000o World!";

				USART_On_USBPort_Output(example_USART_On_USBPort,sizeof(example_USART_On_USBPort)/sizeof(uint8_t));
    1256:	4d0e      	ldr	r5, [pc, #56]	; (1290 <example_task+0x40>)
    1258:	e003      	b.n	1262 <example_task+0x12>

//Din_0_example(buff,100);
//				USART_On_USBPort_Output(buff,sizeof(buff)/sizeof(uint8_t));
			xSemaphoreGive(disp_mutex);
		}
		os_sleep(1000);
    125a:	20fa      	movs	r0, #250	; 0xfa
    125c:	0080      	lsls	r0, r0, #2
    125e:	4b0d      	ldr	r3, [pc, #52]	; (1294 <example_task+0x44>)
    1260:	4798      	blx	r3
		if (xSemaphoreTake(disp_mutex, ~0)) {
    1262:	2101      	movs	r1, #1
    1264:	4249      	negs	r1, r1
    1266:	6830      	ldr	r0, [r6, #0]
    1268:	47a0      	blx	r4
    126a:	2800      	cmp	r0, #0
    126c:	d0f5      	beq.n	125a <example_task+0xa>
				USART_On_USBPort_Output(example_USART_On_USBPort,sizeof(example_USART_On_USBPort)/sizeof(uint8_t));
    126e:	2110      	movs	r1, #16
    1270:	0028      	movs	r0, r5
    1272:	4b09      	ldr	r3, [pc, #36]	; (1298 <example_task+0x48>)
    1274:	4798      	blx	r3
			xSemaphoreGive(disp_mutex);
    1276:	4b04      	ldr	r3, [pc, #16]	; (1288 <example_task+0x38>)
    1278:	6818      	ldr	r0, [r3, #0]
    127a:	2300      	movs	r3, #0
    127c:	2200      	movs	r2, #0
    127e:	2100      	movs	r1, #0
    1280:	4f06      	ldr	r7, [pc, #24]	; (129c <example_task+0x4c>)
    1282:	47b8      	blx	r7
    1284:	e7e9      	b.n	125a <example_task+0xa>
    1286:	46c0      	nop			; (mov r8, r8)
    1288:	2000006c 	.word	0x2000006c
    128c:	00001c85 	.word	0x00001c85
    1290:	20000000 	.word	0x20000000
    1294:	00002379 	.word	0x00002379
    1298:	000012f5 	.word	0x000012f5
    129c:	000018a9 	.word	0x000018a9

000012a0 <Hui_FREERTOS_V1000_0_example>:

/*
 * Example
 */
void Hui_FREERTOS_V1000_0_example(void)
{
    12a0:	b510      	push	{r4, lr}
    12a2:	b082      	sub	sp, #8
	disp_mutex = xSemaphoreCreateMutex();
    12a4:	2001      	movs	r0, #1
    12a6:	4b0c      	ldr	r3, [pc, #48]	; (12d8 <Hui_FREERTOS_V1000_0_example+0x38>)
    12a8:	4798      	blx	r3
    12aa:	4b0c      	ldr	r3, [pc, #48]	; (12dc <Hui_FREERTOS_V1000_0_example+0x3c>)
    12ac:	6018      	str	r0, [r3, #0]

	if (disp_mutex == NULL) {
    12ae:	2800      	cmp	r0, #0
    12b0:	d100      	bne.n	12b4 <Hui_FREERTOS_V1000_0_example+0x14>
    12b2:	e7fe      	b.n	12b2 <Hui_FREERTOS_V1000_0_example+0x12>
		while (1) {
			;
		}
	}

	if (xTaskCreate(
    12b4:	2300      	movs	r3, #0
    12b6:	9301      	str	r3, [sp, #4]
    12b8:	3301      	adds	r3, #1
    12ba:	9300      	str	r3, [sp, #0]
    12bc:	2300      	movs	r3, #0
    12be:	2220      	movs	r2, #32
    12c0:	4907      	ldr	r1, [pc, #28]	; (12e0 <Hui_FREERTOS_V1000_0_example+0x40>)
    12c2:	4808      	ldr	r0, [pc, #32]	; (12e4 <Hui_FREERTOS_V1000_0_example+0x44>)
    12c4:	4c08      	ldr	r4, [pc, #32]	; (12e8 <Hui_FREERTOS_V1000_0_example+0x48>)
    12c6:	47a0      	blx	r4
    12c8:	2801      	cmp	r0, #1
    12ca:	d000      	beq.n	12ce <Hui_FREERTOS_V1000_0_example+0x2e>
    12cc:	e7fe      	b.n	12cc <Hui_FREERTOS_V1000_0_example+0x2c>
		while (1) {
			;
		}
	}

	vTaskStartScheduler();
    12ce:	4b07      	ldr	r3, [pc, #28]	; (12ec <Hui_FREERTOS_V1000_0_example+0x4c>)
    12d0:	4798      	blx	r3

	return;
}
    12d2:	b002      	add	sp, #8
    12d4:	bd10      	pop	{r4, pc}
    12d6:	46c0      	nop			; (mov r8, r8)
    12d8:	00001a35 	.word	0x00001a35
    12dc:	2000006c 	.word	0x2000006c
    12e0:	00002c34 	.word	0x00002c34
    12e4:	00001251 	.word	0x00001251
    12e8:	00001f2d 	.word	0x00001f2d
    12ec:	000020f9 	.word	0x000020f9

000012f0 <tx_cb_USART_On_USBPort>:
 */

static void tx_cb_USART_On_USBPort(const struct usart_async_descriptor *const io_descr)
{
	/* Transfer completed */
}
    12f0:	4770      	bx	lr
	...

000012f4 <USART_On_USBPort_Output>:

void USART_On_USBPort_Output(uint8_t Data_USART_On_USBPort[], uint8_t arry_size)
{
    12f4:	b570      	push	{r4, r5, r6, lr}
    12f6:	b082      	sub	sp, #8
    12f8:	0006      	movs	r6, r0
    12fa:	000c      	movs	r4, r1
	struct io_descriptor *io;

	usart_async_register_callback(&USART_On_USBPort, USART_ASYNC_TXC_CB, tx_cb_USART_On_USBPort);
    12fc:	4d09      	ldr	r5, [pc, #36]	; (1324 <USART_On_USBPort_Output+0x30>)
    12fe:	4a0a      	ldr	r2, [pc, #40]	; (1328 <USART_On_USBPort_Output+0x34>)
    1300:	2101      	movs	r1, #1
    1302:	0028      	movs	r0, r5
    1304:	4b09      	ldr	r3, [pc, #36]	; (132c <USART_On_USBPort_Output+0x38>)
    1306:	4798      	blx	r3
	/*usart_async_register_callback(&USART_On_USBPort, USART_ASYNC_RXC_CB, rx_cb);
	usart_async_register_callback(&USART_On_USBPort, USART_ASYNC_ERROR_CB, err_cb);*/
	usart_async_get_io_descriptor(&USART_On_USBPort, &io);
    1308:	a901      	add	r1, sp, #4
    130a:	0028      	movs	r0, r5
    130c:	4b08      	ldr	r3, [pc, #32]	; (1330 <USART_On_USBPort_Output+0x3c>)
    130e:	4798      	blx	r3
	usart_async_enable(&USART_On_USBPort);
    1310:	0028      	movs	r0, r5
    1312:	4b08      	ldr	r3, [pc, #32]	; (1334 <USART_On_USBPort_Output+0x40>)
    1314:	4798      	blx	r3

	io_write(io, Data_USART_On_USBPort, arry_size);
    1316:	b2a2      	uxth	r2, r4
    1318:	0031      	movs	r1, r6
    131a:	9801      	ldr	r0, [sp, #4]
    131c:	4b06      	ldr	r3, [pc, #24]	; (1338 <USART_On_USBPort_Output+0x44>)
    131e:	4798      	blx	r3
}
    1320:	b002      	add	sp, #8
    1322:	bd70      	pop	{r4, r5, r6, pc}
    1324:	20000b00 	.word	0x20000b00
    1328:	000012f1 	.word	0x000012f1
    132c:	000009f1 	.word	0x000009f1
    1330:	000009c5 	.word	0x000009c5
    1334:	00000999 	.word	0x00000999
    1338:	00000435 	.word	0x00000435

0000133c <main>:
#include <atmel_start.h>
#include <driver_examples.h>
#include "Hui_rtos_start.h"

int main(void)
{
    133c:	b510      	push	{r4, lr}
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
    133e:	4b02      	ldr	r3, [pc, #8]	; (1348 <main+0xc>)
    1340:	4798      	blx	r3
	Hui_FREERTOS_V1000_0_example();
    1342:	4b02      	ldr	r3, [pc, #8]	; (134c <main+0x10>)
    1344:	4798      	blx	r3
    1346:	e7fe      	b.n	1346 <main+0xa>
    1348:	0000011d 	.word	0x0000011d
    134c:	000012a1 	.word	0x000012a1

00001350 <vListInitialise>:
void vListInitialise(List_t *const pxList)
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = (ListItem_t *)&(
    1350:	0003      	movs	r3, r0
    1352:	3308      	adds	r3, #8
    1354:	6043      	str	r3, [r0, #4]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1356:	2201      	movs	r2, #1
    1358:	4252      	negs	r2, r2
    135a:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = (ListItem_t *)&(pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as
    135c:	60c3      	str	r3, [r0, #12]
	                                                                the list end to save RAM.  This is checked and
	                                                                valid. */
	pxList->xListEnd.pxPrevious = (ListItem_t *)&(
    135e:	6103      	str	r3, [r0, #16]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	pxList->uxNumberOfItems = (UBaseType_t)0U;
    1360:	2300      	movs	r3, #0
    1362:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE(pxList);
	listSET_LIST_INTEGRITY_CHECK_2_VALUE(pxList);
}
    1364:	4770      	bx	lr

00001366 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem(ListItem_t *const pxItem)
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1366:	2300      	movs	r3, #0
    1368:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
}
    136a:	4770      	bx	lr

0000136c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
	ListItem_t *const pxIndex = pxList->pxIndex;
    136c:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
    136e:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1370:	689a      	ldr	r2, [r3, #8]
    1372:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1374:	689a      	ldr	r2, [r3, #8]
    1376:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious         = pxNewListItem;
    1378:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;
    137a:	6108      	str	r0, [r1, #16]

	(pxList->uxNumberOfItems)++;
    137c:	6803      	ldr	r3, [r0, #0]
    137e:	3301      	adds	r3, #1
    1380:	6003      	str	r3, [r0, #0]
}
    1382:	4770      	bx	lr

00001384 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert(List_t *const pxList, ListItem_t *const pxNewListItem)
{
    1384:	b530      	push	{r4, r5, lr}
	ListItem_t *     pxIterator;
	const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1386:	680c      	ldr	r4, [r1, #0]
		    4) Using a queue or semaphore before it has been initialised or
		       before the scheduler has been started (are interrupts firing
		       before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
    1388:	0002      	movs	r2, r0
    138a:	3208      	adds	r2, #8
	if (xValueOfInsertion == portMAX_DELAY) {
    138c:	1c63      	adds	r3, r4, #1
    138e:	d102      	bne.n	1396 <vListInsert+0x12>
		pxIterator = pxList->xListEnd.pxPrevious;
    1390:	6902      	ldr	r2, [r0, #16]
    1392:	e004      	b.n	139e <vListInsert+0x1a>
		     pxIterator
		     = pxIterator
    1394:	001a      	movs	r2, r3
		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
    1396:	6853      	ldr	r3, [r2, #4]
    1398:	681d      	ldr	r5, [r3, #0]
    139a:	42ac      	cmp	r4, r5
    139c:	d2fa      	bcs.n	1394 <vListInsert+0x10>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext             = pxIterator->pxNext;
    139e:	6853      	ldr	r3, [r2, #4]
    13a0:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    13a2:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious         = pxIterator;
    13a4:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext                = pxNewListItem;
    13a6:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = (void *)pxList;
    13a8:	6108      	str	r0, [r1, #16]

	(pxList->uxNumberOfItems)++;
    13aa:	6803      	ldr	r3, [r0, #0]
    13ac:	3301      	adds	r3, #1
    13ae:	6003      	str	r3, [r0, #0]
}
    13b0:	bd30      	pop	{r4, r5, pc}

000013b2 <uxListRemove>:

UBaseType_t uxListRemove(ListItem_t *const pxItemToRemove)
{
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
    13b2:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    13b4:	6842      	ldr	r2, [r0, #4]
    13b6:	6881      	ldr	r1, [r0, #8]
    13b8:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    13ba:	6882      	ldr	r2, [r0, #8]
    13bc:	6841      	ldr	r1, [r0, #4]
    13be:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
    13c0:	685a      	ldr	r2, [r3, #4]
    13c2:	4290      	cmp	r0, r2
    13c4:	d006      	beq.n	13d4 <uxListRemove+0x22>
		pxList->pxIndex = pxItemToRemove->pxPrevious;
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    13c6:	2200      	movs	r2, #0
    13c8:	6102      	str	r2, [r0, #16]
	(pxList->uxNumberOfItems)--;
    13ca:	681a      	ldr	r2, [r3, #0]
    13cc:	3a01      	subs	r2, #1
    13ce:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    13d0:	6818      	ldr	r0, [r3, #0]
}
    13d2:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    13d4:	6882      	ldr	r2, [r0, #8]
    13d6:	605a      	str	r2, [r3, #4]
    13d8:	e7f5      	b.n	13c6 <uxListRemove+0x14>
	...

000013dc <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError(void)
{
    13dc:	b082      	sub	sp, #8
	volatile uint32_t ulDummy = 0UL;
    13de:	2300      	movs	r3, #0
    13e0:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT(uxCriticalNesting == ~0UL);
    13e2:	4b06      	ldr	r3, [pc, #24]	; (13fc <prvTaskExitError+0x20>)
    13e4:	681b      	ldr	r3, [r3, #0]
    13e6:	3301      	adds	r3, #1
    13e8:	d001      	beq.n	13ee <prvTaskExitError+0x12>
    13ea:	b672      	cpsid	i
    13ec:	e7fe      	b.n	13ec <prvTaskExitError+0x10>
	portDISABLE_INTERRUPTS();
    13ee:	b672      	cpsid	i
	while (ulDummy == 0) {
    13f0:	9b01      	ldr	r3, [sp, #4]
    13f2:	2b00      	cmp	r3, #0
    13f4:	d0fc      	beq.n	13f0 <prvTaskExitError+0x14>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
    13f6:	b002      	add	sp, #8
    13f8:	4770      	bx	lr
    13fa:	46c0      	nop			; (mov r8, r8)
    13fc:	20000010 	.word	0x20000010

00001400 <vPortStartFirstTask>:
void vPortStartFirstTask(void)
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
    1400:	4a0b      	ldr	r2, [pc, #44]	; (1430 <pxCurrentTCBConst2>)
    1402:	6813      	ldr	r3, [r2, #0]
    1404:	6818      	ldr	r0, [r3, #0]
    1406:	3020      	adds	r0, #32
    1408:	f380 8809 	msr	PSP, r0
    140c:	2002      	movs	r0, #2
    140e:	f380 8814 	msr	CONTROL, r0
    1412:	f3bf 8f6f 	isb	sy
    1416:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
    1418:	46ae      	mov	lr, r5
    141a:	bc08      	pop	{r3}
    141c:	bc04      	pop	{r2}
    141e:	b662      	cpsie	i
    1420:	4718      	bx	r3
    1422:	46c0      	nop			; (mov r8, r8)
    1424:	46c0      	nop			; (mov r8, r8)
    1426:	46c0      	nop			; (mov r8, r8)
    1428:	46c0      	nop			; (mov r8, r8)
    142a:	46c0      	nop			; (mov r8, r8)
    142c:	46c0      	nop			; (mov r8, r8)
    142e:	46c0      	nop			; (mov r8, r8)

00001430 <pxCurrentTCBConst2>:
    1430:	20000a70 	.word	0x20000a70

00001434 <pxPortInitialiseStack>:
{
    1434:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR; /* xPSR */
    1436:	1f03      	subs	r3, r0, #4
    1438:	2480      	movs	r4, #128	; 0x80
    143a:	0464      	lsls	r4, r4, #17
    143c:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = (StackType_t)pxCode; /* PC */
    143e:	3b04      	subs	r3, #4
    1440:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */
    1442:	3b04      	subs	r3, #4
    1444:	4902      	ldr	r1, [pc, #8]	; (1450 <pxPortInitialiseStack+0x1c>)
    1446:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = (StackType_t)pvParameters;            /* R0 */
    1448:	3b14      	subs	r3, #20
    144a:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;                                    /* R11..R4. */
    144c:	3840      	subs	r0, #64	; 0x40
}
    144e:	bd10      	pop	{r4, pc}
    1450:	000013dd 	.word	0x000013dd

00001454 <SVCall_Handler>:
}
    1454:	4770      	bx	lr
	...

00001458 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler(void)
{
    1458:	b510      	push	{r4, lr}
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
    145a:	4b0f      	ldr	r3, [pc, #60]	; (1498 <xPortStartScheduler+0x40>)
    145c:	6819      	ldr	r1, [r3, #0]
    145e:	22ff      	movs	r2, #255	; 0xff
    1460:	0412      	lsls	r2, r2, #16
    1462:	430a      	orrs	r2, r1
    1464:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
    1466:	6819      	ldr	r1, [r3, #0]
    1468:	22ff      	movs	r2, #255	; 0xff
    146a:	0612      	lsls	r2, r2, #24
    146c:	430a      	orrs	r2, r1
    146e:	601a      	str	r2, [r3, #0]
 * frequency.
 */
void prvSetupTimerInterrupt(void)
{
	/* Stop and reset the SysTick. */
	*(portNVIC_SYSTICK_CTRL)          = 0UL;
    1470:	4a0a      	ldr	r2, [pc, #40]	; (149c <xPortStartScheduler+0x44>)
    1472:	2300      	movs	r3, #0
    1474:	6013      	str	r3, [r2, #0]
	*(portNVIC_SYSTICK_CURRENT_VALUE) = 0UL;
    1476:	490a      	ldr	r1, [pc, #40]	; (14a0 <xPortStartScheduler+0x48>)
    1478:	600b      	str	r3, [r1, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = (configCPU_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
    147a:	480a      	ldr	r0, [pc, #40]	; (14a4 <xPortStartScheduler+0x4c>)
    147c:	490a      	ldr	r1, [pc, #40]	; (14a8 <xPortStartScheduler+0x50>)
    147e:	6008      	str	r0, [r1, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
    1480:	2107      	movs	r1, #7
    1482:	6011      	str	r1, [r2, #0]
	uxCriticalNesting = 0;
    1484:	4a09      	ldr	r2, [pc, #36]	; (14ac <xPortStartScheduler+0x54>)
    1486:	6013      	str	r3, [r2, #0]
	vPortStartFirstTask();
    1488:	4b09      	ldr	r3, [pc, #36]	; (14b0 <xPortStartScheduler+0x58>)
    148a:	4798      	blx	r3
	vTaskSwitchContext();
    148c:	4b09      	ldr	r3, [pc, #36]	; (14b4 <xPortStartScheduler+0x5c>)
    148e:	4798      	blx	r3
	prvTaskExitError();
    1490:	4b09      	ldr	r3, [pc, #36]	; (14b8 <xPortStartScheduler+0x60>)
    1492:	4798      	blx	r3
}
    1494:	2000      	movs	r0, #0
    1496:	bd10      	pop	{r4, pc}
    1498:	e000ed20 	.word	0xe000ed20
    149c:	e000e010 	.word	0xe000e010
    14a0:	e000e018 	.word	0xe000e018
    14a4:	00000f9f 	.word	0x00000f9f
    14a8:	e000e014 	.word	0xe000e014
    14ac:	20000010 	.word	0x20000010
    14b0:	00001401 	.word	0x00001401
    14b4:	000023b9 	.word	0x000023b9
    14b8:	000013dd 	.word	0x000013dd

000014bc <vPortYield>:
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
    14bc:	2280      	movs	r2, #128	; 0x80
    14be:	0552      	lsls	r2, r2, #21
    14c0:	4b03      	ldr	r3, [pc, #12]	; (14d0 <vPortYield+0x14>)
    14c2:	601a      	str	r2, [r3, #0]
	__asm volatile("dsb" ::: "memory");
    14c4:	f3bf 8f4f 	dsb	sy
	__asm volatile("isb");
    14c8:	f3bf 8f6f 	isb	sy
}
    14cc:	4770      	bx	lr
    14ce:	46c0      	nop			; (mov r8, r8)
    14d0:	e000ed04 	.word	0xe000ed04

000014d4 <vPortEnterCritical>:
	portDISABLE_INTERRUPTS();
    14d4:	b672      	cpsid	i
	uxCriticalNesting++;
    14d6:	4a04      	ldr	r2, [pc, #16]	; (14e8 <vPortEnterCritical+0x14>)
    14d8:	6813      	ldr	r3, [r2, #0]
    14da:	3301      	adds	r3, #1
    14dc:	6013      	str	r3, [r2, #0]
	__asm volatile("dsb" ::: "memory");
    14de:	f3bf 8f4f 	dsb	sy
	__asm volatile("isb");
    14e2:	f3bf 8f6f 	isb	sy
}
    14e6:	4770      	bx	lr
    14e8:	20000010 	.word	0x20000010

000014ec <vPortExitCritical>:
	configASSERT(uxCriticalNesting);
    14ec:	4b06      	ldr	r3, [pc, #24]	; (1508 <vPortExitCritical+0x1c>)
    14ee:	681b      	ldr	r3, [r3, #0]
    14f0:	2b00      	cmp	r3, #0
    14f2:	d101      	bne.n	14f8 <vPortExitCritical+0xc>
    14f4:	b672      	cpsid	i
    14f6:	e7fe      	b.n	14f6 <vPortExitCritical+0xa>
	uxCriticalNesting--;
    14f8:	3b01      	subs	r3, #1
    14fa:	4a03      	ldr	r2, [pc, #12]	; (1508 <vPortExitCritical+0x1c>)
    14fc:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
    14fe:	2b00      	cmp	r3, #0
    1500:	d100      	bne.n	1504 <vPortExitCritical+0x18>
		portENABLE_INTERRUPTS();
    1502:	b662      	cpsie	i
}
    1504:	4770      	bx	lr
    1506:	46c0      	nop			; (mov r8, r8)
    1508:	20000010 	.word	0x20000010

0000150c <ulSetInterruptMaskFromISR>:
	__asm volatile(" mrs r0, PRIMASK	\n"
    150c:	f3ef 8010 	mrs	r0, PRIMASK
    1510:	b672      	cpsid	i
    1512:	4770      	bx	lr

00001514 <vClearInterruptMaskFromISR>:
	__asm volatile(" msr PRIMASK, r0	\n"
    1514:	f380 8810 	msr	PRIMASK, r0
    1518:	4770      	bx	lr
    151a:	0000      	movs	r0, r0
    151c:	0000      	movs	r0, r0
	...

00001520 <PendSV_Handler>:
	__asm volatile(
    1520:	f3ef 8009 	mrs	r0, PSP
    1524:	4b0e      	ldr	r3, [pc, #56]	; (1560 <pxCurrentTCBConst>)
    1526:	681a      	ldr	r2, [r3, #0]
    1528:	3820      	subs	r0, #32
    152a:	6010      	str	r0, [r2, #0]
    152c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    152e:	4644      	mov	r4, r8
    1530:	464d      	mov	r5, r9
    1532:	4656      	mov	r6, sl
    1534:	465f      	mov	r7, fp
    1536:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    1538:	b508      	push	{r3, lr}
    153a:	b672      	cpsid	i
    153c:	f000 ff3c 	bl	23b8 <vTaskSwitchContext>
    1540:	b662      	cpsie	i
    1542:	bc0c      	pop	{r2, r3}
    1544:	6811      	ldr	r1, [r2, #0]
    1546:	6808      	ldr	r0, [r1, #0]
    1548:	3010      	adds	r0, #16
    154a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    154c:	46a0      	mov	r8, r4
    154e:	46a9      	mov	r9, r5
    1550:	46b2      	mov	sl, r6
    1552:	46bb      	mov	fp, r7
    1554:	f380 8809 	msr	PSP, r0
    1558:	3820      	subs	r0, #32
    155a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    155c:	4718      	bx	r3
    155e:	46c0      	nop			; (mov r8, r8)

00001560 <pxCurrentTCBConst>:
    1560:	20000a70 	.word	0x20000a70

00001564 <SysTick_Handler>:
{
    1564:	b510      	push	{r4, lr}
	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
    1566:	4b07      	ldr	r3, [pc, #28]	; (1584 <SysTick_Handler+0x20>)
    1568:	4798      	blx	r3
    156a:	0004      	movs	r4, r0
		if (xTaskIncrementTick() != pdFALSE) {
    156c:	4b06      	ldr	r3, [pc, #24]	; (1588 <SysTick_Handler+0x24>)
    156e:	4798      	blx	r3
    1570:	2800      	cmp	r0, #0
    1572:	d003      	beq.n	157c <SysTick_Handler+0x18>
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
    1574:	2280      	movs	r2, #128	; 0x80
    1576:	0552      	lsls	r2, r2, #21
    1578:	4b04      	ldr	r3, [pc, #16]	; (158c <SysTick_Handler+0x28>)
    157a:	601a      	str	r2, [r3, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR(ulPreviousMask);
    157c:	0020      	movs	r0, r4
    157e:	4b04      	ldr	r3, [pc, #16]	; (1590 <SysTick_Handler+0x2c>)
    1580:	4798      	blx	r3
}
    1582:	bd10      	pop	{r4, pc}
    1584:	0000150d 	.word	0x0000150d
    1588:	0000217d 	.word	0x0000217d
    158c:	e000ed04 	.word	0xe000ed04
    1590:	00001515 	.word	0x00001515

00001594 <pvPortMalloc>:
static size_t xNextFreeByte = (size_t)0;

/*-----------------------------------------------------------*/

void *pvPortMalloc(size_t xWantedSize)
{
    1594:	b570      	push	{r4, r5, r6, lr}
    1596:	0004      	movs	r4, r0
	static uint8_t *pucAlignedHeap = NULL;

/* Ensure that blocks are always aligned to the required number of bytes. */
#if (portBYTE_ALIGNMENT != 1)
	{
		if (xWantedSize & portBYTE_ALIGNMENT_MASK) {
    1598:	0743      	lsls	r3, r0, #29
    159a:	d002      	beq.n	15a2 <pvPortMalloc+0xe>
			/* Byte alignment required. */
			xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
    159c:	2307      	movs	r3, #7
    159e:	439c      	bics	r4, r3
    15a0:	3408      	adds	r4, #8
		}
	}
#endif

	vTaskSuspendAll();
    15a2:	4b11      	ldr	r3, [pc, #68]	; (15e8 <pvPortMalloc+0x54>)
    15a4:	4798      	blx	r3
	{
		if (pucAlignedHeap == NULL) {
    15a6:	4b11      	ldr	r3, [pc, #68]	; (15ec <pvPortMalloc+0x58>)
    15a8:	681b      	ldr	r3, [r3, #0]
    15aa:	2b00      	cmp	r3, #0
    15ac:	d010      	beq.n	15d0 <pvPortMalloc+0x3c>
			pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
			                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
		}

		/* Check there is enough room left for the allocation. */
		if (((xNextFreeByte + xWantedSize) < configADJUSTED_HEAP_SIZE)
    15ae:	4b10      	ldr	r3, [pc, #64]	; (15f0 <pvPortMalloc+0x5c>)
    15b0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    15b2:	18e4      	adds	r4, r4, r3
    15b4:	4a0f      	ldr	r2, [pc, #60]	; (15f4 <pvPortMalloc+0x60>)
    15b6:	4294      	cmp	r4, r2
    15b8:	d811      	bhi.n	15de <pvPortMalloc+0x4a>
		    && ((xNextFreeByte + xWantedSize) > xNextFreeByte)) /* Check for overflow. */
    15ba:	42a3      	cmp	r3, r4
    15bc:	d211      	bcs.n	15e2 <pvPortMalloc+0x4e>
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    15be:	4a0b      	ldr	r2, [pc, #44]	; (15ec <pvPortMalloc+0x58>)
    15c0:	6815      	ldr	r5, [r2, #0]
    15c2:	18ed      	adds	r5, r5, r3
			xNextFreeByte += xWantedSize;
    15c4:	4b0a      	ldr	r3, [pc, #40]	; (15f0 <pvPortMalloc+0x5c>)
    15c6:	665c      	str	r4, [r3, #100]	; 0x64
		}

		traceMALLOC(pvReturn, xWantedSize);
	}
	(void)xTaskResumeAll();
    15c8:	4b0b      	ldr	r3, [pc, #44]	; (15f8 <pvPortMalloc+0x64>)
    15ca:	4798      	blx	r3
		}
	}
#endif

	return pvReturn;
}
    15cc:	0028      	movs	r0, r5
    15ce:	bd70      	pop	{r4, r5, r6, pc}
			pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
    15d0:	4a06      	ldr	r2, [pc, #24]	; (15ec <pvPortMalloc+0x58>)
    15d2:	0013      	movs	r3, r2
    15d4:	330c      	adds	r3, #12
			                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
    15d6:	2107      	movs	r1, #7
    15d8:	438b      	bics	r3, r1
			pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
    15da:	6013      	str	r3, [r2, #0]
    15dc:	e7e7      	b.n	15ae <pvPortMalloc+0x1a>
	void *          pvReturn       = NULL;
    15de:	2500      	movs	r5, #0
    15e0:	e7f2      	b.n	15c8 <pvPortMalloc+0x34>
    15e2:	2500      	movs	r5, #0
    15e4:	e7f0      	b.n	15c8 <pvPortMalloc+0x34>
    15e6:	46c0      	nop			; (mov r8, r8)
    15e8:	00002161 	.word	0x00002161
    15ec:	20000070 	.word	0x20000070
    15f0:	20000970 	.word	0x20000970
    15f4:	00000957 	.word	0x00000957
    15f8:	00002289 	.word	0x00002289

000015fc <vPortFree>:
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	(void)pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT(pv == NULL);
    15fc:	2800      	cmp	r0, #0
    15fe:	d001      	beq.n	1604 <vPortFree+0x8>
    1600:	b672      	cpsid	i
    1602:	e7fe      	b.n	1602 <vPortFree+0x6>
}
    1604:	4770      	bx	lr
	...

00001608 <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty(const Queue_t *pxQueue)
{
    1608:	b510      	push	{r4, lr}
    160a:	0004      	movs	r4, r0
	BaseType_t xReturn;

	taskENTER_CRITICAL();
    160c:	4b03      	ldr	r3, [pc, #12]	; (161c <prvIsQueueEmpty+0x14>)
    160e:	4798      	blx	r3
	{
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
    1610:	6ba4      	ldr	r4, [r4, #56]	; 0x38
			xReturn = pdTRUE;
		} else {
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1612:	4b03      	ldr	r3, [pc, #12]	; (1620 <prvIsQueueEmpty+0x18>)
    1614:	4798      	blx	r3
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
    1616:	4260      	negs	r0, r4
    1618:	4160      	adcs	r0, r4

	return xReturn;
}
    161a:	bd10      	pop	{r4, pc}
    161c:	000014d5 	.word	0x000014d5
    1620:	000014ed 	.word	0x000014ed

00001624 <prvCopyDataToQueue>:
{
    1624:	b570      	push	{r4, r5, r6, lr}
    1626:	0004      	movs	r4, r0
    1628:	0016      	movs	r6, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    162a:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
    162c:	6c02      	ldr	r2, [r0, #64]	; 0x40
    162e:	2a00      	cmp	r2, #0
    1630:	d10b      	bne.n	164a <prvCopyDataToQueue+0x26>
	BaseType_t  xReturn = pdFALSE;
    1632:	2000      	movs	r0, #0
			if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
    1634:	6823      	ldr	r3, [r4, #0]
    1636:	4283      	cmp	r3, r0
    1638:	d104      	bne.n	1644 <prvCopyDataToQueue+0x20>
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
    163a:	6860      	ldr	r0, [r4, #4]
    163c:	4b16      	ldr	r3, [pc, #88]	; (1698 <prvCopyDataToQueue+0x74>)
    163e:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
    1640:	2300      	movs	r3, #0
    1642:	6063      	str	r3, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + (UBaseType_t)1;
    1644:	3501      	adds	r5, #1
    1646:	63a5      	str	r5, [r4, #56]	; 0x38
}
    1648:	bd70      	pop	{r4, r5, r6, pc}
	} else if (xPosition == queueSEND_TO_BACK) {
    164a:	2e00      	cmp	r6, #0
    164c:	d10e      	bne.n	166c <prvCopyDataToQueue+0x48>
		(void)memcpy((void *)pxQueue->pcWriteTo,
    164e:	6880      	ldr	r0, [r0, #8]
    1650:	4b12      	ldr	r3, [pc, #72]	; (169c <prvCopyDataToQueue+0x78>)
    1652:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1654:	68a3      	ldr	r3, [r4, #8]
    1656:	6c22      	ldr	r2, [r4, #64]	; 0x40
    1658:	4694      	mov	ip, r2
    165a:	4463      	add	r3, ip
    165c:	60a3      	str	r3, [r4, #8]
	BaseType_t  xReturn = pdFALSE;
    165e:	2000      	movs	r0, #0
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
    1660:	6862      	ldr	r2, [r4, #4]
    1662:	4293      	cmp	r3, r2
    1664:	d3ee      	bcc.n	1644 <prvCopyDataToQueue+0x20>
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1666:	6823      	ldr	r3, [r4, #0]
    1668:	60a3      	str	r3, [r4, #8]
    166a:	e7eb      	b.n	1644 <prvCopyDataToQueue+0x20>
		(void)memcpy((void *)pxQueue->u.pcReadFrom,
    166c:	68c0      	ldr	r0, [r0, #12]
    166e:	4b0b      	ldr	r3, [pc, #44]	; (169c <prvCopyDataToQueue+0x78>)
    1670:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    1672:	6c23      	ldr	r3, [r4, #64]	; 0x40
    1674:	425b      	negs	r3, r3
    1676:	68e2      	ldr	r2, [r4, #12]
    1678:	18d2      	adds	r2, r2, r3
    167a:	60e2      	str	r2, [r4, #12]
		if (pxQueue->u.pcReadFrom
    167c:	6821      	ldr	r1, [r4, #0]
    167e:	428a      	cmp	r2, r1
    1680:	d203      	bcs.n	168a <prvCopyDataToQueue+0x66>
			pxQueue->u.pcReadFrom = (pxQueue->pcTail - pxQueue->uxItemSize);
    1682:	6862      	ldr	r2, [r4, #4]
    1684:	4694      	mov	ip, r2
    1686:	4463      	add	r3, ip
    1688:	60e3      	str	r3, [r4, #12]
	BaseType_t  xReturn = pdFALSE;
    168a:	2000      	movs	r0, #0
		if (xPosition == queueOVERWRITE) {
    168c:	2e02      	cmp	r6, #2
    168e:	d1d9      	bne.n	1644 <prvCopyDataToQueue+0x20>
			if (uxMessagesWaiting > (UBaseType_t)0) {
    1690:	4285      	cmp	r5, r0
    1692:	d0d7      	beq.n	1644 <prvCopyDataToQueue+0x20>
				--uxMessagesWaiting;
    1694:	3d01      	subs	r5, #1
    1696:	e7d5      	b.n	1644 <prvCopyDataToQueue+0x20>
    1698:	00002661 	.word	0x00002661
    169c:	00002b45 	.word	0x00002b45

000016a0 <prvNotifyQueueSetContainer>:
	/*-----------------------------------------------------------*/

#if (configUSE_QUEUE_SETS == 1)

static BaseType_t prvNotifyQueueSetContainer(const Queue_t *const pxQueue, const BaseType_t xCopyPosition)
{
    16a0:	b570      	push	{r4, r5, r6, lr}
    16a2:	b082      	sub	sp, #8
    16a4:	9001      	str	r0, [sp, #4]
    16a6:	000a      	movs	r2, r1
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
    16a8:	6c84      	ldr	r4, [r0, #72]	; 0x48
	BaseType_t xReturn             = pdFALSE;

	/* This function must be called form a critical section. */

	configASSERT(pxQueueSetContainer);
    16aa:	2c00      	cmp	r4, #0
    16ac:	d005      	beq.n	16ba <prvNotifyQueueSetContainer+0x1a>
	configASSERT(pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength);
    16ae:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    16b0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    16b2:	4299      	cmp	r1, r3
    16b4:	d303      	bcc.n	16be <prvNotifyQueueSetContainer+0x1e>
    16b6:	b672      	cpsid	i
    16b8:	e7fe      	b.n	16b8 <prvNotifyQueueSetContainer+0x18>
	configASSERT(pxQueueSetContainer);
    16ba:	b672      	cpsid	i
    16bc:	e7fe      	b.n	16bc <prvNotifyQueueSetContainer+0x1c>

	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
    16be:	6ba1      	ldr	r1, [r4, #56]	; 0x38
	BaseType_t xReturn             = pdFALSE;
    16c0:	2600      	movs	r6, #0
	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
    16c2:	428b      	cmp	r3, r1
    16c4:	d802      	bhi.n	16cc <prvNotifyQueueSetContainer+0x2c>
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    16c6:	0030      	movs	r0, r6
    16c8:	b002      	add	sp, #8
    16ca:	bd70      	pop	{r4, r5, r6, pc}
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    16cc:	2345      	movs	r3, #69	; 0x45
    16ce:	5ce5      	ldrb	r5, [r4, r3]
    16d0:	b26d      	sxtb	r5, r5
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
    16d2:	a901      	add	r1, sp, #4
    16d4:	0020      	movs	r0, r4
    16d6:	4b0a      	ldr	r3, [pc, #40]	; (1700 <prvNotifyQueueSetContainer+0x60>)
    16d8:	4798      	blx	r3
    16da:	0006      	movs	r6, r0
		if (cTxLock == queueUNLOCKED) {
    16dc:	1c6b      	adds	r3, r5, #1
    16de:	d10a      	bne.n	16f6 <prvNotifyQueueSetContainer+0x56>
			if (listLIST_IS_EMPTY(&(pxQueueSetContainer->xTasksWaitingToReceive)) == pdFALSE) {
    16e0:	6a63      	ldr	r3, [r4, #36]	; 0x24
    16e2:	2b00      	cmp	r3, #0
    16e4:	d0ef      	beq.n	16c6 <prvNotifyQueueSetContainer+0x26>
				if (xTaskRemoveFromEventList(&(pxQueueSetContainer->xTasksWaitingToReceive)) != pdFALSE) {
    16e6:	0020      	movs	r0, r4
    16e8:	3024      	adds	r0, #36	; 0x24
    16ea:	4b06      	ldr	r3, [pc, #24]	; (1704 <prvNotifyQueueSetContainer+0x64>)
    16ec:	4798      	blx	r3
    16ee:	2800      	cmp	r0, #0
    16f0:	d0e9      	beq.n	16c6 <prvNotifyQueueSetContainer+0x26>
					xReturn = pdTRUE;
    16f2:	2601      	movs	r6, #1
    16f4:	e7e7      	b.n	16c6 <prvNotifyQueueSetContainer+0x26>
			pxQueueSetContainer->cTxLock = (int8_t)(cTxLock + 1);
    16f6:	3501      	adds	r5, #1
    16f8:	b26d      	sxtb	r5, r5
    16fa:	2345      	movs	r3, #69	; 0x45
    16fc:	54e5      	strb	r5, [r4, r3]
    16fe:	e7e2      	b.n	16c6 <prvNotifyQueueSetContainer+0x26>
    1700:	00001625 	.word	0x00001625
    1704:	000024a9 	.word	0x000024a9

00001708 <prvCopyDataFromQueue>:
{
    1708:	b510      	push	{r4, lr}
    170a:	000c      	movs	r4, r1
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
    170c:	6c02      	ldr	r2, [r0, #64]	; 0x40
    170e:	2a00      	cmp	r2, #0
    1710:	d00b      	beq.n	172a <prvCopyDataFromQueue+0x22>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1712:	68c3      	ldr	r3, [r0, #12]
    1714:	189b      	adds	r3, r3, r2
    1716:	60c3      	str	r3, [r0, #12]
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
    1718:	6841      	ldr	r1, [r0, #4]
    171a:	428b      	cmp	r3, r1
    171c:	d301      	bcc.n	1722 <prvCopyDataFromQueue+0x1a>
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    171e:	6803      	ldr	r3, [r0, #0]
    1720:	60c3      	str	r3, [r0, #12]
		(void)memcpy((void *)pvBuffer,
    1722:	68c1      	ldr	r1, [r0, #12]
    1724:	0020      	movs	r0, r4
    1726:	4b01      	ldr	r3, [pc, #4]	; (172c <prvCopyDataFromQueue+0x24>)
    1728:	4798      	blx	r3
}
    172a:	bd10      	pop	{r4, pc}
    172c:	00002b45 	.word	0x00002b45

00001730 <prvUnlockQueue>:
{
    1730:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1732:	0007      	movs	r7, r0
	taskENTER_CRITICAL();
    1734:	4b25      	ldr	r3, [pc, #148]	; (17cc <prvUnlockQueue+0x9c>)
    1736:	4798      	blx	r3
		int8_t cTxLock = pxQueue->cTxLock;
    1738:	2345      	movs	r3, #69	; 0x45
    173a:	5cfc      	ldrb	r4, [r7, r3]
    173c:	b264      	sxtb	r4, r4
		while (cTxLock > queueLOCKED_UNMODIFIED) {
    173e:	2c00      	cmp	r4, #0
    1740:	dd1c      	ble.n	177c <prvUnlockQueue+0x4c>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    1742:	4e23      	ldr	r6, [pc, #140]	; (17d0 <prvUnlockQueue+0xa0>)
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    1744:	4d23      	ldr	r5, [pc, #140]	; (17d4 <prvUnlockQueue+0xa4>)
    1746:	e00b      	b.n	1760 <prvUnlockQueue+0x30>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    1748:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    174a:	2b00      	cmp	r3, #0
    174c:	d016      	beq.n	177c <prvUnlockQueue+0x4c>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    174e:	0038      	movs	r0, r7
    1750:	3024      	adds	r0, #36	; 0x24
    1752:	47a8      	blx	r5
    1754:	2800      	cmp	r0, #0
    1756:	d10e      	bne.n	1776 <prvUnlockQueue+0x46>
    1758:	3c01      	subs	r4, #1
    175a:	b264      	sxtb	r4, r4
		while (cTxLock > queueLOCKED_UNMODIFIED) {
    175c:	2c00      	cmp	r4, #0
    175e:	d00d      	beq.n	177c <prvUnlockQueue+0x4c>
				if (pxQueue->pxQueueSetContainer != NULL) {
    1760:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    1762:	2b00      	cmp	r3, #0
    1764:	d0f0      	beq.n	1748 <prvUnlockQueue+0x18>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    1766:	2100      	movs	r1, #0
    1768:	0038      	movs	r0, r7
    176a:	47b0      	blx	r6
    176c:	2800      	cmp	r0, #0
    176e:	d0f3      	beq.n	1758 <prvUnlockQueue+0x28>
						vTaskMissedYield();
    1770:	4b19      	ldr	r3, [pc, #100]	; (17d8 <prvUnlockQueue+0xa8>)
    1772:	4798      	blx	r3
    1774:	e7f0      	b.n	1758 <prvUnlockQueue+0x28>
							vTaskMissedYield();
    1776:	4b18      	ldr	r3, [pc, #96]	; (17d8 <prvUnlockQueue+0xa8>)
    1778:	4798      	blx	r3
    177a:	e7ed      	b.n	1758 <prvUnlockQueue+0x28>
		pxQueue->cTxLock = queueUNLOCKED;
    177c:	22ff      	movs	r2, #255	; 0xff
    177e:	2345      	movs	r3, #69	; 0x45
    1780:	54fa      	strb	r2, [r7, r3]
	taskEXIT_CRITICAL();
    1782:	4b16      	ldr	r3, [pc, #88]	; (17dc <prvUnlockQueue+0xac>)
    1784:	4798      	blx	r3
	taskENTER_CRITICAL();
    1786:	4b11      	ldr	r3, [pc, #68]	; (17cc <prvUnlockQueue+0x9c>)
    1788:	4798      	blx	r3
		int8_t cRxLock = pxQueue->cRxLock;
    178a:	2344      	movs	r3, #68	; 0x44
    178c:	5cfc      	ldrb	r4, [r7, r3]
    178e:	b264      	sxtb	r4, r4
		while (cRxLock > queueLOCKED_UNMODIFIED) {
    1790:	2c00      	cmp	r4, #0
    1792:	dd14      	ble.n	17be <prvUnlockQueue+0x8e>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    1794:	693b      	ldr	r3, [r7, #16]
    1796:	2b00      	cmp	r3, #0
    1798:	d011      	beq.n	17be <prvUnlockQueue+0x8e>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    179a:	003d      	movs	r5, r7
    179c:	3510      	adds	r5, #16
    179e:	4e0d      	ldr	r6, [pc, #52]	; (17d4 <prvUnlockQueue+0xa4>)
    17a0:	e006      	b.n	17b0 <prvUnlockQueue+0x80>
    17a2:	3c01      	subs	r4, #1
    17a4:	b264      	sxtb	r4, r4
		while (cRxLock > queueLOCKED_UNMODIFIED) {
    17a6:	2c00      	cmp	r4, #0
    17a8:	d009      	beq.n	17be <prvUnlockQueue+0x8e>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    17aa:	693b      	ldr	r3, [r7, #16]
    17ac:	2b00      	cmp	r3, #0
    17ae:	d006      	beq.n	17be <prvUnlockQueue+0x8e>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    17b0:	0028      	movs	r0, r5
    17b2:	47b0      	blx	r6
    17b4:	2800      	cmp	r0, #0
    17b6:	d0f4      	beq.n	17a2 <prvUnlockQueue+0x72>
					vTaskMissedYield();
    17b8:	4b07      	ldr	r3, [pc, #28]	; (17d8 <prvUnlockQueue+0xa8>)
    17ba:	4798      	blx	r3
    17bc:	e7f1      	b.n	17a2 <prvUnlockQueue+0x72>
		pxQueue->cRxLock = queueUNLOCKED;
    17be:	22ff      	movs	r2, #255	; 0xff
    17c0:	2344      	movs	r3, #68	; 0x44
    17c2:	54fa      	strb	r2, [r7, r3]
	taskEXIT_CRITICAL();
    17c4:	4b05      	ldr	r3, [pc, #20]	; (17dc <prvUnlockQueue+0xac>)
    17c6:	4798      	blx	r3
}
    17c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    17ca:	46c0      	nop			; (mov r8, r8)
    17cc:	000014d5 	.word	0x000014d5
    17d0:	000016a1 	.word	0x000016a1
    17d4:	000024a9 	.word	0x000024a9
    17d8:	000025a1 	.word	0x000025a1
    17dc:	000014ed 	.word	0x000014ed

000017e0 <xQueueGenericReset>:
{
    17e0:	b570      	push	{r4, r5, r6, lr}
    17e2:	0004      	movs	r4, r0
    17e4:	000d      	movs	r5, r1
	configASSERT(pxQueue);
    17e6:	2800      	cmp	r0, #0
    17e8:	d021      	beq.n	182e <xQueueGenericReset+0x4e>
	taskENTER_CRITICAL();
    17ea:	4b17      	ldr	r3, [pc, #92]	; (1848 <xQueueGenericReset+0x68>)
    17ec:	4798      	blx	r3
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    17ee:	6822      	ldr	r2, [r4, #0]
    17f0:	6c21      	ldr	r1, [r4, #64]	; 0x40
    17f2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    17f4:	434b      	muls	r3, r1
    17f6:	18d0      	adds	r0, r2, r3
    17f8:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
    17fa:	2000      	movs	r0, #0
    17fc:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo         = pxQueue->pcHead;
    17fe:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
    1800:	1a5b      	subs	r3, r3, r1
    1802:	18d3      	adds	r3, r2, r3
    1804:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock           = queueUNLOCKED;
    1806:	23ff      	movs	r3, #255	; 0xff
    1808:	2244      	movs	r2, #68	; 0x44
    180a:	54a3      	strb	r3, [r4, r2]
		pxQueue->cTxLock           = queueUNLOCKED;
    180c:	3201      	adds	r2, #1
    180e:	54a3      	strb	r3, [r4, r2]
		if (xNewQueue == pdFALSE) {
    1810:	2d00      	cmp	r5, #0
    1812:	d111      	bne.n	1838 <xQueueGenericReset+0x58>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    1814:	6923      	ldr	r3, [r4, #16]
    1816:	2b00      	cmp	r3, #0
    1818:	d005      	beq.n	1826 <xQueueGenericReset+0x46>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    181a:	0020      	movs	r0, r4
    181c:	3010      	adds	r0, #16
    181e:	4b0b      	ldr	r3, [pc, #44]	; (184c <xQueueGenericReset+0x6c>)
    1820:	4798      	blx	r3
    1822:	2800      	cmp	r0, #0
    1824:	d105      	bne.n	1832 <xQueueGenericReset+0x52>
	taskEXIT_CRITICAL();
    1826:	4b0a      	ldr	r3, [pc, #40]	; (1850 <xQueueGenericReset+0x70>)
    1828:	4798      	blx	r3
}
    182a:	2001      	movs	r0, #1
    182c:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT(pxQueue);
    182e:	b672      	cpsid	i
    1830:	e7fe      	b.n	1830 <xQueueGenericReset+0x50>
					queueYIELD_IF_USING_PREEMPTION();
    1832:	4b08      	ldr	r3, [pc, #32]	; (1854 <xQueueGenericReset+0x74>)
    1834:	4798      	blx	r3
    1836:	e7f6      	b.n	1826 <xQueueGenericReset+0x46>
			vListInitialise(&(pxQueue->xTasksWaitingToSend));
    1838:	0020      	movs	r0, r4
    183a:	3010      	adds	r0, #16
    183c:	4d06      	ldr	r5, [pc, #24]	; (1858 <xQueueGenericReset+0x78>)
    183e:	47a8      	blx	r5
			vListInitialise(&(pxQueue->xTasksWaitingToReceive));
    1840:	0020      	movs	r0, r4
    1842:	3024      	adds	r0, #36	; 0x24
    1844:	47a8      	blx	r5
    1846:	e7ee      	b.n	1826 <xQueueGenericReset+0x46>
    1848:	000014d5 	.word	0x000014d5
    184c:	000024a9 	.word	0x000024a9
    1850:	000014ed 	.word	0x000014ed
    1854:	000014bd 	.word	0x000014bd
    1858:	00001351 	.word	0x00001351

0000185c <xQueueGenericCreate>:
{
    185c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    185e:	0006      	movs	r6, r0
    1860:	000d      	movs	r5, r1
    1862:	0017      	movs	r7, r2
	configASSERT(uxQueueLength > (UBaseType_t)0);
    1864:	2800      	cmp	r0, #0
    1866:	d101      	bne.n	186c <xQueueGenericCreate+0x10>
    1868:	b672      	cpsid	i
    186a:	e7fe      	b.n	186a <xQueueGenericCreate+0xe>
		xQueueSizeInBytes = (size_t)(
    186c:	0008      	movs	r0, r1
    186e:	4370      	muls	r0, r6
	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t) + xQueueSizeInBytes);
    1870:	3054      	adds	r0, #84	; 0x54
    1872:	4b0b      	ldr	r3, [pc, #44]	; (18a0 <xQueueGenericCreate+0x44>)
    1874:	4798      	blx	r3
    1876:	1e04      	subs	r4, r0, #0
	if (pxNewQueue != NULL) {
    1878:	d010      	beq.n	189c <xQueueGenericCreate+0x40>
	if (uxItemSize == (UBaseType_t)0) {
    187a:	2d00      	cmp	r5, #0
    187c:	d003      	beq.n	1886 <xQueueGenericCreate+0x2a>
		pucQueueStorage = ((uint8_t *)pxNewQueue) + sizeof(Queue_t);
    187e:	0003      	movs	r3, r0
    1880:	3354      	adds	r3, #84	; 0x54
		pxNewQueue->pcHead = (int8_t *)pucQueueStorage;
    1882:	6003      	str	r3, [r0, #0]
    1884:	e000      	b.n	1888 <xQueueGenericCreate+0x2c>
		pxNewQueue->pcHead = (int8_t *)pxNewQueue;
    1886:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength   = uxQueueLength;
    1888:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
    188a:	6425      	str	r5, [r4, #64]	; 0x40
	(void)xQueueGenericReset(pxNewQueue, pdTRUE);
    188c:	2101      	movs	r1, #1
    188e:	0020      	movs	r0, r4
    1890:	4b04      	ldr	r3, [pc, #16]	; (18a4 <xQueueGenericCreate+0x48>)
    1892:	4798      	blx	r3
		pxNewQueue->ucQueueType = ucQueueType;
    1894:	2350      	movs	r3, #80	; 0x50
    1896:	54e7      	strb	r7, [r4, r3]
		pxNewQueue->pxQueueSetContainer = NULL;
    1898:	2300      	movs	r3, #0
    189a:	64a3      	str	r3, [r4, #72]	; 0x48
}
    189c:	0020      	movs	r0, r4
    189e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    18a0:	00001595 	.word	0x00001595
    18a4:	000017e1 	.word	0x000017e1

000018a8 <xQueueGenericSend>:
{
    18a8:	b5f0      	push	{r4, r5, r6, r7, lr}
    18aa:	46ce      	mov	lr, r9
    18ac:	4647      	mov	r7, r8
    18ae:	b580      	push	{r7, lr}
    18b0:	b085      	sub	sp, #20
    18b2:	0004      	movs	r4, r0
    18b4:	000f      	movs	r7, r1
    18b6:	9201      	str	r2, [sp, #4]
    18b8:	001d      	movs	r5, r3
	configASSERT(pxQueue);
    18ba:	2800      	cmp	r0, #0
    18bc:	d00c      	beq.n	18d8 <xQueueGenericSend+0x30>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    18be:	2900      	cmp	r1, #0
    18c0:	d00c      	beq.n	18dc <xQueueGenericSend+0x34>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    18c2:	2d02      	cmp	r5, #2
    18c4:	d00f      	beq.n	18e6 <xQueueGenericSend+0x3e>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    18c6:	4b4e      	ldr	r3, [pc, #312]	; (1a00 <xQueueGenericSend+0x158>)
    18c8:	4798      	blx	r3
    18ca:	2800      	cmp	r0, #0
    18cc:	d110      	bne.n	18f0 <xQueueGenericSend+0x48>
    18ce:	9b01      	ldr	r3, [sp, #4]
    18d0:	2b00      	cmp	r3, #0
    18d2:	d011      	beq.n	18f8 <xQueueGenericSend+0x50>
    18d4:	b672      	cpsid	i
    18d6:	e7fe      	b.n	18d6 <xQueueGenericSend+0x2e>
	configASSERT(pxQueue);
    18d8:	b672      	cpsid	i
    18da:	e7fe      	b.n	18da <xQueueGenericSend+0x32>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    18dc:	6c03      	ldr	r3, [r0, #64]	; 0x40
    18de:	2b00      	cmp	r3, #0
    18e0:	d0ef      	beq.n	18c2 <xQueueGenericSend+0x1a>
    18e2:	b672      	cpsid	i
    18e4:	e7fe      	b.n	18e4 <xQueueGenericSend+0x3c>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    18e6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    18e8:	2b01      	cmp	r3, #1
    18ea:	d0ec      	beq.n	18c6 <xQueueGenericSend+0x1e>
    18ec:	b672      	cpsid	i
    18ee:	e7fe      	b.n	18ee <xQueueGenericSend+0x46>
    18f0:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
    18f2:	4b44      	ldr	r3, [pc, #272]	; (1a04 <xQueueGenericSend+0x15c>)
    18f4:	4698      	mov	r8, r3
    18f6:	e04c      	b.n	1992 <xQueueGenericSend+0xea>
    18f8:	2600      	movs	r6, #0
    18fa:	e7fa      	b.n	18f2 <xQueueGenericSend+0x4a>
				xYieldRequired = prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    18fc:	002a      	movs	r2, r5
    18fe:	0039      	movs	r1, r7
    1900:	0020      	movs	r0, r4
    1902:	4b41      	ldr	r3, [pc, #260]	; (1a08 <xQueueGenericSend+0x160>)
    1904:	4798      	blx	r3
					if (pxQueue->pxQueueSetContainer != NULL) {
    1906:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    1908:	2b00      	cmp	r3, #0
    190a:	d00f      	beq.n	192c <xQueueGenericSend+0x84>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    190c:	0029      	movs	r1, r5
    190e:	0020      	movs	r0, r4
    1910:	4b3e      	ldr	r3, [pc, #248]	; (1a0c <xQueueGenericSend+0x164>)
    1912:	4798      	blx	r3
    1914:	2800      	cmp	r0, #0
    1916:	d001      	beq.n	191c <xQueueGenericSend+0x74>
							queueYIELD_IF_USING_PREEMPTION();
    1918:	4b3d      	ldr	r3, [pc, #244]	; (1a10 <xQueueGenericSend+0x168>)
    191a:	4798      	blx	r3
				taskEXIT_CRITICAL();
    191c:	4b3d      	ldr	r3, [pc, #244]	; (1a14 <xQueueGenericSend+0x16c>)
    191e:	4798      	blx	r3
				return pdPASS;
    1920:	2001      	movs	r0, #1
}
    1922:	b005      	add	sp, #20
    1924:	bc0c      	pop	{r2, r3}
    1926:	4690      	mov	r8, r2
    1928:	4699      	mov	r9, r3
    192a:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    192c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    192e:	2b00      	cmp	r3, #0
    1930:	d008      	beq.n	1944 <xQueueGenericSend+0x9c>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    1932:	0020      	movs	r0, r4
    1934:	3024      	adds	r0, #36	; 0x24
    1936:	4b38      	ldr	r3, [pc, #224]	; (1a18 <xQueueGenericSend+0x170>)
    1938:	4798      	blx	r3
    193a:	2800      	cmp	r0, #0
    193c:	d0ee      	beq.n	191c <xQueueGenericSend+0x74>
								queueYIELD_IF_USING_PREEMPTION();
    193e:	4b34      	ldr	r3, [pc, #208]	; (1a10 <xQueueGenericSend+0x168>)
    1940:	4798      	blx	r3
    1942:	e7eb      	b.n	191c <xQueueGenericSend+0x74>
						} else if (xYieldRequired != pdFALSE) {
    1944:	2800      	cmp	r0, #0
    1946:	d0e9      	beq.n	191c <xQueueGenericSend+0x74>
							queueYIELD_IF_USING_PREEMPTION();
    1948:	4b31      	ldr	r3, [pc, #196]	; (1a10 <xQueueGenericSend+0x168>)
    194a:	4798      	blx	r3
    194c:	e7e6      	b.n	191c <xQueueGenericSend+0x74>
					taskEXIT_CRITICAL();
    194e:	4b31      	ldr	r3, [pc, #196]	; (1a14 <xQueueGenericSend+0x16c>)
    1950:	4798      	blx	r3
					return errQUEUE_FULL;
    1952:	2000      	movs	r0, #0
    1954:	e7e5      	b.n	1922 <xQueueGenericSend+0x7a>
		prvLockQueue(pxQueue);
    1956:	4b2f      	ldr	r3, [pc, #188]	; (1a14 <xQueueGenericSend+0x16c>)
    1958:	4798      	blx	r3
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    195a:	a901      	add	r1, sp, #4
    195c:	a802      	add	r0, sp, #8
    195e:	4b2f      	ldr	r3, [pc, #188]	; (1a1c <xQueueGenericSend+0x174>)
    1960:	4798      	blx	r3
    1962:	2800      	cmp	r0, #0
    1964:	d144      	bne.n	19f0 <xQueueGenericSend+0x148>
	taskENTER_CRITICAL();
    1966:	4b27      	ldr	r3, [pc, #156]	; (1a04 <xQueueGenericSend+0x15c>)
    1968:	4798      	blx	r3
		if (pxQueue->uxMessagesWaiting == pxQueue->uxLength) {
    196a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    196c:	4699      	mov	r9, r3
    196e:	6be6      	ldr	r6, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
    1970:	4b28      	ldr	r3, [pc, #160]	; (1a14 <xQueueGenericSend+0x16c>)
    1972:	4798      	blx	r3
			if (prvIsQueueFull(pxQueue) != pdFALSE) {
    1974:	45b1      	cmp	r9, r6
    1976:	d135      	bne.n	19e4 <xQueueGenericSend+0x13c>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToSend), xTicksToWait);
    1978:	0020      	movs	r0, r4
    197a:	3010      	adds	r0, #16
    197c:	9901      	ldr	r1, [sp, #4]
    197e:	4b28      	ldr	r3, [pc, #160]	; (1a20 <xQueueGenericSend+0x178>)
    1980:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    1982:	0020      	movs	r0, r4
    1984:	4b27      	ldr	r3, [pc, #156]	; (1a24 <xQueueGenericSend+0x17c>)
    1986:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    1988:	4b27      	ldr	r3, [pc, #156]	; (1a28 <xQueueGenericSend+0x180>)
    198a:	4798      	blx	r3
    198c:	2800      	cmp	r0, #0
    198e:	d026      	beq.n	19de <xQueueGenericSend+0x136>
    1990:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    1992:	47c0      	blx	r8
			if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    1994:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    1996:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    1998:	4293      	cmp	r3, r2
    199a:	d3af      	bcc.n	18fc <xQueueGenericSend+0x54>
    199c:	2d02      	cmp	r5, #2
    199e:	d0ad      	beq.n	18fc <xQueueGenericSend+0x54>
				if (xTicksToWait == (TickType_t)0) {
    19a0:	9b01      	ldr	r3, [sp, #4]
    19a2:	2b00      	cmp	r3, #0
    19a4:	d0d3      	beq.n	194e <xQueueGenericSend+0xa6>
				} else if (xEntryTimeSet == pdFALSE) {
    19a6:	2e00      	cmp	r6, #0
    19a8:	d102      	bne.n	19b0 <xQueueGenericSend+0x108>
					vTaskInternalSetTimeOutState(&xTimeOut);
    19aa:	a802      	add	r0, sp, #8
    19ac:	4b1f      	ldr	r3, [pc, #124]	; (1a2c <xQueueGenericSend+0x184>)
    19ae:	4798      	blx	r3
		taskEXIT_CRITICAL();
    19b0:	4b18      	ldr	r3, [pc, #96]	; (1a14 <xQueueGenericSend+0x16c>)
    19b2:	4798      	blx	r3
		vTaskSuspendAll();
    19b4:	4b1e      	ldr	r3, [pc, #120]	; (1a30 <xQueueGenericSend+0x188>)
    19b6:	4798      	blx	r3
		prvLockQueue(pxQueue);
    19b8:	4b12      	ldr	r3, [pc, #72]	; (1a04 <xQueueGenericSend+0x15c>)
    19ba:	4798      	blx	r3
    19bc:	2344      	movs	r3, #68	; 0x44
    19be:	5ce3      	ldrb	r3, [r4, r3]
    19c0:	b25b      	sxtb	r3, r3
    19c2:	3301      	adds	r3, #1
    19c4:	d102      	bne.n	19cc <xQueueGenericSend+0x124>
    19c6:	2200      	movs	r2, #0
    19c8:	2344      	movs	r3, #68	; 0x44
    19ca:	54e2      	strb	r2, [r4, r3]
    19cc:	2345      	movs	r3, #69	; 0x45
    19ce:	5ce3      	ldrb	r3, [r4, r3]
    19d0:	b25b      	sxtb	r3, r3
    19d2:	3301      	adds	r3, #1
    19d4:	d1bf      	bne.n	1956 <xQueueGenericSend+0xae>
    19d6:	2200      	movs	r2, #0
    19d8:	2345      	movs	r3, #69	; 0x45
    19da:	54e2      	strb	r2, [r4, r3]
    19dc:	e7bb      	b.n	1956 <xQueueGenericSend+0xae>
					portYIELD_WITHIN_API();
    19de:	4b0c      	ldr	r3, [pc, #48]	; (1a10 <xQueueGenericSend+0x168>)
    19e0:	4798      	blx	r3
    19e2:	e7d5      	b.n	1990 <xQueueGenericSend+0xe8>
				prvUnlockQueue(pxQueue);
    19e4:	0020      	movs	r0, r4
    19e6:	4b0f      	ldr	r3, [pc, #60]	; (1a24 <xQueueGenericSend+0x17c>)
    19e8:	4798      	blx	r3
				(void)xTaskResumeAll();
    19ea:	4b0f      	ldr	r3, [pc, #60]	; (1a28 <xQueueGenericSend+0x180>)
    19ec:	4798      	blx	r3
    19ee:	e7cf      	b.n	1990 <xQueueGenericSend+0xe8>
			prvUnlockQueue(pxQueue);
    19f0:	0020      	movs	r0, r4
    19f2:	4b0c      	ldr	r3, [pc, #48]	; (1a24 <xQueueGenericSend+0x17c>)
    19f4:	4798      	blx	r3
			(void)xTaskResumeAll();
    19f6:	4b0c      	ldr	r3, [pc, #48]	; (1a28 <xQueueGenericSend+0x180>)
    19f8:	4798      	blx	r3
			return errQUEUE_FULL;
    19fa:	2000      	movs	r0, #0
    19fc:	e791      	b.n	1922 <xQueueGenericSend+0x7a>
    19fe:	46c0      	nop			; (mov r8, r8)
    1a00:	000025ad 	.word	0x000025ad
    1a04:	000014d5 	.word	0x000014d5
    1a08:	00001625 	.word	0x00001625
    1a0c:	000016a1 	.word	0x000016a1
    1a10:	000014bd 	.word	0x000014bd
    1a14:	000014ed 	.word	0x000014ed
    1a18:	000024a9 	.word	0x000024a9
    1a1c:	00002535 	.word	0x00002535
    1a20:	00002445 	.word	0x00002445
    1a24:	00001731 	.word	0x00001731
    1a28:	00002289 	.word	0x00002289
    1a2c:	00002525 	.word	0x00002525
    1a30:	00002161 	.word	0x00002161

00001a34 <xQueueCreateMutex>:
{
    1a34:	b570      	push	{r4, r5, r6, lr}
    1a36:	0002      	movs	r2, r0
	pxNewQueue = (Queue_t *)xQueueGenericCreate(uxMutexLength, uxMutexSize, ucQueueType);
    1a38:	2100      	movs	r1, #0
    1a3a:	2001      	movs	r0, #1
    1a3c:	4b06      	ldr	r3, [pc, #24]	; (1a58 <xQueueCreateMutex+0x24>)
    1a3e:	4798      	blx	r3
    1a40:	1e04      	subs	r4, r0, #0
	if (pxNewQueue != NULL) {
    1a42:	d007      	beq.n	1a54 <xQueueCreateMutex+0x20>
		pxNewQueue->pxMutexHolder = NULL;
    1a44:	2300      	movs	r3, #0
    1a46:	6043      	str	r3, [r0, #4]
		pxNewQueue->uxQueueType   = queueQUEUE_IS_MUTEX;
    1a48:	6003      	str	r3, [r0, #0]
		pxNewQueue->u.uxRecursiveCallCount = 0;
    1a4a:	60c3      	str	r3, [r0, #12]
		(void)xQueueGenericSend(pxNewQueue, NULL, (TickType_t)0U, queueSEND_TO_BACK);
    1a4c:	2200      	movs	r2, #0
    1a4e:	2100      	movs	r1, #0
    1a50:	4d02      	ldr	r5, [pc, #8]	; (1a5c <xQueueCreateMutex+0x28>)
    1a52:	47a8      	blx	r5
}
    1a54:	0020      	movs	r0, r4
    1a56:	bd70      	pop	{r4, r5, r6, pc}
    1a58:	0000185d 	.word	0x0000185d
    1a5c:	000018a9 	.word	0x000018a9

00001a60 <xQueueGenericSendFromISR>:
{
    1a60:	b5f0      	push	{r4, r5, r6, r7, lr}
    1a62:	b083      	sub	sp, #12
    1a64:	0004      	movs	r4, r0
    1a66:	9101      	str	r1, [sp, #4]
    1a68:	0016      	movs	r6, r2
    1a6a:	001d      	movs	r5, r3
	configASSERT(pxQueue);
    1a6c:	2800      	cmp	r0, #0
    1a6e:	d012      	beq.n	1a96 <xQueueGenericSendFromISR+0x36>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    1a70:	9b01      	ldr	r3, [sp, #4]
    1a72:	2b00      	cmp	r3, #0
    1a74:	d011      	beq.n	1a9a <xQueueGenericSendFromISR+0x3a>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    1a76:	2d02      	cmp	r5, #2
    1a78:	d014      	beq.n	1aa4 <xQueueGenericSendFromISR+0x44>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1a7a:	4b28      	ldr	r3, [pc, #160]	; (1b1c <xQueueGenericSendFromISR+0xbc>)
    1a7c:	4798      	blx	r3
    1a7e:	9000      	str	r0, [sp, #0]
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    1a80:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    1a82:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    1a84:	429a      	cmp	r2, r3
    1a86:	d82f      	bhi.n	1ae8 <xQueueGenericSendFromISR+0x88>
			xReturn = errQUEUE_FULL;
    1a88:	2500      	movs	r5, #0
	portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);
    1a8a:	9800      	ldr	r0, [sp, #0]
    1a8c:	4b24      	ldr	r3, [pc, #144]	; (1b20 <xQueueGenericSendFromISR+0xc0>)
    1a8e:	4798      	blx	r3
}
    1a90:	0028      	movs	r0, r5
    1a92:	b003      	add	sp, #12
    1a94:	bdf0      	pop	{r4, r5, r6, r7, pc}
	configASSERT(pxQueue);
    1a96:	b672      	cpsid	i
    1a98:	e7fe      	b.n	1a98 <xQueueGenericSendFromISR+0x38>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    1a9a:	6c03      	ldr	r3, [r0, #64]	; 0x40
    1a9c:	2b00      	cmp	r3, #0
    1a9e:	d0ea      	beq.n	1a76 <xQueueGenericSendFromISR+0x16>
    1aa0:	b672      	cpsid	i
    1aa2:	e7fe      	b.n	1aa2 <xQueueGenericSendFromISR+0x42>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    1aa4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    1aa6:	2b01      	cmp	r3, #1
    1aa8:	d01a      	beq.n	1ae0 <xQueueGenericSendFromISR+0x80>
    1aaa:	b672      	cpsid	i
    1aac:	e7fe      	b.n	1aac <xQueueGenericSendFromISR+0x4c>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    1aae:	6a63      	ldr	r3, [r4, #36]	; 0x24
			xReturn = pdPASS;
    1ab0:	2501      	movs	r5, #1
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    1ab2:	2b00      	cmp	r3, #0
    1ab4:	d0e9      	beq.n	1a8a <xQueueGenericSendFromISR+0x2a>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    1ab6:	0020      	movs	r0, r4
    1ab8:	3024      	adds	r0, #36	; 0x24
    1aba:	4b1a      	ldr	r3, [pc, #104]	; (1b24 <xQueueGenericSendFromISR+0xc4>)
    1abc:	4798      	blx	r3
    1abe:	2800      	cmp	r0, #0
    1ac0:	d0e3      	beq.n	1a8a <xQueueGenericSendFromISR+0x2a>
								if (pxHigherPriorityTaskWoken != NULL) {
    1ac2:	2e00      	cmp	r6, #0
    1ac4:	d00a      	beq.n	1adc <xQueueGenericSendFromISR+0x7c>
									*pxHigherPriorityTaskWoken = pdTRUE;
    1ac6:	2301      	movs	r3, #1
    1ac8:	6033      	str	r3, [r6, #0]
    1aca:	e7de      	b.n	1a8a <xQueueGenericSendFromISR+0x2a>
				pxQueue->cTxLock = (int8_t)(cTxLock + 1);
    1acc:	1c7b      	adds	r3, r7, #1
    1ace:	b25b      	sxtb	r3, r3
    1ad0:	2245      	movs	r2, #69	; 0x45
    1ad2:	54a3      	strb	r3, [r4, r2]
			xReturn = pdPASS;
    1ad4:	2501      	movs	r5, #1
    1ad6:	e7d8      	b.n	1a8a <xQueueGenericSendFromISR+0x2a>
    1ad8:	2501      	movs	r5, #1
    1ada:	e7d6      	b.n	1a8a <xQueueGenericSendFromISR+0x2a>
    1adc:	2501      	movs	r5, #1
    1ade:	e7d4      	b.n	1a8a <xQueueGenericSendFromISR+0x2a>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1ae0:	4b0e      	ldr	r3, [pc, #56]	; (1b1c <xQueueGenericSendFromISR+0xbc>)
    1ae2:	4798      	blx	r3
    1ae4:	9000      	str	r0, [sp, #0]
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    1ae6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			const int8_t cTxLock = pxQueue->cTxLock;
    1ae8:	2345      	movs	r3, #69	; 0x45
    1aea:	5ce7      	ldrb	r7, [r4, r3]
    1aec:	b27f      	sxtb	r7, r7
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    1aee:	002a      	movs	r2, r5
    1af0:	9901      	ldr	r1, [sp, #4]
    1af2:	0020      	movs	r0, r4
    1af4:	4b0c      	ldr	r3, [pc, #48]	; (1b28 <xQueueGenericSendFromISR+0xc8>)
    1af6:	4798      	blx	r3
			if (cTxLock == queueUNLOCKED) {
    1af8:	1c7b      	adds	r3, r7, #1
    1afa:	d1e7      	bne.n	1acc <xQueueGenericSendFromISR+0x6c>
					if (pxQueue->pxQueueSetContainer != NULL) {
    1afc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    1afe:	2b00      	cmp	r3, #0
    1b00:	d0d5      	beq.n	1aae <xQueueGenericSendFromISR+0x4e>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    1b02:	0029      	movs	r1, r5
    1b04:	0020      	movs	r0, r4
    1b06:	4b09      	ldr	r3, [pc, #36]	; (1b2c <xQueueGenericSendFromISR+0xcc>)
    1b08:	4798      	blx	r3
			xReturn = pdPASS;
    1b0a:	2501      	movs	r5, #1
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    1b0c:	2800      	cmp	r0, #0
    1b0e:	d0bc      	beq.n	1a8a <xQueueGenericSendFromISR+0x2a>
							if (pxHigherPriorityTaskWoken != NULL) {
    1b10:	2e00      	cmp	r6, #0
    1b12:	d0e1      	beq.n	1ad8 <xQueueGenericSendFromISR+0x78>
								*pxHigherPriorityTaskWoken = pdTRUE;
    1b14:	2301      	movs	r3, #1
    1b16:	6033      	str	r3, [r6, #0]
    1b18:	e7b7      	b.n	1a8a <xQueueGenericSendFromISR+0x2a>
    1b1a:	46c0      	nop			; (mov r8, r8)
    1b1c:	0000150d 	.word	0x0000150d
    1b20:	00001515 	.word	0x00001515
    1b24:	000024a9 	.word	0x000024a9
    1b28:	00001625 	.word	0x00001625
    1b2c:	000016a1 	.word	0x000016a1

00001b30 <xQueueReceive>:
{
    1b30:	b5f0      	push	{r4, r5, r6, r7, lr}
    1b32:	46c6      	mov	lr, r8
    1b34:	b500      	push	{lr}
    1b36:	b084      	sub	sp, #16
    1b38:	0004      	movs	r4, r0
    1b3a:	000f      	movs	r7, r1
    1b3c:	9201      	str	r2, [sp, #4]
	configASSERT((pxQueue));
    1b3e:	2800      	cmp	r0, #0
    1b40:	d00a      	beq.n	1b58 <xQueueReceive+0x28>
	configASSERT(!(((pvBuffer) == NULL) && ((pxQueue)->uxItemSize != (UBaseType_t)0U)));
    1b42:	2900      	cmp	r1, #0
    1b44:	d00a      	beq.n	1b5c <xQueueReceive+0x2c>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    1b46:	4b42      	ldr	r3, [pc, #264]	; (1c50 <xQueueReceive+0x120>)
    1b48:	4798      	blx	r3
    1b4a:	2800      	cmp	r0, #0
    1b4c:	d10b      	bne.n	1b66 <xQueueReceive+0x36>
    1b4e:	9b01      	ldr	r3, [sp, #4]
    1b50:	2b00      	cmp	r3, #0
    1b52:	d00c      	beq.n	1b6e <xQueueReceive+0x3e>
    1b54:	b672      	cpsid	i
    1b56:	e7fe      	b.n	1b56 <xQueueReceive+0x26>
	configASSERT((pxQueue));
    1b58:	b672      	cpsid	i
    1b5a:	e7fe      	b.n	1b5a <xQueueReceive+0x2a>
	configASSERT(!(((pvBuffer) == NULL) && ((pxQueue)->uxItemSize != (UBaseType_t)0U)));
    1b5c:	6c03      	ldr	r3, [r0, #64]	; 0x40
    1b5e:	2b00      	cmp	r3, #0
    1b60:	d0f1      	beq.n	1b46 <xQueueReceive+0x16>
    1b62:	b672      	cpsid	i
    1b64:	e7fe      	b.n	1b64 <xQueueReceive+0x34>
    1b66:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
    1b68:	4b3a      	ldr	r3, [pc, #232]	; (1c54 <xQueueReceive+0x124>)
    1b6a:	4698      	mov	r8, r3
    1b6c:	e02f      	b.n	1bce <xQueueReceive+0x9e>
    1b6e:	2600      	movs	r6, #0
    1b70:	e7fa      	b.n	1b68 <xQueueReceive+0x38>
				prvCopyDataFromQueue(pxQueue, pvBuffer);
    1b72:	0039      	movs	r1, r7
    1b74:	0020      	movs	r0, r4
    1b76:	4b38      	ldr	r3, [pc, #224]	; (1c58 <xQueueReceive+0x128>)
    1b78:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - (UBaseType_t)1;
    1b7a:	3d01      	subs	r5, #1
    1b7c:	63a5      	str	r5, [r4, #56]	; 0x38
				if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    1b7e:	6923      	ldr	r3, [r4, #16]
    1b80:	2b00      	cmp	r3, #0
    1b82:	d007      	beq.n	1b94 <xQueueReceive+0x64>
					if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    1b84:	0020      	movs	r0, r4
    1b86:	3010      	adds	r0, #16
    1b88:	4b34      	ldr	r3, [pc, #208]	; (1c5c <xQueueReceive+0x12c>)
    1b8a:	4798      	blx	r3
    1b8c:	2800      	cmp	r0, #0
    1b8e:	d001      	beq.n	1b94 <xQueueReceive+0x64>
						queueYIELD_IF_USING_PREEMPTION();
    1b90:	4b33      	ldr	r3, [pc, #204]	; (1c60 <xQueueReceive+0x130>)
    1b92:	4798      	blx	r3
				taskEXIT_CRITICAL();
    1b94:	4b33      	ldr	r3, [pc, #204]	; (1c64 <xQueueReceive+0x134>)
    1b96:	4798      	blx	r3
				return pdPASS;
    1b98:	2001      	movs	r0, #1
}
    1b9a:	b004      	add	sp, #16
    1b9c:	bc04      	pop	{r2}
    1b9e:	4690      	mov	r8, r2
    1ba0:	bdf0      	pop	{r4, r5, r6, r7, pc}
					taskEXIT_CRITICAL();
    1ba2:	4b30      	ldr	r3, [pc, #192]	; (1c64 <xQueueReceive+0x134>)
    1ba4:	4798      	blx	r3
					return errQUEUE_EMPTY;
    1ba6:	2000      	movs	r0, #0
    1ba8:	e7f7      	b.n	1b9a <xQueueReceive+0x6a>
					vTaskInternalSetTimeOutState(&xTimeOut);
    1baa:	a802      	add	r0, sp, #8
    1bac:	4b2e      	ldr	r3, [pc, #184]	; (1c68 <xQueueReceive+0x138>)
    1bae:	4798      	blx	r3
    1bb0:	e016      	b.n	1be0 <xQueueReceive+0xb0>
		prvLockQueue(pxQueue);
    1bb2:	2200      	movs	r2, #0
    1bb4:	2344      	movs	r3, #68	; 0x44
    1bb6:	54e2      	strb	r2, [r4, r3]
    1bb8:	e01d      	b.n	1bf6 <xQueueReceive+0xc6>
    1bba:	2200      	movs	r2, #0
    1bbc:	2345      	movs	r3, #69	; 0x45
    1bbe:	54e2      	strb	r2, [r4, r3]
    1bc0:	e01e      	b.n	1c00 <xQueueReceive+0xd0>
				prvUnlockQueue(pxQueue);
    1bc2:	0020      	movs	r0, r4
    1bc4:	4b29      	ldr	r3, [pc, #164]	; (1c6c <xQueueReceive+0x13c>)
    1bc6:	4798      	blx	r3
				(void)xTaskResumeAll();
    1bc8:	4b29      	ldr	r3, [pc, #164]	; (1c70 <xQueueReceive+0x140>)
    1bca:	4798      	blx	r3
    1bcc:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    1bce:	47c0      	blx	r8
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1bd0:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if (uxMessagesWaiting > (UBaseType_t)0) {
    1bd2:	2d00      	cmp	r5, #0
    1bd4:	d1cd      	bne.n	1b72 <xQueueReceive+0x42>
				if (xTicksToWait == (TickType_t)0) {
    1bd6:	9b01      	ldr	r3, [sp, #4]
    1bd8:	2b00      	cmp	r3, #0
    1bda:	d0e2      	beq.n	1ba2 <xQueueReceive+0x72>
				} else if (xEntryTimeSet == pdFALSE) {
    1bdc:	2e00      	cmp	r6, #0
    1bde:	d0e4      	beq.n	1baa <xQueueReceive+0x7a>
		taskEXIT_CRITICAL();
    1be0:	4b20      	ldr	r3, [pc, #128]	; (1c64 <xQueueReceive+0x134>)
    1be2:	4798      	blx	r3
		vTaskSuspendAll();
    1be4:	4b23      	ldr	r3, [pc, #140]	; (1c74 <xQueueReceive+0x144>)
    1be6:	4798      	blx	r3
		prvLockQueue(pxQueue);
    1be8:	4b1a      	ldr	r3, [pc, #104]	; (1c54 <xQueueReceive+0x124>)
    1bea:	4798      	blx	r3
    1bec:	2344      	movs	r3, #68	; 0x44
    1bee:	5ce3      	ldrb	r3, [r4, r3]
    1bf0:	b25b      	sxtb	r3, r3
    1bf2:	3301      	adds	r3, #1
    1bf4:	d0dd      	beq.n	1bb2 <xQueueReceive+0x82>
    1bf6:	2345      	movs	r3, #69	; 0x45
    1bf8:	5ce3      	ldrb	r3, [r4, r3]
    1bfa:	b25b      	sxtb	r3, r3
    1bfc:	3301      	adds	r3, #1
    1bfe:	d0dc      	beq.n	1bba <xQueueReceive+0x8a>
    1c00:	4b18      	ldr	r3, [pc, #96]	; (1c64 <xQueueReceive+0x134>)
    1c02:	4798      	blx	r3
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    1c04:	a901      	add	r1, sp, #4
    1c06:	a802      	add	r0, sp, #8
    1c08:	4b1b      	ldr	r3, [pc, #108]	; (1c78 <xQueueReceive+0x148>)
    1c0a:	4798      	blx	r3
    1c0c:	2800      	cmp	r0, #0
    1c0e:	d113      	bne.n	1c38 <xQueueReceive+0x108>
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    1c10:	0020      	movs	r0, r4
    1c12:	4b1a      	ldr	r3, [pc, #104]	; (1c7c <xQueueReceive+0x14c>)
    1c14:	4798      	blx	r3
    1c16:	2800      	cmp	r0, #0
    1c18:	d0d3      	beq.n	1bc2 <xQueueReceive+0x92>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
    1c1a:	0020      	movs	r0, r4
    1c1c:	3024      	adds	r0, #36	; 0x24
    1c1e:	9901      	ldr	r1, [sp, #4]
    1c20:	4b17      	ldr	r3, [pc, #92]	; (1c80 <xQueueReceive+0x150>)
    1c22:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    1c24:	0020      	movs	r0, r4
    1c26:	4b11      	ldr	r3, [pc, #68]	; (1c6c <xQueueReceive+0x13c>)
    1c28:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    1c2a:	4b11      	ldr	r3, [pc, #68]	; (1c70 <xQueueReceive+0x140>)
    1c2c:	4798      	blx	r3
    1c2e:	2800      	cmp	r0, #0
    1c30:	d1cc      	bne.n	1bcc <xQueueReceive+0x9c>
					portYIELD_WITHIN_API();
    1c32:	4b0b      	ldr	r3, [pc, #44]	; (1c60 <xQueueReceive+0x130>)
    1c34:	4798      	blx	r3
    1c36:	e7c9      	b.n	1bcc <xQueueReceive+0x9c>
			prvUnlockQueue(pxQueue);
    1c38:	0020      	movs	r0, r4
    1c3a:	4b0c      	ldr	r3, [pc, #48]	; (1c6c <xQueueReceive+0x13c>)
    1c3c:	4798      	blx	r3
			(void)xTaskResumeAll();
    1c3e:	4b0c      	ldr	r3, [pc, #48]	; (1c70 <xQueueReceive+0x140>)
    1c40:	4798      	blx	r3
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    1c42:	0020      	movs	r0, r4
    1c44:	4b0d      	ldr	r3, [pc, #52]	; (1c7c <xQueueReceive+0x14c>)
    1c46:	4798      	blx	r3
    1c48:	2800      	cmp	r0, #0
    1c4a:	d0bf      	beq.n	1bcc <xQueueReceive+0x9c>
				return errQUEUE_EMPTY;
    1c4c:	2000      	movs	r0, #0
    1c4e:	e7a4      	b.n	1b9a <xQueueReceive+0x6a>
    1c50:	000025ad 	.word	0x000025ad
    1c54:	000014d5 	.word	0x000014d5
    1c58:	00001709 	.word	0x00001709
    1c5c:	000024a9 	.word	0x000024a9
    1c60:	000014bd 	.word	0x000014bd
    1c64:	000014ed 	.word	0x000014ed
    1c68:	00002525 	.word	0x00002525
    1c6c:	00001731 	.word	0x00001731
    1c70:	00002289 	.word	0x00002289
    1c74:	00002161 	.word	0x00002161
    1c78:	00002535 	.word	0x00002535
    1c7c:	00001609 	.word	0x00001609
    1c80:	00002445 	.word	0x00002445

00001c84 <xQueueSemaphoreTake>:
{
    1c84:	b5f0      	push	{r4, r5, r6, r7, lr}
    1c86:	b085      	sub	sp, #20
    1c88:	1e04      	subs	r4, r0, #0
    1c8a:	9101      	str	r1, [sp, #4]
	configASSERT((pxQueue));
    1c8c:	d004      	beq.n	1c98 <xQueueSemaphoreTake+0x14>
	configASSERT(pxQueue->uxItemSize == 0);
    1c8e:	6c03      	ldr	r3, [r0, #64]	; 0x40
    1c90:	2b00      	cmp	r3, #0
    1c92:	d003      	beq.n	1c9c <xQueueSemaphoreTake+0x18>
    1c94:	b672      	cpsid	i
    1c96:	e7fe      	b.n	1c96 <xQueueSemaphoreTake+0x12>
	configASSERT((pxQueue));
    1c98:	b672      	cpsid	i
    1c9a:	e7fe      	b.n	1c9a <xQueueSemaphoreTake+0x16>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    1c9c:	4b50      	ldr	r3, [pc, #320]	; (1de0 <xQueueSemaphoreTake+0x15c>)
    1c9e:	4798      	blx	r3
    1ca0:	2800      	cmp	r0, #0
    1ca2:	d104      	bne.n	1cae <xQueueSemaphoreTake+0x2a>
    1ca4:	9b01      	ldr	r3, [sp, #4]
    1ca6:	2b00      	cmp	r3, #0
    1ca8:	d005      	beq.n	1cb6 <xQueueSemaphoreTake+0x32>
    1caa:	b672      	cpsid	i
    1cac:	e7fe      	b.n	1cac <xQueueSemaphoreTake+0x28>
    1cae:	2500      	movs	r5, #0
    1cb0:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
    1cb2:	4f4c      	ldr	r7, [pc, #304]	; (1de4 <xQueueSemaphoreTake+0x160>)
    1cb4:	e048      	b.n	1d48 <xQueueSemaphoreTake+0xc4>
    1cb6:	2500      	movs	r5, #0
    1cb8:	2600      	movs	r6, #0
    1cba:	e7fa      	b.n	1cb2 <xQueueSemaphoreTake+0x2e>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - (UBaseType_t)1;
    1cbc:	3b01      	subs	r3, #1
    1cbe:	63a3      	str	r3, [r4, #56]	; 0x38
					if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
    1cc0:	6823      	ldr	r3, [r4, #0]
    1cc2:	2b00      	cmp	r3, #0
    1cc4:	d102      	bne.n	1ccc <xQueueSemaphoreTake+0x48>
						    = (int8_t *)pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as
    1cc6:	4b48      	ldr	r3, [pc, #288]	; (1de8 <xQueueSemaphoreTake+0x164>)
    1cc8:	4798      	blx	r3
    1cca:	6060      	str	r0, [r4, #4]
				if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    1ccc:	6923      	ldr	r3, [r4, #16]
    1cce:	2b00      	cmp	r3, #0
    1cd0:	d007      	beq.n	1ce2 <xQueueSemaphoreTake+0x5e>
					if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    1cd2:	0020      	movs	r0, r4
    1cd4:	3010      	adds	r0, #16
    1cd6:	4b45      	ldr	r3, [pc, #276]	; (1dec <xQueueSemaphoreTake+0x168>)
    1cd8:	4798      	blx	r3
    1cda:	2800      	cmp	r0, #0
    1cdc:	d001      	beq.n	1ce2 <xQueueSemaphoreTake+0x5e>
						queueYIELD_IF_USING_PREEMPTION();
    1cde:	4b44      	ldr	r3, [pc, #272]	; (1df0 <xQueueSemaphoreTake+0x16c>)
    1ce0:	4798      	blx	r3
				taskEXIT_CRITICAL();
    1ce2:	4b44      	ldr	r3, [pc, #272]	; (1df4 <xQueueSemaphoreTake+0x170>)
    1ce4:	4798      	blx	r3
				return pdPASS;
    1ce6:	2501      	movs	r5, #1
}
    1ce8:	0028      	movs	r0, r5
    1cea:	b005      	add	sp, #20
    1cec:	bdf0      	pop	{r4, r5, r6, r7, pc}
						configASSERT(xInheritanceOccurred == pdFALSE);
    1cee:	2d00      	cmp	r5, #0
    1cf0:	d001      	beq.n	1cf6 <xQueueSemaphoreTake+0x72>
    1cf2:	b672      	cpsid	i
    1cf4:	e7fe      	b.n	1cf4 <xQueueSemaphoreTake+0x70>
					taskEXIT_CRITICAL();
    1cf6:	4b3f      	ldr	r3, [pc, #252]	; (1df4 <xQueueSemaphoreTake+0x170>)
    1cf8:	4798      	blx	r3
					return errQUEUE_EMPTY;
    1cfa:	e7f5      	b.n	1ce8 <xQueueSemaphoreTake+0x64>
					vTaskInternalSetTimeOutState(&xTimeOut);
    1cfc:	a802      	add	r0, sp, #8
    1cfe:	4b3e      	ldr	r3, [pc, #248]	; (1df8 <xQueueSemaphoreTake+0x174>)
    1d00:	4798      	blx	r3
    1d02:	e02a      	b.n	1d5a <xQueueSemaphoreTake+0xd6>
		prvLockQueue(pxQueue);
    1d04:	2200      	movs	r2, #0
    1d06:	2344      	movs	r3, #68	; 0x44
    1d08:	54e2      	strb	r2, [r4, r3]
    1d0a:	e031      	b.n	1d70 <xQueueSemaphoreTake+0xec>
    1d0c:	2200      	movs	r2, #0
    1d0e:	2345      	movs	r3, #69	; 0x45
    1d10:	54e2      	strb	r2, [r4, r3]
    1d12:	e032      	b.n	1d7a <xQueueSemaphoreTake+0xf6>
						taskENTER_CRITICAL();
    1d14:	4b33      	ldr	r3, [pc, #204]	; (1de4 <xQueueSemaphoreTake+0x160>)
    1d16:	4798      	blx	r3
							xInheritanceOccurred = xTaskPriorityInherit((void *)pxQueue->pxMutexHolder);
    1d18:	6860      	ldr	r0, [r4, #4]
    1d1a:	4b38      	ldr	r3, [pc, #224]	; (1dfc <xQueueSemaphoreTake+0x178>)
    1d1c:	4798      	blx	r3
    1d1e:	0005      	movs	r5, r0
						taskEXIT_CRITICAL();
    1d20:	4b34      	ldr	r3, [pc, #208]	; (1df4 <xQueueSemaphoreTake+0x170>)
    1d22:	4798      	blx	r3
    1d24:	e039      	b.n	1d9a <xQueueSemaphoreTake+0x116>
				prvUnlockQueue(pxQueue);
    1d26:	0020      	movs	r0, r4
    1d28:	4b35      	ldr	r3, [pc, #212]	; (1e00 <xQueueSemaphoreTake+0x17c>)
    1d2a:	4798      	blx	r3
				(void)xTaskResumeAll();
    1d2c:	4b35      	ldr	r3, [pc, #212]	; (1e04 <xQueueSemaphoreTake+0x180>)
    1d2e:	4798      	blx	r3
    1d30:	e009      	b.n	1d46 <xQueueSemaphoreTake+0xc2>
			prvUnlockQueue(pxQueue);
    1d32:	0020      	movs	r0, r4
    1d34:	4b32      	ldr	r3, [pc, #200]	; (1e00 <xQueueSemaphoreTake+0x17c>)
    1d36:	4798      	blx	r3
			(void)xTaskResumeAll();
    1d38:	4b32      	ldr	r3, [pc, #200]	; (1e04 <xQueueSemaphoreTake+0x180>)
    1d3a:	4798      	blx	r3
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    1d3c:	0020      	movs	r0, r4
    1d3e:	4b32      	ldr	r3, [pc, #200]	; (1e08 <xQueueSemaphoreTake+0x184>)
    1d40:	4798      	blx	r3
    1d42:	2800      	cmp	r0, #0
    1d44:	d138      	bne.n	1db8 <xQueueSemaphoreTake+0x134>
    1d46:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    1d48:	47b8      	blx	r7
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1d4a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if (uxSemaphoreCount > (UBaseType_t)0) {
    1d4c:	2b00      	cmp	r3, #0
    1d4e:	d1b5      	bne.n	1cbc <xQueueSemaphoreTake+0x38>
				if (xTicksToWait == (TickType_t)0) {
    1d50:	9b01      	ldr	r3, [sp, #4]
    1d52:	2b00      	cmp	r3, #0
    1d54:	d0cb      	beq.n	1cee <xQueueSemaphoreTake+0x6a>
				} else if (xEntryTimeSet == pdFALSE) {
    1d56:	2e00      	cmp	r6, #0
    1d58:	d0d0      	beq.n	1cfc <xQueueSemaphoreTake+0x78>
		taskEXIT_CRITICAL();
    1d5a:	4b26      	ldr	r3, [pc, #152]	; (1df4 <xQueueSemaphoreTake+0x170>)
    1d5c:	4798      	blx	r3
		vTaskSuspendAll();
    1d5e:	4b2b      	ldr	r3, [pc, #172]	; (1e0c <xQueueSemaphoreTake+0x188>)
    1d60:	4798      	blx	r3
		prvLockQueue(pxQueue);
    1d62:	4b20      	ldr	r3, [pc, #128]	; (1de4 <xQueueSemaphoreTake+0x160>)
    1d64:	4798      	blx	r3
    1d66:	2344      	movs	r3, #68	; 0x44
    1d68:	5ce3      	ldrb	r3, [r4, r3]
    1d6a:	b25b      	sxtb	r3, r3
    1d6c:	3301      	adds	r3, #1
    1d6e:	d0c9      	beq.n	1d04 <xQueueSemaphoreTake+0x80>
    1d70:	2345      	movs	r3, #69	; 0x45
    1d72:	5ce3      	ldrb	r3, [r4, r3]
    1d74:	b25b      	sxtb	r3, r3
    1d76:	3301      	adds	r3, #1
    1d78:	d0c8      	beq.n	1d0c <xQueueSemaphoreTake+0x88>
    1d7a:	4b1e      	ldr	r3, [pc, #120]	; (1df4 <xQueueSemaphoreTake+0x170>)
    1d7c:	4798      	blx	r3
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    1d7e:	a901      	add	r1, sp, #4
    1d80:	a802      	add	r0, sp, #8
    1d82:	4b23      	ldr	r3, [pc, #140]	; (1e10 <xQueueSemaphoreTake+0x18c>)
    1d84:	4798      	blx	r3
    1d86:	2800      	cmp	r0, #0
    1d88:	d1d3      	bne.n	1d32 <xQueueSemaphoreTake+0xae>
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    1d8a:	0020      	movs	r0, r4
    1d8c:	4b1e      	ldr	r3, [pc, #120]	; (1e08 <xQueueSemaphoreTake+0x184>)
    1d8e:	4798      	blx	r3
    1d90:	2800      	cmp	r0, #0
    1d92:	d0c8      	beq.n	1d26 <xQueueSemaphoreTake+0xa2>
					if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
    1d94:	6823      	ldr	r3, [r4, #0]
    1d96:	2b00      	cmp	r3, #0
    1d98:	d0bc      	beq.n	1d14 <xQueueSemaphoreTake+0x90>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
    1d9a:	0020      	movs	r0, r4
    1d9c:	3024      	adds	r0, #36	; 0x24
    1d9e:	9901      	ldr	r1, [sp, #4]
    1da0:	4b1c      	ldr	r3, [pc, #112]	; (1e14 <xQueueSemaphoreTake+0x190>)
    1da2:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    1da4:	0020      	movs	r0, r4
    1da6:	4b16      	ldr	r3, [pc, #88]	; (1e00 <xQueueSemaphoreTake+0x17c>)
    1da8:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    1daa:	4b16      	ldr	r3, [pc, #88]	; (1e04 <xQueueSemaphoreTake+0x180>)
    1dac:	4798      	blx	r3
    1dae:	2800      	cmp	r0, #0
    1db0:	d1c9      	bne.n	1d46 <xQueueSemaphoreTake+0xc2>
					portYIELD_WITHIN_API();
    1db2:	4b0f      	ldr	r3, [pc, #60]	; (1df0 <xQueueSemaphoreTake+0x16c>)
    1db4:	4798      	blx	r3
    1db6:	e7c6      	b.n	1d46 <xQueueSemaphoreTake+0xc2>
					if (xInheritanceOccurred != pdFALSE) {
    1db8:	2d00      	cmp	r5, #0
    1dba:	d100      	bne.n	1dbe <xQueueSemaphoreTake+0x13a>
    1dbc:	e794      	b.n	1ce8 <xQueueSemaphoreTake+0x64>
						taskENTER_CRITICAL();
    1dbe:	4b09      	ldr	r3, [pc, #36]	; (1de4 <xQueueSemaphoreTake+0x160>)
    1dc0:	4798      	blx	r3
	if (listCURRENT_LIST_LENGTH(&(pxQueue->xTasksWaitingToReceive)) > 0) {
    1dc2:	6a63      	ldr	r3, [r4, #36]	; 0x24
		uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    1dc4:	2100      	movs	r1, #0
	if (listCURRENT_LIST_LENGTH(&(pxQueue->xTasksWaitingToReceive)) > 0) {
    1dc6:	2b00      	cmp	r3, #0
    1dc8:	d003      	beq.n	1dd2 <xQueueSemaphoreTake+0x14e>
		    = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY(&(pxQueue->xTasksWaitingToReceive));
    1dca:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1dcc:	681b      	ldr	r3, [r3, #0]
    1dce:	3105      	adds	r1, #5
    1dd0:	1ac9      	subs	r1, r1, r3
							vTaskPriorityDisinheritAfterTimeout((void *)pxQueue->pxMutexHolder,
    1dd2:	6860      	ldr	r0, [r4, #4]
    1dd4:	4b10      	ldr	r3, [pc, #64]	; (1e18 <xQueueSemaphoreTake+0x194>)
    1dd6:	4798      	blx	r3
						taskEXIT_CRITICAL();
    1dd8:	4b06      	ldr	r3, [pc, #24]	; (1df4 <xQueueSemaphoreTake+0x170>)
    1dda:	4798      	blx	r3
				return errQUEUE_EMPTY;
    1ddc:	2500      	movs	r5, #0
    1dde:	e783      	b.n	1ce8 <xQueueSemaphoreTake+0x64>
    1de0:	000025ad 	.word	0x000025ad
    1de4:	000014d5 	.word	0x000014d5
    1de8:	00002769 	.word	0x00002769
    1dec:	000024a9 	.word	0x000024a9
    1df0:	000014bd 	.word	0x000014bd
    1df4:	000014ed 	.word	0x000014ed
    1df8:	00002525 	.word	0x00002525
    1dfc:	000025c9 	.word	0x000025c9
    1e00:	00001731 	.word	0x00001731
    1e04:	00002289 	.word	0x00002289
    1e08:	00001609 	.word	0x00001609
    1e0c:	00002161 	.word	0x00002161
    1e10:	00002535 	.word	0x00002535
    1e14:	00002445 	.word	0x00002445
    1e18:	000026dd 	.word	0x000026dd

00001e1c <vQueueWaitForMessageRestricted>:
{
    1e1c:	b570      	push	{r4, r5, r6, lr}
    1e1e:	0004      	movs	r4, r0
    1e20:	000d      	movs	r5, r1
    1e22:	0016      	movs	r6, r2
	prvLockQueue(pxQueue);
    1e24:	4b11      	ldr	r3, [pc, #68]	; (1e6c <vQueueWaitForMessageRestricted+0x50>)
    1e26:	4798      	blx	r3
    1e28:	2344      	movs	r3, #68	; 0x44
    1e2a:	5ce3      	ldrb	r3, [r4, r3]
    1e2c:	b25b      	sxtb	r3, r3
    1e2e:	3301      	adds	r3, #1
    1e30:	d00d      	beq.n	1e4e <vQueueWaitForMessageRestricted+0x32>
    1e32:	2345      	movs	r3, #69	; 0x45
    1e34:	5ce3      	ldrb	r3, [r4, r3]
    1e36:	b25b      	sxtb	r3, r3
    1e38:	3301      	adds	r3, #1
    1e3a:	d00c      	beq.n	1e56 <vQueueWaitForMessageRestricted+0x3a>
    1e3c:	4b0c      	ldr	r3, [pc, #48]	; (1e70 <vQueueWaitForMessageRestricted+0x54>)
    1e3e:	4798      	blx	r3
	if (pxQueue->uxMessagesWaiting == (UBaseType_t)0U) {
    1e40:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    1e42:	2b00      	cmp	r3, #0
    1e44:	d00b      	beq.n	1e5e <vQueueWaitForMessageRestricted+0x42>
	prvUnlockQueue(pxQueue);
    1e46:	0020      	movs	r0, r4
    1e48:	4b0a      	ldr	r3, [pc, #40]	; (1e74 <vQueueWaitForMessageRestricted+0x58>)
    1e4a:	4798      	blx	r3
}
    1e4c:	bd70      	pop	{r4, r5, r6, pc}
	prvLockQueue(pxQueue);
    1e4e:	2200      	movs	r2, #0
    1e50:	2344      	movs	r3, #68	; 0x44
    1e52:	54e2      	strb	r2, [r4, r3]
    1e54:	e7ed      	b.n	1e32 <vQueueWaitForMessageRestricted+0x16>
    1e56:	2200      	movs	r2, #0
    1e58:	2345      	movs	r3, #69	; 0x45
    1e5a:	54e2      	strb	r2, [r4, r3]
    1e5c:	e7ee      	b.n	1e3c <vQueueWaitForMessageRestricted+0x20>
		vTaskPlaceOnEventListRestricted(&(pxQueue->xTasksWaitingToReceive), xTicksToWait, xWaitIndefinitely);
    1e5e:	0020      	movs	r0, r4
    1e60:	3024      	adds	r0, #36	; 0x24
    1e62:	0032      	movs	r2, r6
    1e64:	0029      	movs	r1, r5
    1e66:	4b04      	ldr	r3, [pc, #16]	; (1e78 <vQueueWaitForMessageRestricted+0x5c>)
    1e68:	4798      	blx	r3
    1e6a:	e7ec      	b.n	1e46 <vQueueWaitForMessageRestricted+0x2a>
    1e6c:	000014d5 	.word	0x000014d5
    1e70:	000014ed 	.word	0x000014ed
    1e74:	00001731 	.word	0x00001731
    1e78:	00002471 	.word	0x00002471

00001e7c <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime(void)
{
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    1e7c:	4b08      	ldr	r3, [pc, #32]	; (1ea0 <prvResetNextTaskUnblockTime+0x24>)
    1e7e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1e80:	681b      	ldr	r3, [r3, #0]
    1e82:	2b00      	cmp	r3, #0
    1e84:	d006      	beq.n	1e94 <prvResetNextTaskUnblockTime+0x18>
	} else {
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    1e86:	4b06      	ldr	r3, [pc, #24]	; (1ea0 <prvResetNextTaskUnblockTime+0x24>)
    1e88:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    1e8a:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
    1e8c:	68d2      	ldr	r2, [r2, #12]
    1e8e:	6852      	ldr	r2, [r2, #4]
    1e90:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
    1e92:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
    1e94:	2201      	movs	r2, #1
    1e96:	4252      	negs	r2, r2
    1e98:	4b01      	ldr	r3, [pc, #4]	; (1ea0 <prvResetNextTaskUnblockTime+0x24>)
    1e9a:	62da      	str	r2, [r3, #44]	; 0x2c
    1e9c:	e7f9      	b.n	1e92 <prvResetNextTaskUnblockTime+0x16>
    1e9e:	46c0      	nop			; (mov r8, r8)
    1ea0:	200009d8 	.word	0x200009d8

00001ea4 <prvIdleTask>:
{
    1ea4:	b570      	push	{r4, r5, r6, lr}
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
    1ea6:	4c03      	ldr	r4, [pc, #12]	; (1eb4 <prvIdleTask+0x10>)
				taskYIELD();
    1ea8:	4d03      	ldr	r5, [pc, #12]	; (1eb8 <prvIdleTask+0x14>)
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
    1eaa:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1eac:	2b01      	cmp	r3, #1
    1eae:	d9fc      	bls.n	1eaa <prvIdleTask+0x6>
				taskYIELD();
    1eb0:	47a8      	blx	r5
    1eb2:	e7fa      	b.n	1eaa <prvIdleTask+0x6>
    1eb4:	200009d8 	.word	0x200009d8
    1eb8:	000014bd 	.word	0x000014bd

00001ebc <prvAddCurrentTaskToDelayedList>:

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely)
{
    1ebc:	b570      	push	{r4, r5, r6, lr}
    1ebe:	0004      	movs	r4, r0
    1ec0:	000d      	movs	r5, r1
	TickType_t       xTimeToWake;
	const TickType_t xConstTickCount = xTickCount;
    1ec2:	4b15      	ldr	r3, [pc, #84]	; (1f18 <prvAddCurrentTaskToDelayedList+0x5c>)
    1ec4:	695e      	ldr	r6, [r3, #20]
	}
#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
    1ec6:	6998      	ldr	r0, [r3, #24]
    1ec8:	3004      	adds	r0, #4
    1eca:	4b14      	ldr	r3, [pc, #80]	; (1f1c <prvAddCurrentTaskToDelayedList+0x60>)
    1ecc:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

#if (INCLUDE_vTaskSuspend == 1)
	{
		if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
    1ece:	1c63      	adds	r3, r4, #1
    1ed0:	d012      	beq.n	1ef8 <prvAddCurrentTaskToDelayedList+0x3c>
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
		} else {
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    1ed2:	1934      	adds	r4, r6, r4

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
    1ed4:	4b10      	ldr	r3, [pc, #64]	; (1f18 <prvAddCurrentTaskToDelayedList+0x5c>)
    1ed6:	699b      	ldr	r3, [r3, #24]
    1ed8:	605c      	str	r4, [r3, #4]

			if (xTimeToWake < xConstTickCount) {
    1eda:	42a6      	cmp	r6, r4
    1edc:	d815      	bhi.n	1f0a <prvAddCurrentTaskToDelayedList+0x4e>
				list. */
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
			} else {
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
    1ede:	4d10      	ldr	r5, [pc, #64]	; (1f20 <prvAddCurrentTaskToDelayedList+0x64>)
    1ee0:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    1ee2:	4b0d      	ldr	r3, [pc, #52]	; (1f18 <prvAddCurrentTaskToDelayedList+0x5c>)
    1ee4:	6999      	ldr	r1, [r3, #24]
    1ee6:	3104      	adds	r1, #4
    1ee8:	4b0e      	ldr	r3, [pc, #56]	; (1f24 <prvAddCurrentTaskToDelayedList+0x68>)
    1eea:	4798      	blx	r3

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if (xTimeToWake < xNextTaskUnblockTime) {
    1eec:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    1eee:	429c      	cmp	r4, r3
    1ef0:	d211      	bcs.n	1f16 <prvAddCurrentTaskToDelayedList+0x5a>
					xNextTaskUnblockTime = xTimeToWake;
    1ef2:	4b0b      	ldr	r3, [pc, #44]	; (1f20 <prvAddCurrentTaskToDelayedList+0x64>)
    1ef4:	62dc      	str	r4, [r3, #44]	; 0x2c

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		(void)xCanBlockIndefinitely;
	}
#endif /* INCLUDE_vTaskSuspend */
}
    1ef6:	e00e      	b.n	1f16 <prvAddCurrentTaskToDelayedList+0x5a>
		if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
    1ef8:	2d00      	cmp	r5, #0
    1efa:	d0ea      	beq.n	1ed2 <prvAddCurrentTaskToDelayedList+0x16>
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
    1efc:	4b06      	ldr	r3, [pc, #24]	; (1f18 <prvAddCurrentTaskToDelayedList+0x5c>)
    1efe:	6999      	ldr	r1, [r3, #24]
    1f00:	3104      	adds	r1, #4
    1f02:	4807      	ldr	r0, [pc, #28]	; (1f20 <prvAddCurrentTaskToDelayedList+0x64>)
    1f04:	4b08      	ldr	r3, [pc, #32]	; (1f28 <prvAddCurrentTaskToDelayedList+0x6c>)
    1f06:	4798      	blx	r3
    1f08:	e005      	b.n	1f16 <prvAddCurrentTaskToDelayedList+0x5a>
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
    1f0a:	4b03      	ldr	r3, [pc, #12]	; (1f18 <prvAddCurrentTaskToDelayedList+0x5c>)
    1f0c:	69d8      	ldr	r0, [r3, #28]
    1f0e:	6999      	ldr	r1, [r3, #24]
    1f10:	3104      	adds	r1, #4
    1f12:	4b04      	ldr	r3, [pc, #16]	; (1f24 <prvAddCurrentTaskToDelayedList+0x68>)
    1f14:	4798      	blx	r3
}
    1f16:	bd70      	pop	{r4, r5, r6, pc}
    1f18:	20000a58 	.word	0x20000a58
    1f1c:	000013b3 	.word	0x000013b3
    1f20:	200009d8 	.word	0x200009d8
    1f24:	00001385 	.word	0x00001385
    1f28:	0000136d 	.word	0x0000136d

00001f2c <xTaskCreate>:
{
    1f2c:	b5f0      	push	{r4, r5, r6, r7, lr}
    1f2e:	46d6      	mov	lr, sl
    1f30:	464f      	mov	r7, r9
    1f32:	4646      	mov	r6, r8
    1f34:	b5c0      	push	{r6, r7, lr}
    1f36:	b084      	sub	sp, #16
    1f38:	9001      	str	r0, [sp, #4]
    1f3a:	000d      	movs	r5, r1
    1f3c:	9302      	str	r3, [sp, #8]
		pxStack = (StackType_t *)pvPortMalloc(
    1f3e:	0097      	lsls	r7, r2, #2
    1f40:	0038      	movs	r0, r7
    1f42:	4b61      	ldr	r3, [pc, #388]	; (20c8 <STACK_SIZE+0xc8>)
    1f44:	4798      	blx	r3
    1f46:	1e06      	subs	r6, r0, #0
		if (pxStack != NULL) {
    1f48:	d100      	bne.n	1f4c <xTaskCreate+0x20>
    1f4a:	e089      	b.n	2060 <STACK_SIZE+0x60>
			pxNewTCB = (TCB_t *)pvPortMalloc(
    1f4c:	2054      	movs	r0, #84	; 0x54
    1f4e:	4b5e      	ldr	r3, [pc, #376]	; (20c8 <STACK_SIZE+0xc8>)
    1f50:	4798      	blx	r3
    1f52:	1e04      	subs	r4, r0, #0
			if (pxNewTCB != NULL) {
    1f54:	d100      	bne.n	1f58 <xTaskCreate+0x2c>
    1f56:	e080      	b.n	205a <STACK_SIZE+0x5a>
				pxNewTCB->pxStack = pxStack;
    1f58:	6306      	str	r6, [r0, #48]	; 0x30
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
    1f5a:	003a      	movs	r2, r7
    1f5c:	21a5      	movs	r1, #165	; 0xa5
    1f5e:	0030      	movs	r0, r6
    1f60:	4b5a      	ldr	r3, [pc, #360]	; (20cc <STACK_SIZE+0xcc>)
    1f62:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
    1f64:	1f3a      	subs	r2, r7, #4
    1f66:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1f68:	469c      	mov	ip, r3
    1f6a:	4462      	add	r2, ip
		                      & (~(
    1f6c:	2307      	movs	r3, #7
    1f6e:	439a      	bics	r2, r3
    1f70:	4690      	mov	r8, r2
		pxNewTCB->pcTaskName[x] = pcName[x];
    1f72:	782a      	ldrb	r2, [r5, #0]
    1f74:	332d      	adds	r3, #45	; 0x2d
    1f76:	54e2      	strb	r2, [r4, r3]
		if (pcName[x] == 0x00) {
    1f78:	782b      	ldrb	r3, [r5, #0]
    1f7a:	2b00      	cmp	r3, #0
    1f7c:	d00d      	beq.n	1f9a <xTaskCreate+0x6e>
    1f7e:	3501      	adds	r5, #1
    1f80:	0023      	movs	r3, r4
    1f82:	3335      	adds	r3, #53	; 0x35
    1f84:	0020      	movs	r0, r4
    1f86:	303c      	adds	r0, #60	; 0x3c
		pxNewTCB->pcTaskName[x] = pcName[x];
    1f88:	782a      	ldrb	r2, [r5, #0]
    1f8a:	701a      	strb	r2, [r3, #0]
		if (pcName[x] == 0x00) {
    1f8c:	782a      	ldrb	r2, [r5, #0]
    1f8e:	2a00      	cmp	r2, #0
    1f90:	d003      	beq.n	1f9a <xTaskCreate+0x6e>
    1f92:	3501      	adds	r5, #1
    1f94:	3301      	adds	r3, #1
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
    1f96:	4283      	cmp	r3, r0
    1f98:	d1f6      	bne.n	1f88 <xTaskCreate+0x5c>
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
    1f9a:	2200      	movs	r2, #0
    1f9c:	233b      	movs	r3, #59	; 0x3b
    1f9e:	54e2      	strb	r2, [r4, r3]
    1fa0:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    1fa2:	2f04      	cmp	r7, #4
    1fa4:	d900      	bls.n	1fa8 <xTaskCreate+0x7c>
    1fa6:	2704      	movs	r7, #4
	pxNewTCB->uxPriority = uxPriority;
    1fa8:	62e7      	str	r7, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
    1faa:	6467      	str	r7, [r4, #68]	; 0x44
		pxNewTCB->uxMutexesHeld  = 0;
    1fac:	2600      	movs	r6, #0
    1fae:	64a6      	str	r6, [r4, #72]	; 0x48
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
    1fb0:	1d23      	adds	r3, r4, #4
    1fb2:	9303      	str	r3, [sp, #12]
    1fb4:	0018      	movs	r0, r3
    1fb6:	4d46      	ldr	r5, [pc, #280]	; (20d0 <STACK_SIZE+0xd0>)
    1fb8:	47a8      	blx	r5
	vListInitialiseItem(&(pxNewTCB->xEventListItem));
    1fba:	0020      	movs	r0, r4
    1fbc:	3018      	adds	r0, #24
    1fbe:	47a8      	blx	r5
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
    1fc0:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE(
    1fc2:	2305      	movs	r3, #5
    1fc4:	1bdb      	subs	r3, r3, r7
    1fc6:	61a3      	str	r3, [r4, #24]
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
    1fc8:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
    1fca:	64e6      	str	r6, [r4, #76]	; 0x4c
		pxNewTCB->ucNotifyState   = taskNOT_WAITING_NOTIFICATION;
    1fcc:	2350      	movs	r3, #80	; 0x50
    1fce:	54e6      	strb	r6, [r4, r3]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    1fd0:	9a02      	ldr	r2, [sp, #8]
    1fd2:	9901      	ldr	r1, [sp, #4]
    1fd4:	4640      	mov	r0, r8
    1fd6:	4b3f      	ldr	r3, [pc, #252]	; (20d4 <STACK_SIZE+0xd4>)
    1fd8:	4798      	blx	r3
    1fda:	6020      	str	r0, [r4, #0]
	if ((void *)pxCreatedTask != NULL) {
    1fdc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    1fde:	2b00      	cmp	r3, #0
    1fe0:	d000      	beq.n	1fe4 <xTaskCreate+0xb8>
		*pxCreatedTask = (TaskHandle_t)pxNewTCB;
    1fe2:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
    1fe4:	4b3c      	ldr	r3, [pc, #240]	; (20d8 <STACK_SIZE+0xd8>)
    1fe6:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
    1fe8:	4b3c      	ldr	r3, [pc, #240]	; (20dc <STACK_SIZE+0xdc>)
    1fea:	6a1a      	ldr	r2, [r3, #32]
    1fec:	3201      	adds	r2, #1
    1fee:	621a      	str	r2, [r3, #32]
		if (pxCurrentTCB == NULL) {
    1ff0:	699b      	ldr	r3, [r3, #24]
    1ff2:	2b00      	cmp	r3, #0
    1ff4:	d037      	beq.n	2066 <STACK_SIZE+0x66>
			if (xSchedulerRunning == pdFALSE) {
    1ff6:	4b39      	ldr	r3, [pc, #228]	; (20dc <STACK_SIZE+0xdc>)
    1ff8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    1ffa:	2b00      	cmp	r3, #0
    1ffc:	d107      	bne.n	200e <STACK_SIZE+0xe>
				if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
    1ffe:	4b37      	ldr	r3, [pc, #220]	; (20dc <STACK_SIZE+0xdc>)
    2000:	699b      	ldr	r3, [r3, #24]
    2002:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2004:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    2006:	4293      	cmp	r3, r2
    2008:	d801      	bhi.n	200e <STACK_SIZE+0xe>
					pxCurrentTCB = pxNewTCB;
    200a:	4b34      	ldr	r3, [pc, #208]	; (20dc <STACK_SIZE+0xdc>)
    200c:	619c      	str	r4, [r3, #24]
		uxTaskNumber++;
    200e:	4933      	ldr	r1, [pc, #204]	; (20dc <STACK_SIZE+0xdc>)
    2010:	6d0b      	ldr	r3, [r1, #80]	; 0x50
    2012:	3301      	adds	r3, #1
    2014:	650b      	str	r3, [r1, #80]	; 0x50
			pxNewTCB->uxTCBNumber = uxTaskNumber;
    2016:	63e3      	str	r3, [r4, #60]	; 0x3c
		prvAddTaskToReadyList(pxNewTCB);
    2018:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    201a:	6d4b      	ldr	r3, [r1, #84]	; 0x54
    201c:	429a      	cmp	r2, r3
    201e:	d900      	bls.n	2022 <STACK_SIZE+0x22>
    2020:	654a      	str	r2, [r1, #84]	; 0x54
    2022:	0090      	lsls	r0, r2, #2
    2024:	1882      	adds	r2, r0, r2
    2026:	0092      	lsls	r2, r2, #2
    2028:	482d      	ldr	r0, [pc, #180]	; (20e0 <STACK_SIZE+0xe0>)
    202a:	3030      	adds	r0, #48	; 0x30
    202c:	1880      	adds	r0, r0, r2
    202e:	9903      	ldr	r1, [sp, #12]
    2030:	4b2c      	ldr	r3, [pc, #176]	; (20e4 <STACK_SIZE+0xe4>)
    2032:	4798      	blx	r3
	taskEXIT_CRITICAL();
    2034:	4b2c      	ldr	r3, [pc, #176]	; (20e8 <STACK_SIZE+0xe8>)
    2036:	4798      	blx	r3
	if (xSchedulerRunning != pdFALSE) {
    2038:	4b28      	ldr	r3, [pc, #160]	; (20dc <STACK_SIZE+0xdc>)
    203a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
		xReturn = pdPASS;
    203c:	2001      	movs	r0, #1
	if (xSchedulerRunning != pdFALSE) {
    203e:	2b00      	cmp	r3, #0
    2040:	d005      	beq.n	204e <STACK_SIZE+0x4e>
		if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
    2042:	4b26      	ldr	r3, [pc, #152]	; (20dc <STACK_SIZE+0xdc>)
    2044:	699b      	ldr	r3, [r3, #24]
    2046:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2048:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    204a:	429a      	cmp	r2, r3
    204c:	d338      	bcc.n	20c0 <STACK_SIZE+0xc0>
}
    204e:	b004      	add	sp, #16
    2050:	bc1c      	pop	{r2, r3, r4}
    2052:	4690      	mov	r8, r2
    2054:	4699      	mov	r9, r3
    2056:	46a2      	mov	sl, r4
    2058:	bdf0      	pop	{r4, r5, r6, r7, pc}
				vPortFree(pxStack);
    205a:	0030      	movs	r0, r6
    205c:	4b23      	ldr	r3, [pc, #140]	; (20ec <STACK_SIZE+0xec>)
    205e:	4798      	blx	r3
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2060:	2001      	movs	r0, #1
    2062:	4240      	negs	r0, r0
    2064:	e7f3      	b.n	204e <STACK_SIZE+0x4e>
			pxCurrentTCB = pxNewTCB;
    2066:	4b1d      	ldr	r3, [pc, #116]	; (20dc <STACK_SIZE+0xdc>)
    2068:	619c      	str	r4, [r3, #24]
			if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
    206a:	6a1b      	ldr	r3, [r3, #32]
    206c:	2b01      	cmp	r3, #1
    206e:	d1ce      	bne.n	200e <STACK_SIZE+0xe>
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
    2070:	4f1b      	ldr	r7, [pc, #108]	; (20e0 <STACK_SIZE+0xe0>)
    2072:	0038      	movs	r0, r7
    2074:	3030      	adds	r0, #48	; 0x30
    2076:	4e1e      	ldr	r6, [pc, #120]	; (20f0 <STACK_SIZE+0xf0>)
    2078:	47b0      	blx	r6
    207a:	0038      	movs	r0, r7
    207c:	3044      	adds	r0, #68	; 0x44
    207e:	47b0      	blx	r6
    2080:	0038      	movs	r0, r7
    2082:	3058      	adds	r0, #88	; 0x58
    2084:	47b0      	blx	r6
    2086:	0038      	movs	r0, r7
    2088:	306c      	adds	r0, #108	; 0x6c
    208a:	47b0      	blx	r6
    208c:	0038      	movs	r0, r7
    208e:	3080      	adds	r0, #128	; 0x80
    2090:	47b0      	blx	r6
	vListInitialise(&xDelayedTaskList1);
    2092:	4b12      	ldr	r3, [pc, #72]	; (20dc <STACK_SIZE+0xdc>)
    2094:	4698      	mov	r8, r3
    2096:	2324      	movs	r3, #36	; 0x24
    2098:	4443      	add	r3, r8
    209a:	469a      	mov	sl, r3
    209c:	0018      	movs	r0, r3
    209e:	47b0      	blx	r6
	vListInitialise(&xDelayedTaskList2);
    20a0:	2338      	movs	r3, #56	; 0x38
    20a2:	4443      	add	r3, r8
    20a4:	4699      	mov	r9, r3
    20a6:	0018      	movs	r0, r3
    20a8:	47b0      	blx	r6
	vListInitialise(&xPendingReadyList);
    20aa:	0038      	movs	r0, r7
    20ac:	3014      	adds	r0, #20
    20ae:	47b0      	blx	r6
		vListInitialise(&xSuspendedTaskList);
    20b0:	0038      	movs	r0, r7
    20b2:	47b0      	blx	r6
	pxDelayedTaskList         = &xDelayedTaskList1;
    20b4:	4653      	mov	r3, sl
    20b6:	62bb      	str	r3, [r7, #40]	; 0x28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    20b8:	4643      	mov	r3, r8
    20ba:	464a      	mov	r2, r9
    20bc:	61da      	str	r2, [r3, #28]
    20be:	e7a6      	b.n	200e <STACK_SIZE+0xe>
			taskYIELD_IF_USING_PREEMPTION();
    20c0:	4b0c      	ldr	r3, [pc, #48]	; (20f4 <STACK_SIZE+0xf4>)
    20c2:	4798      	blx	r3
		xReturn = pdPASS;
    20c4:	2001      	movs	r0, #1
    20c6:	e7c2      	b.n	204e <STACK_SIZE+0x4e>
    20c8:	00001595 	.word	0x00001595
    20cc:	00002b57 	.word	0x00002b57
    20d0:	00001367 	.word	0x00001367
    20d4:	00001435 	.word	0x00001435
    20d8:	000014d5 	.word	0x000014d5
    20dc:	20000a58 	.word	0x20000a58
    20e0:	200009d8 	.word	0x200009d8
    20e4:	0000136d 	.word	0x0000136d
    20e8:	000014ed 	.word	0x000014ed
    20ec:	000015fd 	.word	0x000015fd
    20f0:	00001351 	.word	0x00001351
    20f4:	000014bd 	.word	0x000014bd

000020f8 <vTaskStartScheduler>:
{
    20f8:	b510      	push	{r4, lr}
    20fa:	b082      	sub	sp, #8
		xReturn = xTaskCreate(prvIdleTask,
    20fc:	4b11      	ldr	r3, [pc, #68]	; (2144 <vTaskStartScheduler+0x4c>)
    20fe:	335c      	adds	r3, #92	; 0x5c
    2100:	9301      	str	r3, [sp, #4]
    2102:	2300      	movs	r3, #0
    2104:	9300      	str	r3, [sp, #0]
    2106:	2240      	movs	r2, #64	; 0x40
    2108:	490f      	ldr	r1, [pc, #60]	; (2148 <vTaskStartScheduler+0x50>)
    210a:	4810      	ldr	r0, [pc, #64]	; (214c <vTaskStartScheduler+0x54>)
    210c:	4c10      	ldr	r4, [pc, #64]	; (2150 <vTaskStartScheduler+0x58>)
    210e:	47a0      	blx	r4
		if (xReturn == pdPASS) {
    2110:	2801      	cmp	r0, #1
    2112:	d003      	beq.n	211c <vTaskStartScheduler+0x24>
		configASSERT(xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY);
    2114:	1c43      	adds	r3, r0, #1
    2116:	d012      	beq.n	213e <vTaskStartScheduler+0x46>
}
    2118:	b002      	add	sp, #8
    211a:	bd10      	pop	{r4, pc}
			xReturn = xTimerCreateTimerTask();
    211c:	4b0d      	ldr	r3, [pc, #52]	; (2154 <vTaskStartScheduler+0x5c>)
    211e:	4798      	blx	r3
	if (xReturn == pdPASS) {
    2120:	2801      	cmp	r0, #1
    2122:	d1f7      	bne.n	2114 <vTaskStartScheduler+0x1c>
		portDISABLE_INTERRUPTS();
    2124:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
    2126:	2201      	movs	r2, #1
    2128:	4252      	negs	r2, r2
    212a:	4b0b      	ldr	r3, [pc, #44]	; (2158 <vTaskStartScheduler+0x60>)
    212c:	62da      	str	r2, [r3, #44]	; 0x2c
		xSchedulerRunning    = pdTRUE;
    212e:	4b05      	ldr	r3, [pc, #20]	; (2144 <vTaskStartScheduler+0x4c>)
    2130:	3202      	adds	r2, #2
    2132:	64da      	str	r2, [r3, #76]	; 0x4c
		xTickCount           = (TickType_t)0U;
    2134:	2200      	movs	r2, #0
    2136:	615a      	str	r2, [r3, #20]
		if (xPortStartScheduler() != pdFALSE) {
    2138:	4b08      	ldr	r3, [pc, #32]	; (215c <vTaskStartScheduler+0x64>)
    213a:	4798      	blx	r3
    213c:	e7ec      	b.n	2118 <vTaskStartScheduler+0x20>
		configASSERT(xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY);
    213e:	b672      	cpsid	i
    2140:	e7fe      	b.n	2140 <vTaskStartScheduler+0x48>
    2142:	46c0      	nop			; (mov r8, r8)
    2144:	20000a58 	.word	0x20000a58
    2148:	00002c3c 	.word	0x00002c3c
    214c:	00001ea5 	.word	0x00001ea5
    2150:	00001f2d 	.word	0x00001f2d
    2154:	00002819 	.word	0x00002819
    2158:	200009d8 	.word	0x200009d8
    215c:	00001459 	.word	0x00001459

00002160 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    2160:	4a02      	ldr	r2, [pc, #8]	; (216c <vTaskSuspendAll+0xc>)
    2162:	6d93      	ldr	r3, [r2, #88]	; 0x58
    2164:	3301      	adds	r3, #1
    2166:	6593      	str	r3, [r2, #88]	; 0x58
}
    2168:	4770      	bx	lr
    216a:	46c0      	nop			; (mov r8, r8)
    216c:	20000a58 	.word	0x20000a58

00002170 <xTaskGetTickCount>:
		xTicks = xTickCount;
    2170:	4b01      	ldr	r3, [pc, #4]	; (2178 <xTaskGetTickCount+0x8>)
    2172:	6958      	ldr	r0, [r3, #20]
}
    2174:	4770      	bx	lr
    2176:	46c0      	nop			; (mov r8, r8)
    2178:	20000a58 	.word	0x20000a58

0000217c <xTaskIncrementTick>:
{
    217c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    217e:	46ce      	mov	lr, r9
    2180:	4647      	mov	r7, r8
    2182:	b580      	push	{r7, lr}
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    2184:	4b3b      	ldr	r3, [pc, #236]	; (2274 <xTaskIncrementTick+0xf8>)
    2186:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    2188:	2b00      	cmp	r3, #0
    218a:	d164      	bne.n	2256 <xTaskIncrementTick+0xda>
		const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
    218c:	4b39      	ldr	r3, [pc, #228]	; (2274 <xTaskIncrementTick+0xf8>)
    218e:	695e      	ldr	r6, [r3, #20]
    2190:	3601      	adds	r6, #1
		xTickCount = xConstTickCount;
    2192:	615e      	str	r6, [r3, #20]
		if (xConstTickCount
    2194:	2e00      	cmp	r6, #0
    2196:	d111      	bne.n	21bc <xTaskIncrementTick+0x40>
			taskSWITCH_DELAYED_LISTS();
    2198:	4b37      	ldr	r3, [pc, #220]	; (2278 <xTaskIncrementTick+0xfc>)
    219a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    219c:	681b      	ldr	r3, [r3, #0]
    219e:	2b00      	cmp	r3, #0
    21a0:	d001      	beq.n	21a6 <xTaskIncrementTick+0x2a>
    21a2:	b672      	cpsid	i
    21a4:	e7fe      	b.n	21a4 <xTaskIncrementTick+0x28>
    21a6:	4a34      	ldr	r2, [pc, #208]	; (2278 <xTaskIncrementTick+0xfc>)
    21a8:	6a91      	ldr	r1, [r2, #40]	; 0x28
    21aa:	4b32      	ldr	r3, [pc, #200]	; (2274 <xTaskIncrementTick+0xf8>)
    21ac:	69d8      	ldr	r0, [r3, #28]
    21ae:	6290      	str	r0, [r2, #40]	; 0x28
    21b0:	61d9      	str	r1, [r3, #28]
    21b2:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    21b4:	3201      	adds	r2, #1
    21b6:	661a      	str	r2, [r3, #96]	; 0x60
    21b8:	4b30      	ldr	r3, [pc, #192]	; (227c <xTaskIncrementTick+0x100>)
    21ba:	4798      	blx	r3
		if (xConstTickCount >= xNextTaskUnblockTime) {
    21bc:	4b2e      	ldr	r3, [pc, #184]	; (2278 <xTaskIncrementTick+0xfc>)
    21be:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	BaseType_t xSwitchRequired = pdFALSE;
    21c0:	2400      	movs	r4, #0
		if (xConstTickCount >= xNextTaskUnblockTime) {
    21c2:	429e      	cmp	r6, r3
    21c4:	d337      	bcc.n	2236 <xTaskIncrementTick+0xba>
    21c6:	2400      	movs	r4, #0
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    21c8:	4b2b      	ldr	r3, [pc, #172]	; (2278 <xTaskIncrementTick+0xfc>)
    21ca:	4699      	mov	r9, r3
					prvAddTaskToReadyList(pxTCB);
    21cc:	2230      	movs	r2, #48	; 0x30
    21ce:	4694      	mov	ip, r2
    21d0:	4463      	add	r3, ip
    21d2:	4698      	mov	r8, r3
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    21d4:	464b      	mov	r3, r9
    21d6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    21d8:	681b      	ldr	r3, [r3, #0]
    21da:	2b00      	cmp	r3, #0
    21dc:	d027      	beq.n	222e <xTaskIncrementTick+0xb2>
					pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    21de:	4b26      	ldr	r3, [pc, #152]	; (2278 <xTaskIncrementTick+0xfc>)
    21e0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    21e2:	68db      	ldr	r3, [r3, #12]
    21e4:	68df      	ldr	r7, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
    21e6:	687b      	ldr	r3, [r7, #4]
					if (xConstTickCount < xItemValue) {
    21e8:	429e      	cmp	r6, r3
    21ea:	d331      	bcc.n	2250 <xTaskIncrementTick+0xd4>
					(void)uxListRemove(&(pxTCB->xStateListItem));
    21ec:	1d3d      	adds	r5, r7, #4
    21ee:	0028      	movs	r0, r5
    21f0:	4b23      	ldr	r3, [pc, #140]	; (2280 <xTaskIncrementTick+0x104>)
    21f2:	4798      	blx	r3
					if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
    21f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    21f6:	2b00      	cmp	r3, #0
    21f8:	d003      	beq.n	2202 <xTaskIncrementTick+0x86>
						(void)uxListRemove(&(pxTCB->xEventListItem));
    21fa:	0038      	movs	r0, r7
    21fc:	3018      	adds	r0, #24
    21fe:	4b20      	ldr	r3, [pc, #128]	; (2280 <xTaskIncrementTick+0x104>)
    2200:	4798      	blx	r3
					prvAddTaskToReadyList(pxTCB);
    2202:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    2204:	4a1b      	ldr	r2, [pc, #108]	; (2274 <xTaskIncrementTick+0xf8>)
    2206:	6d52      	ldr	r2, [r2, #84]	; 0x54
    2208:	4293      	cmp	r3, r2
    220a:	d901      	bls.n	2210 <xTaskIncrementTick+0x94>
    220c:	4a19      	ldr	r2, [pc, #100]	; (2274 <xTaskIncrementTick+0xf8>)
    220e:	6553      	str	r3, [r2, #84]	; 0x54
    2210:	0098      	lsls	r0, r3, #2
    2212:	18c0      	adds	r0, r0, r3
    2214:	0080      	lsls	r0, r0, #2
    2216:	4440      	add	r0, r8
    2218:	0029      	movs	r1, r5
    221a:	4b1a      	ldr	r3, [pc, #104]	; (2284 <xTaskIncrementTick+0x108>)
    221c:	4798      	blx	r3
						if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    221e:	4b15      	ldr	r3, [pc, #84]	; (2274 <xTaskIncrementTick+0xf8>)
    2220:	699b      	ldr	r3, [r3, #24]
    2222:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    2224:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2226:	429a      	cmp	r2, r3
    2228:	d3d4      	bcc.n	21d4 <xTaskIncrementTick+0x58>
							xSwitchRequired = pdTRUE;
    222a:	2401      	movs	r4, #1
    222c:	e7d2      	b.n	21d4 <xTaskIncrementTick+0x58>
					    = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    222e:	2201      	movs	r2, #1
    2230:	4252      	negs	r2, r2
    2232:	4b11      	ldr	r3, [pc, #68]	; (2278 <xTaskIncrementTick+0xfc>)
    2234:	62da      	str	r2, [r3, #44]	; 0x2c
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
    2236:	4b0f      	ldr	r3, [pc, #60]	; (2274 <xTaskIncrementTick+0xf8>)
    2238:	699b      	ldr	r3, [r3, #24]
    223a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    223c:	0093      	lsls	r3, r2, #2
    223e:	189b      	adds	r3, r3, r2
    2240:	009b      	lsls	r3, r3, #2
    2242:	4a0d      	ldr	r2, [pc, #52]	; (2278 <xTaskIncrementTick+0xfc>)
    2244:	18d3      	adds	r3, r2, r3
    2246:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    2248:	2b01      	cmp	r3, #1
    224a:	d909      	bls.n	2260 <xTaskIncrementTick+0xe4>
				xSwitchRequired = pdTRUE;
    224c:	2401      	movs	r4, #1
    224e:	e007      	b.n	2260 <xTaskIncrementTick+0xe4>
						xNextTaskUnblockTime = xItemValue;
    2250:	4a09      	ldr	r2, [pc, #36]	; (2278 <xTaskIncrementTick+0xfc>)
    2252:	62d3      	str	r3, [r2, #44]	; 0x2c
						break;
    2254:	e7ef      	b.n	2236 <xTaskIncrementTick+0xba>
		++uxPendedTicks;
    2256:	4a07      	ldr	r2, [pc, #28]	; (2274 <xTaskIncrementTick+0xf8>)
    2258:	6e53      	ldr	r3, [r2, #100]	; 0x64
    225a:	3301      	adds	r3, #1
    225c:	6653      	str	r3, [r2, #100]	; 0x64
	BaseType_t xSwitchRequired = pdFALSE;
    225e:	2400      	movs	r4, #0
		if (xYieldPending != pdFALSE) {
    2260:	4b04      	ldr	r3, [pc, #16]	; (2274 <xTaskIncrementTick+0xf8>)
    2262:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    2264:	2b00      	cmp	r3, #0
    2266:	d000      	beq.n	226a <xTaskIncrementTick+0xee>
			xSwitchRequired = pdTRUE;
    2268:	2401      	movs	r4, #1
}
    226a:	0020      	movs	r0, r4
    226c:	bc0c      	pop	{r2, r3}
    226e:	4690      	mov	r8, r2
    2270:	4699      	mov	r9, r3
    2272:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2274:	20000a58 	.word	0x20000a58
    2278:	200009d8 	.word	0x200009d8
    227c:	00001e7d 	.word	0x00001e7d
    2280:	000013b3 	.word	0x000013b3
    2284:	0000136d 	.word	0x0000136d

00002288 <xTaskResumeAll>:
{
    2288:	b5f0      	push	{r4, r5, r6, r7, lr}
    228a:	b083      	sub	sp, #12
	configASSERT(uxSchedulerSuspended);
    228c:	4b31      	ldr	r3, [pc, #196]	; (2354 <xTaskResumeAll+0xcc>)
    228e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    2290:	2b00      	cmp	r3, #0
    2292:	d101      	bne.n	2298 <xTaskResumeAll+0x10>
    2294:	b672      	cpsid	i
    2296:	e7fe      	b.n	2296 <xTaskResumeAll+0xe>
	taskENTER_CRITICAL();
    2298:	4b2f      	ldr	r3, [pc, #188]	; (2358 <xTaskResumeAll+0xd0>)
    229a:	4798      	blx	r3
		--uxSchedulerSuspended;
    229c:	4b2d      	ldr	r3, [pc, #180]	; (2354 <xTaskResumeAll+0xcc>)
    229e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    22a0:	3a01      	subs	r2, #1
    22a2:	659a      	str	r2, [r3, #88]	; 0x58
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    22a4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
	BaseType_t xAlreadyYielded = pdFALSE;
    22a6:	2400      	movs	r4, #0
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    22a8:	2b00      	cmp	r3, #0
    22aa:	d104      	bne.n	22b6 <xTaskResumeAll+0x2e>
			if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
    22ac:	4b29      	ldr	r3, [pc, #164]	; (2354 <xTaskResumeAll+0xcc>)
    22ae:	6a1b      	ldr	r3, [r3, #32]
    22b0:	2500      	movs	r5, #0
    22b2:	2b00      	cmp	r3, #0
    22b4:	d104      	bne.n	22c0 <xTaskResumeAll+0x38>
	taskEXIT_CRITICAL();
    22b6:	4b29      	ldr	r3, [pc, #164]	; (235c <xTaskResumeAll+0xd4>)
    22b8:	4798      	blx	r3
}
    22ba:	0020      	movs	r0, r4
    22bc:	b003      	add	sp, #12
    22be:	bdf0      	pop	{r4, r5, r6, r7, pc}
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
    22c0:	4f27      	ldr	r7, [pc, #156]	; (2360 <xTaskResumeAll+0xd8>)
					prvAddTaskToReadyList(pxTCB);
    22c2:	003e      	movs	r6, r7
    22c4:	3630      	adds	r6, #48	; 0x30
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
    22c6:	697b      	ldr	r3, [r7, #20]
    22c8:	2b00      	cmp	r3, #0
    22ca:	d022      	beq.n	2312 <xTaskResumeAll+0x8a>
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
    22cc:	4b24      	ldr	r3, [pc, #144]	; (2360 <xTaskResumeAll+0xd8>)
    22ce:	6a1b      	ldr	r3, [r3, #32]
    22d0:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xEventListItem));
    22d2:	0028      	movs	r0, r5
    22d4:	3018      	adds	r0, #24
    22d6:	4c23      	ldr	r4, [pc, #140]	; (2364 <xTaskResumeAll+0xdc>)
    22d8:	47a0      	blx	r4
					(void)uxListRemove(&(pxTCB->xStateListItem));
    22da:	1d2b      	adds	r3, r5, #4
    22dc:	9301      	str	r3, [sp, #4]
    22de:	0018      	movs	r0, r3
    22e0:	47a0      	blx	r4
					prvAddTaskToReadyList(pxTCB);
    22e2:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    22e4:	4a1b      	ldr	r2, [pc, #108]	; (2354 <xTaskResumeAll+0xcc>)
    22e6:	6d52      	ldr	r2, [r2, #84]	; 0x54
    22e8:	4293      	cmp	r3, r2
    22ea:	d901      	bls.n	22f0 <xTaskResumeAll+0x68>
    22ec:	4a19      	ldr	r2, [pc, #100]	; (2354 <xTaskResumeAll+0xcc>)
    22ee:	6553      	str	r3, [r2, #84]	; 0x54
    22f0:	0098      	lsls	r0, r3, #2
    22f2:	18c0      	adds	r0, r0, r3
    22f4:	0080      	lsls	r0, r0, #2
    22f6:	1830      	adds	r0, r6, r0
    22f8:	9901      	ldr	r1, [sp, #4]
    22fa:	4b1b      	ldr	r3, [pc, #108]	; (2368 <xTaskResumeAll+0xe0>)
    22fc:	4798      	blx	r3
					if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    22fe:	4b15      	ldr	r3, [pc, #84]	; (2354 <xTaskResumeAll+0xcc>)
    2300:	699b      	ldr	r3, [r3, #24]
    2302:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2304:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    2306:	429a      	cmp	r2, r3
    2308:	d3dd      	bcc.n	22c6 <xTaskResumeAll+0x3e>
						xYieldPending = pdTRUE;
    230a:	2201      	movs	r2, #1
    230c:	4b11      	ldr	r3, [pc, #68]	; (2354 <xTaskResumeAll+0xcc>)
    230e:	669a      	str	r2, [r3, #104]	; 0x68
    2310:	e7d9      	b.n	22c6 <xTaskResumeAll+0x3e>
				if (pxTCB != NULL) {
    2312:	2d00      	cmp	r5, #0
    2314:	d001      	beq.n	231a <xTaskResumeAll+0x92>
					prvResetNextTaskUnblockTime();
    2316:	4b15      	ldr	r3, [pc, #84]	; (236c <xTaskResumeAll+0xe4>)
    2318:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    231a:	4b0e      	ldr	r3, [pc, #56]	; (2354 <xTaskResumeAll+0xcc>)
    231c:	6e5c      	ldr	r4, [r3, #100]	; 0x64
					if (uxPendedCounts > (UBaseType_t)0U) {
    231e:	2c00      	cmp	r4, #0
    2320:	d00e      	beq.n	2340 <xTaskResumeAll+0xb8>
							if (xTaskIncrementTick() != pdFALSE) {
    2322:	4f13      	ldr	r7, [pc, #76]	; (2370 <xTaskResumeAll+0xe8>)
								xYieldPending = pdTRUE;
    2324:	001e      	movs	r6, r3
    2326:	2501      	movs	r5, #1
    2328:	e002      	b.n	2330 <xTaskResumeAll+0xa8>
							--uxPendedCounts;
    232a:	3c01      	subs	r4, #1
						} while (uxPendedCounts > (UBaseType_t)0U);
    232c:	2c00      	cmp	r4, #0
    232e:	d004      	beq.n	233a <xTaskResumeAll+0xb2>
							if (xTaskIncrementTick() != pdFALSE) {
    2330:	47b8      	blx	r7
    2332:	2800      	cmp	r0, #0
    2334:	d0f9      	beq.n	232a <xTaskResumeAll+0xa2>
								xYieldPending = pdTRUE;
    2336:	66b5      	str	r5, [r6, #104]	; 0x68
    2338:	e7f7      	b.n	232a <xTaskResumeAll+0xa2>
						uxPendedTicks = 0;
    233a:	2200      	movs	r2, #0
    233c:	4b05      	ldr	r3, [pc, #20]	; (2354 <xTaskResumeAll+0xcc>)
    233e:	665a      	str	r2, [r3, #100]	; 0x64
				if (xYieldPending != pdFALSE) {
    2340:	4b04      	ldr	r3, [pc, #16]	; (2354 <xTaskResumeAll+0xcc>)
    2342:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	BaseType_t xAlreadyYielded = pdFALSE;
    2344:	2400      	movs	r4, #0
				if (xYieldPending != pdFALSE) {
    2346:	2b00      	cmp	r3, #0
    2348:	d0b5      	beq.n	22b6 <xTaskResumeAll+0x2e>
					taskYIELD_IF_USING_PREEMPTION();
    234a:	4b0a      	ldr	r3, [pc, #40]	; (2374 <xTaskResumeAll+0xec>)
    234c:	4798      	blx	r3
						xAlreadyYielded = pdTRUE;
    234e:	3401      	adds	r4, #1
    2350:	e7b1      	b.n	22b6 <xTaskResumeAll+0x2e>
    2352:	46c0      	nop			; (mov r8, r8)
    2354:	20000a58 	.word	0x20000a58
    2358:	000014d5 	.word	0x000014d5
    235c:	000014ed 	.word	0x000014ed
    2360:	200009d8 	.word	0x200009d8
    2364:	000013b3 	.word	0x000013b3
    2368:	0000136d 	.word	0x0000136d
    236c:	00001e7d 	.word	0x00001e7d
    2370:	0000217d 	.word	0x0000217d
    2374:	000014bd 	.word	0x000014bd

00002378 <vTaskDelay>:
{
    2378:	b510      	push	{r4, lr}
    237a:	1e04      	subs	r4, r0, #0
	if (xTicksToDelay > (TickType_t)0U) {
    237c:	d00f      	beq.n	239e <vTaskDelay+0x26>
		configASSERT(uxSchedulerSuspended == 0);
    237e:	4b09      	ldr	r3, [pc, #36]	; (23a4 <vTaskDelay+0x2c>)
    2380:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    2382:	2b00      	cmp	r3, #0
    2384:	d001      	beq.n	238a <vTaskDelay+0x12>
    2386:	b672      	cpsid	i
    2388:	e7fe      	b.n	2388 <vTaskDelay+0x10>
		vTaskSuspendAll();
    238a:	4b07      	ldr	r3, [pc, #28]	; (23a8 <vTaskDelay+0x30>)
    238c:	4798      	blx	r3
			prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
    238e:	2100      	movs	r1, #0
    2390:	0020      	movs	r0, r4
    2392:	4b06      	ldr	r3, [pc, #24]	; (23ac <vTaskDelay+0x34>)
    2394:	4798      	blx	r3
		xAlreadyYielded = xTaskResumeAll();
    2396:	4b06      	ldr	r3, [pc, #24]	; (23b0 <vTaskDelay+0x38>)
    2398:	4798      	blx	r3
	if (xAlreadyYielded == pdFALSE) {
    239a:	2800      	cmp	r0, #0
    239c:	d101      	bne.n	23a2 <vTaskDelay+0x2a>
		portYIELD_WITHIN_API();
    239e:	4b05      	ldr	r3, [pc, #20]	; (23b4 <vTaskDelay+0x3c>)
    23a0:	4798      	blx	r3
}
    23a2:	bd10      	pop	{r4, pc}
    23a4:	20000a58 	.word	0x20000a58
    23a8:	00002161 	.word	0x00002161
    23ac:	00001ebd 	.word	0x00001ebd
    23b0:	00002289 	.word	0x00002289
    23b4:	000014bd 	.word	0x000014bd

000023b8 <vTaskSwitchContext>:
{
    23b8:	b510      	push	{r4, lr}
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
    23ba:	4b20      	ldr	r3, [pc, #128]	; (243c <vTaskSwitchContext+0x84>)
    23bc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    23be:	2b00      	cmp	r3, #0
    23c0:	d119      	bne.n	23f6 <vTaskSwitchContext+0x3e>
		xYieldPending = pdFALSE;
    23c2:	4b1e      	ldr	r3, [pc, #120]	; (243c <vTaskSwitchContext+0x84>)
    23c4:	2200      	movs	r2, #0
    23c6:	669a      	str	r2, [r3, #104]	; 0x68
		taskSELECT_HIGHEST_PRIORITY_TASK();
    23c8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    23ca:	009a      	lsls	r2, r3, #2
    23cc:	18d2      	adds	r2, r2, r3
    23ce:	0092      	lsls	r2, r2, #2
    23d0:	491b      	ldr	r1, [pc, #108]	; (2440 <vTaskSwitchContext+0x88>)
    23d2:	188a      	adds	r2, r1, r2
    23d4:	6b12      	ldr	r2, [r2, #48]	; 0x30
    23d6:	2a00      	cmp	r2, #0
    23d8:	d111      	bne.n	23fe <vTaskSwitchContext+0x46>
    23da:	2b00      	cmp	r3, #0
    23dc:	d009      	beq.n	23f2 <vTaskSwitchContext+0x3a>
    23de:	3b01      	subs	r3, #1
    23e0:	009a      	lsls	r2, r3, #2
    23e2:	18d2      	adds	r2, r2, r3
    23e4:	0092      	lsls	r2, r2, #2
    23e6:	188a      	adds	r2, r1, r2
    23e8:	6b12      	ldr	r2, [r2, #48]	; 0x30
    23ea:	2a00      	cmp	r2, #0
    23ec:	d107      	bne.n	23fe <vTaskSwitchContext+0x46>
    23ee:	2b00      	cmp	r3, #0
    23f0:	d1f5      	bne.n	23de <vTaskSwitchContext+0x26>
    23f2:	b672      	cpsid	i
    23f4:	e7fe      	b.n	23f4 <vTaskSwitchContext+0x3c>
		xYieldPending = pdTRUE;
    23f6:	2201      	movs	r2, #1
    23f8:	4b10      	ldr	r3, [pc, #64]	; (243c <vTaskSwitchContext+0x84>)
    23fa:	669a      	str	r2, [r3, #104]	; 0x68
}
    23fc:	bd10      	pop	{r4, pc}
		taskSELECT_HIGHEST_PRIORITY_TASK();
    23fe:	4a10      	ldr	r2, [pc, #64]	; (2440 <vTaskSwitchContext+0x88>)
    2400:	0099      	lsls	r1, r3, #2
    2402:	18c8      	adds	r0, r1, r3
    2404:	0080      	lsls	r0, r0, #2
    2406:	1810      	adds	r0, r2, r0
    2408:	6b44      	ldr	r4, [r0, #52]	; 0x34
    240a:	6864      	ldr	r4, [r4, #4]
    240c:	6344      	str	r4, [r0, #52]	; 0x34
    240e:	18c9      	adds	r1, r1, r3
    2410:	0089      	lsls	r1, r1, #2
    2412:	0002      	movs	r2, r0
    2414:	3238      	adds	r2, #56	; 0x38
    2416:	4294      	cmp	r4, r2
    2418:	d00a      	beq.n	2430 <vTaskSwitchContext+0x78>
    241a:	009a      	lsls	r2, r3, #2
    241c:	18d2      	adds	r2, r2, r3
    241e:	0092      	lsls	r2, r2, #2
    2420:	4907      	ldr	r1, [pc, #28]	; (2440 <vTaskSwitchContext+0x88>)
    2422:	188a      	adds	r2, r1, r2
    2424:	6b52      	ldr	r2, [r2, #52]	; 0x34
    2426:	68d1      	ldr	r1, [r2, #12]
    2428:	4a04      	ldr	r2, [pc, #16]	; (243c <vTaskSwitchContext+0x84>)
    242a:	6191      	str	r1, [r2, #24]
    242c:	6553      	str	r3, [r2, #84]	; 0x54
}
    242e:	e7e5      	b.n	23fc <vTaskSwitchContext+0x44>
		taskSELECT_HIGHEST_PRIORITY_TASK();
    2430:	6860      	ldr	r0, [r4, #4]
    2432:	000a      	movs	r2, r1
    2434:	4902      	ldr	r1, [pc, #8]	; (2440 <vTaskSwitchContext+0x88>)
    2436:	188a      	adds	r2, r1, r2
    2438:	6350      	str	r0, [r2, #52]	; 0x34
    243a:	e7ee      	b.n	241a <vTaskSwitchContext+0x62>
    243c:	20000a58 	.word	0x20000a58
    2440:	200009d8 	.word	0x200009d8

00002444 <vTaskPlaceOnEventList>:
{
    2444:	b510      	push	{r4, lr}
    2446:	000c      	movs	r4, r1
	configASSERT(pxEventList);
    2448:	2800      	cmp	r0, #0
    244a:	d101      	bne.n	2450 <vTaskPlaceOnEventList+0xc>
    244c:	b672      	cpsid	i
    244e:	e7fe      	b.n	244e <vTaskPlaceOnEventList+0xa>
	vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
    2450:	4b04      	ldr	r3, [pc, #16]	; (2464 <vTaskPlaceOnEventList+0x20>)
    2452:	6999      	ldr	r1, [r3, #24]
    2454:	3118      	adds	r1, #24
    2456:	4b04      	ldr	r3, [pc, #16]	; (2468 <vTaskPlaceOnEventList+0x24>)
    2458:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
    245a:	2101      	movs	r1, #1
    245c:	0020      	movs	r0, r4
    245e:	4b03      	ldr	r3, [pc, #12]	; (246c <vTaskPlaceOnEventList+0x28>)
    2460:	4798      	blx	r3
}
    2462:	bd10      	pop	{r4, pc}
    2464:	20000a58 	.word	0x20000a58
    2468:	00001385 	.word	0x00001385
    246c:	00001ebd 	.word	0x00001ebd

00002470 <vTaskPlaceOnEventListRestricted>:
{
    2470:	b570      	push	{r4, r5, r6, lr}
    2472:	000c      	movs	r4, r1
    2474:	0015      	movs	r5, r2
	configASSERT(pxEventList);
    2476:	2800      	cmp	r0, #0
    2478:	d00d      	beq.n	2496 <vTaskPlaceOnEventListRestricted+0x26>
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
    247a:	4b08      	ldr	r3, [pc, #32]	; (249c <vTaskPlaceOnEventListRestricted+0x2c>)
    247c:	6999      	ldr	r1, [r3, #24]
    247e:	3118      	adds	r1, #24
    2480:	4b07      	ldr	r3, [pc, #28]	; (24a0 <vTaskPlaceOnEventListRestricted+0x30>)
    2482:	4798      	blx	r3
	if (xWaitIndefinitely != pdFALSE) {
    2484:	2d00      	cmp	r5, #0
    2486:	d001      	beq.n	248c <vTaskPlaceOnEventListRestricted+0x1c>
		xTicksToWait = portMAX_DELAY;
    2488:	2401      	movs	r4, #1
    248a:	4264      	negs	r4, r4
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
    248c:	0029      	movs	r1, r5
    248e:	0020      	movs	r0, r4
    2490:	4b04      	ldr	r3, [pc, #16]	; (24a4 <vTaskPlaceOnEventListRestricted+0x34>)
    2492:	4798      	blx	r3
}
    2494:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT(pxEventList);
    2496:	b672      	cpsid	i
    2498:	e7fe      	b.n	2498 <vTaskPlaceOnEventListRestricted+0x28>
    249a:	46c0      	nop			; (mov r8, r8)
    249c:	20000a58 	.word	0x20000a58
    24a0:	0000136d 	.word	0x0000136d
    24a4:	00001ebd 	.word	0x00001ebd

000024a8 <xTaskRemoveFromEventList>:
{
    24a8:	b570      	push	{r4, r5, r6, lr}
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
    24aa:	68c3      	ldr	r3, [r0, #12]
    24ac:	68dc      	ldr	r4, [r3, #12]
	configASSERT(pxUnblockedTCB);
    24ae:	2c00      	cmp	r4, #0
    24b0:	d028      	beq.n	2504 <xTaskRemoveFromEventList+0x5c>
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
    24b2:	0025      	movs	r5, r4
    24b4:	3518      	adds	r5, #24
    24b6:	0028      	movs	r0, r5
    24b8:	4b16      	ldr	r3, [pc, #88]	; (2514 <xTaskRemoveFromEventList+0x6c>)
    24ba:	4798      	blx	r3
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    24bc:	4b16      	ldr	r3, [pc, #88]	; (2518 <xTaskRemoveFromEventList+0x70>)
    24be:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    24c0:	2b00      	cmp	r3, #0
    24c2:	d121      	bne.n	2508 <xTaskRemoveFromEventList+0x60>
		(void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
    24c4:	1d25      	adds	r5, r4, #4
    24c6:	0028      	movs	r0, r5
    24c8:	4b12      	ldr	r3, [pc, #72]	; (2514 <xTaskRemoveFromEventList+0x6c>)
    24ca:	4798      	blx	r3
		prvAddTaskToReadyList(pxUnblockedTCB);
    24cc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    24ce:	4a12      	ldr	r2, [pc, #72]	; (2518 <xTaskRemoveFromEventList+0x70>)
    24d0:	6d52      	ldr	r2, [r2, #84]	; 0x54
    24d2:	4293      	cmp	r3, r2
    24d4:	d901      	bls.n	24da <xTaskRemoveFromEventList+0x32>
    24d6:	4a10      	ldr	r2, [pc, #64]	; (2518 <xTaskRemoveFromEventList+0x70>)
    24d8:	6553      	str	r3, [r2, #84]	; 0x54
    24da:	0098      	lsls	r0, r3, #2
    24dc:	18c3      	adds	r3, r0, r3
    24de:	009b      	lsls	r3, r3, #2
    24e0:	480e      	ldr	r0, [pc, #56]	; (251c <xTaskRemoveFromEventList+0x74>)
    24e2:	3030      	adds	r0, #48	; 0x30
    24e4:	18c0      	adds	r0, r0, r3
    24e6:	0029      	movs	r1, r5
    24e8:	4b0d      	ldr	r3, [pc, #52]	; (2520 <xTaskRemoveFromEventList+0x78>)
    24ea:	4798      	blx	r3
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
    24ec:	4b0a      	ldr	r3, [pc, #40]	; (2518 <xTaskRemoveFromEventList+0x70>)
    24ee:	699b      	ldr	r3, [r3, #24]
    24f0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    24f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
		xReturn = pdFALSE;
    24f4:	2000      	movs	r0, #0
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
    24f6:	429a      	cmp	r2, r3
    24f8:	d903      	bls.n	2502 <xTaskRemoveFromEventList+0x5a>
		xYieldPending = pdTRUE;
    24fa:	2201      	movs	r2, #1
    24fc:	4b06      	ldr	r3, [pc, #24]	; (2518 <xTaskRemoveFromEventList+0x70>)
    24fe:	669a      	str	r2, [r3, #104]	; 0x68
		xReturn = pdTRUE;
    2500:	3001      	adds	r0, #1
}
    2502:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT(pxUnblockedTCB);
    2504:	b672      	cpsid	i
    2506:	e7fe      	b.n	2506 <xTaskRemoveFromEventList+0x5e>
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
    2508:	0029      	movs	r1, r5
    250a:	4804      	ldr	r0, [pc, #16]	; (251c <xTaskRemoveFromEventList+0x74>)
    250c:	3014      	adds	r0, #20
    250e:	4b04      	ldr	r3, [pc, #16]	; (2520 <xTaskRemoveFromEventList+0x78>)
    2510:	4798      	blx	r3
    2512:	e7eb      	b.n	24ec <xTaskRemoveFromEventList+0x44>
    2514:	000013b3 	.word	0x000013b3
    2518:	20000a58 	.word	0x20000a58
    251c:	200009d8 	.word	0x200009d8
    2520:	0000136d 	.word	0x0000136d

00002524 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
    2524:	4b02      	ldr	r3, [pc, #8]	; (2530 <vTaskInternalSetTimeOutState+0xc>)
    2526:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    2528:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    252a:	695b      	ldr	r3, [r3, #20]
    252c:	6043      	str	r3, [r0, #4]
}
    252e:	4770      	bx	lr
    2530:	20000a58 	.word	0x20000a58

00002534 <xTaskCheckForTimeOut>:
{
    2534:	b570      	push	{r4, r5, r6, lr}
    2536:	0006      	movs	r6, r0
    2538:	000d      	movs	r5, r1
	configASSERT(pxTimeOut);
    253a:	2800      	cmp	r0, #0
    253c:	d01b      	beq.n	2576 <xTaskCheckForTimeOut+0x42>
	configASSERT(pxTicksToWait);
    253e:	2900      	cmp	r1, #0
    2540:	d01b      	beq.n	257a <xTaskCheckForTimeOut+0x46>
	taskENTER_CRITICAL();
    2542:	4b13      	ldr	r3, [pc, #76]	; (2590 <xTaskCheckForTimeOut+0x5c>)
    2544:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
    2546:	4b13      	ldr	r3, [pc, #76]	; (2594 <xTaskCheckForTimeOut+0x60>)
    2548:	695a      	ldr	r2, [r3, #20]
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
    254a:	6871      	ldr	r1, [r6, #4]
		    if (*pxTicksToWait == portMAX_DELAY) {
    254c:	682b      	ldr	r3, [r5, #0]
    254e:	1c58      	adds	r0, r3, #1
    2550:	d01c      	beq.n	258c <xTaskCheckForTimeOut+0x58>
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
    2552:	4810      	ldr	r0, [pc, #64]	; (2594 <xTaskCheckForTimeOut+0x60>)
    2554:	6e00      	ldr	r0, [r0, #96]	; 0x60
    2556:	6834      	ldr	r4, [r6, #0]
    2558:	4284      	cmp	r4, r0
    255a:	d002      	beq.n	2562 <xTaskCheckForTimeOut+0x2e>
			xReturn = pdTRUE;
    255c:	2401      	movs	r4, #1
		        && (xConstTickCount >= pxTimeOut->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to make
    255e:	428a      	cmp	r2, r1
    2560:	d205      	bcs.n	256e <xTaskCheckForTimeOut+0x3a>
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
    2562:	1a52      	subs	r2, r2, r1
		} else if (xElapsedTime < *pxTicksToWait) /*lint !e961 Explicit casting is only redundant with some compilers,
    2564:	429a      	cmp	r2, r3
    2566:	d30a      	bcc.n	257e <xTaskCheckForTimeOut+0x4a>
			*pxTicksToWait = 0;
    2568:	2300      	movs	r3, #0
    256a:	602b      	str	r3, [r5, #0]
			xReturn        = pdTRUE;
    256c:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
    256e:	4b0a      	ldr	r3, [pc, #40]	; (2598 <xTaskCheckForTimeOut+0x64>)
    2570:	4798      	blx	r3
}
    2572:	0020      	movs	r0, r4
    2574:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT(pxTimeOut);
    2576:	b672      	cpsid	i
    2578:	e7fe      	b.n	2578 <xTaskCheckForTimeOut+0x44>
	configASSERT(pxTicksToWait);
    257a:	b672      	cpsid	i
    257c:	e7fe      	b.n	257c <xTaskCheckForTimeOut+0x48>
			*pxTicksToWait -= xElapsedTime;
    257e:	1a9b      	subs	r3, r3, r2
    2580:	602b      	str	r3, [r5, #0]
			vTaskInternalSetTimeOutState(pxTimeOut);
    2582:	0030      	movs	r0, r6
    2584:	4b05      	ldr	r3, [pc, #20]	; (259c <xTaskCheckForTimeOut+0x68>)
    2586:	4798      	blx	r3
			xReturn = pdFALSE;
    2588:	2400      	movs	r4, #0
    258a:	e7f0      	b.n	256e <xTaskCheckForTimeOut+0x3a>
			xReturn = pdFALSE;
    258c:	2400      	movs	r4, #0
    258e:	e7ee      	b.n	256e <xTaskCheckForTimeOut+0x3a>
    2590:	000014d5 	.word	0x000014d5
    2594:	20000a58 	.word	0x20000a58
    2598:	000014ed 	.word	0x000014ed
    259c:	00002525 	.word	0x00002525

000025a0 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    25a0:	2201      	movs	r2, #1
    25a2:	4b01      	ldr	r3, [pc, #4]	; (25a8 <vTaskMissedYield+0x8>)
    25a4:	669a      	str	r2, [r3, #104]	; 0x68
}
    25a6:	4770      	bx	lr
    25a8:	20000a58 	.word	0x20000a58

000025ac <xTaskGetSchedulerState>:
	if (xSchedulerRunning == pdFALSE) {
    25ac:	4b05      	ldr	r3, [pc, #20]	; (25c4 <xTaskGetSchedulerState+0x18>)
    25ae:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
		xReturn = taskSCHEDULER_NOT_STARTED;
    25b0:	2001      	movs	r0, #1
	if (xSchedulerRunning == pdFALSE) {
    25b2:	2b00      	cmp	r3, #0
    25b4:	d004      	beq.n	25c0 <xTaskGetSchedulerState+0x14>
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    25b6:	4b03      	ldr	r3, [pc, #12]	; (25c4 <xTaskGetSchedulerState+0x18>)
    25b8:	6d98      	ldr	r0, [r3, #88]	; 0x58
			xReturn = taskSCHEDULER_SUSPENDED;
    25ba:	4243      	negs	r3, r0
    25bc:	4158      	adcs	r0, r3
    25be:	0040      	lsls	r0, r0, #1
}
    25c0:	4770      	bx	lr
    25c2:	46c0      	nop			; (mov r8, r8)
    25c4:	20000a58 	.word	0x20000a58

000025c8 <xTaskPriorityInherit>:
{
    25c8:	b570      	push	{r4, r5, r6, lr}
    25ca:	1e04      	subs	r4, r0, #0
	if (pxMutexHolder != NULL) {
    25cc:	d03d      	beq.n	264a <xTaskPriorityInherit+0x82>
		if (pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority) {
    25ce:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
    25d0:	4b1f      	ldr	r3, [pc, #124]	; (2650 <xTaskPriorityInherit+0x88>)
    25d2:	699b      	ldr	r3, [r3, #24]
    25d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    25d6:	4299      	cmp	r1, r3
    25d8:	d22f      	bcs.n	263a <xTaskPriorityInherit+0x72>
			if ((listGET_LIST_ITEM_VALUE(&(pxMutexHolderTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE)
    25da:	6983      	ldr	r3, [r0, #24]
    25dc:	2b00      	cmp	r3, #0
    25de:	db05      	blt.n	25ec <xTaskPriorityInherit+0x24>
				listSET_LIST_ITEM_VALUE(
    25e0:	4b1b      	ldr	r3, [pc, #108]	; (2650 <xTaskPriorityInherit+0x88>)
    25e2:	699b      	ldr	r3, [r3, #24]
    25e4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    25e6:	2305      	movs	r3, #5
    25e8:	1a9b      	subs	r3, r3, r2
    25ea:	6183      	str	r3, [r0, #24]
			if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[pxMutexHolderTCB->uxPriority]),
    25ec:	008b      	lsls	r3, r1, #2
    25ee:	1859      	adds	r1, r3, r1
    25f0:	0089      	lsls	r1, r1, #2
    25f2:	4b18      	ldr	r3, [pc, #96]	; (2654 <xTaskPriorityInherit+0x8c>)
    25f4:	3330      	adds	r3, #48	; 0x30
    25f6:	185b      	adds	r3, r3, r1
    25f8:	6962      	ldr	r2, [r4, #20]
    25fa:	429a      	cmp	r2, r3
    25fc:	d005      	beq.n	260a <xTaskPriorityInherit+0x42>
				pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    25fe:	4b14      	ldr	r3, [pc, #80]	; (2650 <xTaskPriorityInherit+0x88>)
    2600:	699b      	ldr	r3, [r3, #24]
    2602:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2604:	62e3      	str	r3, [r4, #44]	; 0x2c
			xReturn = pdTRUE;
    2606:	2001      	movs	r0, #1
    2608:	e01e      	b.n	2648 <xTaskPriorityInherit+0x80>
				if (uxListRemove(&(pxMutexHolderTCB->xStateListItem)) == (UBaseType_t)0) {
    260a:	1d25      	adds	r5, r4, #4
    260c:	0028      	movs	r0, r5
    260e:	4b12      	ldr	r3, [pc, #72]	; (2658 <xTaskPriorityInherit+0x90>)
    2610:	4798      	blx	r3
				pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    2612:	4b0f      	ldr	r3, [pc, #60]	; (2650 <xTaskPriorityInherit+0x88>)
    2614:	699a      	ldr	r2, [r3, #24]
    2616:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    2618:	62e2      	str	r2, [r4, #44]	; 0x2c
				prvAddTaskToReadyList(pxMutexHolderTCB);
    261a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    261c:	429a      	cmp	r2, r3
    261e:	d901      	bls.n	2624 <xTaskPriorityInherit+0x5c>
    2620:	4b0b      	ldr	r3, [pc, #44]	; (2650 <xTaskPriorityInherit+0x88>)
    2622:	655a      	str	r2, [r3, #84]	; 0x54
    2624:	0090      	lsls	r0, r2, #2
    2626:	1882      	adds	r2, r0, r2
    2628:	0092      	lsls	r2, r2, #2
    262a:	480a      	ldr	r0, [pc, #40]	; (2654 <xTaskPriorityInherit+0x8c>)
    262c:	3030      	adds	r0, #48	; 0x30
    262e:	1880      	adds	r0, r0, r2
    2630:	0029      	movs	r1, r5
    2632:	4b0a      	ldr	r3, [pc, #40]	; (265c <xTaskPriorityInherit+0x94>)
    2634:	4798      	blx	r3
			xReturn = pdTRUE;
    2636:	2001      	movs	r0, #1
    2638:	e006      	b.n	2648 <xTaskPriorityInherit+0x80>
			if (pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority) {
    263a:	4b05      	ldr	r3, [pc, #20]	; (2650 <xTaskPriorityInherit+0x88>)
    263c:	699b      	ldr	r3, [r3, #24]
    263e:	6c40      	ldr	r0, [r0, #68]	; 0x44
    2640:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2642:	4298      	cmp	r0, r3
    2644:	4180      	sbcs	r0, r0
    2646:	4240      	negs	r0, r0
}
    2648:	bd70      	pop	{r4, r5, r6, pc}
	BaseType_t   xReturn          = pdFALSE;
    264a:	2000      	movs	r0, #0
	return xReturn;
    264c:	e7fc      	b.n	2648 <xTaskPriorityInherit+0x80>
    264e:	46c0      	nop			; (mov r8, r8)
    2650:	20000a58 	.word	0x20000a58
    2654:	200009d8 	.word	0x200009d8
    2658:	000013b3 	.word	0x000013b3
    265c:	0000136d 	.word	0x0000136d

00002660 <xTaskPriorityDisinherit>:
{
    2660:	b570      	push	{r4, r5, r6, lr}
    2662:	1e04      	subs	r4, r0, #0
	if (pxMutexHolder != NULL) {
    2664:	d02d      	beq.n	26c2 <xTaskPriorityDisinherit+0x62>
		configASSERT(pxTCB == pxCurrentTCB);
    2666:	4b19      	ldr	r3, [pc, #100]	; (26cc <xTaskPriorityDisinherit+0x6c>)
    2668:	699b      	ldr	r3, [r3, #24]
    266a:	4298      	cmp	r0, r3
    266c:	d001      	beq.n	2672 <xTaskPriorityDisinherit+0x12>
    266e:	b672      	cpsid	i
    2670:	e7fe      	b.n	2670 <xTaskPriorityDisinherit+0x10>
		configASSERT(pxTCB->uxMutexesHeld);
    2672:	6c83      	ldr	r3, [r0, #72]	; 0x48
    2674:	2b00      	cmp	r3, #0
    2676:	d101      	bne.n	267c <xTaskPriorityDisinherit+0x1c>
    2678:	b672      	cpsid	i
    267a:	e7fe      	b.n	267a <xTaskPriorityDisinherit+0x1a>
		(pxTCB->uxMutexesHeld)--;
    267c:	3b01      	subs	r3, #1
    267e:	6483      	str	r3, [r0, #72]	; 0x48
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
    2680:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    2682:	6c41      	ldr	r1, [r0, #68]	; 0x44
    2684:	428a      	cmp	r2, r1
    2686:	d01e      	beq.n	26c6 <xTaskPriorityDisinherit+0x66>
	BaseType_t   xReturn = pdFALSE;
    2688:	2000      	movs	r0, #0
			if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
    268a:	2b00      	cmp	r3, #0
    268c:	d118      	bne.n	26c0 <xTaskPriorityDisinherit+0x60>
				if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
    268e:	1d25      	adds	r5, r4, #4
    2690:	0028      	movs	r0, r5
    2692:	4b0f      	ldr	r3, [pc, #60]	; (26d0 <xTaskPriorityDisinherit+0x70>)
    2694:	4798      	blx	r3
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2696:	6c63      	ldr	r3, [r4, #68]	; 0x44
    2698:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE(
    269a:	2205      	movs	r2, #5
    269c:	1ad2      	subs	r2, r2, r3
    269e:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyList(pxTCB);
    26a0:	4a0a      	ldr	r2, [pc, #40]	; (26cc <xTaskPriorityDisinherit+0x6c>)
    26a2:	6d52      	ldr	r2, [r2, #84]	; 0x54
    26a4:	4293      	cmp	r3, r2
    26a6:	d901      	bls.n	26ac <xTaskPriorityDisinherit+0x4c>
    26a8:	4a08      	ldr	r2, [pc, #32]	; (26cc <xTaskPriorityDisinherit+0x6c>)
    26aa:	6553      	str	r3, [r2, #84]	; 0x54
    26ac:	0098      	lsls	r0, r3, #2
    26ae:	18c3      	adds	r3, r0, r3
    26b0:	009b      	lsls	r3, r3, #2
    26b2:	4808      	ldr	r0, [pc, #32]	; (26d4 <xTaskPriorityDisinherit+0x74>)
    26b4:	3030      	adds	r0, #48	; 0x30
    26b6:	18c0      	adds	r0, r0, r3
    26b8:	0029      	movs	r1, r5
    26ba:	4b07      	ldr	r3, [pc, #28]	; (26d8 <xTaskPriorityDisinherit+0x78>)
    26bc:	4798      	blx	r3
				xReturn = pdTRUE;
    26be:	2001      	movs	r0, #1
}
    26c0:	bd70      	pop	{r4, r5, r6, pc}
	BaseType_t   xReturn = pdFALSE;
    26c2:	2000      	movs	r0, #0
    26c4:	e7fc      	b.n	26c0 <xTaskPriorityDisinherit+0x60>
    26c6:	2000      	movs	r0, #0
    26c8:	e7fa      	b.n	26c0 <xTaskPriorityDisinherit+0x60>
    26ca:	46c0      	nop			; (mov r8, r8)
    26cc:	20000a58 	.word	0x20000a58
    26d0:	000013b3 	.word	0x000013b3
    26d4:	200009d8 	.word	0x200009d8
    26d8:	0000136d 	.word	0x0000136d

000026dc <vTaskPriorityDisinheritAfterTimeout>:
{
    26dc:	b570      	push	{r4, r5, r6, lr}
    26de:	1e04      	subs	r4, r0, #0
	if (pxMutexHolder != NULL) {
    26e0:	d00d      	beq.n	26fe <vTaskPriorityDisinheritAfterTimeout+0x22>
		configASSERT(pxTCB->uxMutexesHeld);
    26e2:	6c83      	ldr	r3, [r0, #72]	; 0x48
    26e4:	2b00      	cmp	r3, #0
    26e6:	d101      	bne.n	26ec <vTaskPriorityDisinheritAfterTimeout+0x10>
    26e8:	b672      	cpsid	i
    26ea:	e7fe      	b.n	26ea <vTaskPriorityDisinheritAfterTimeout+0xe>
    26ec:	6c40      	ldr	r0, [r0, #68]	; 0x44
    26ee:	4288      	cmp	r0, r1
    26f0:	d200      	bcs.n	26f4 <vTaskPriorityDisinheritAfterTimeout+0x18>
    26f2:	0008      	movs	r0, r1
		if (pxTCB->uxPriority != uxPriorityToUse) {
    26f4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    26f6:	4282      	cmp	r2, r0
    26f8:	d001      	beq.n	26fe <vTaskPriorityDisinheritAfterTimeout+0x22>
			if (pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld) {
    26fa:	2b01      	cmp	r3, #1
    26fc:	d000      	beq.n	2700 <vTaskPriorityDisinheritAfterTimeout+0x24>
}
    26fe:	bd70      	pop	{r4, r5, r6, pc}
				configASSERT(pxTCB != pxCurrentTCB);
    2700:	4b15      	ldr	r3, [pc, #84]	; (2758 <vTaskPriorityDisinheritAfterTimeout+0x7c>)
    2702:	699b      	ldr	r3, [r3, #24]
    2704:	429c      	cmp	r4, r3
    2706:	d101      	bne.n	270c <vTaskPriorityDisinheritAfterTimeout+0x30>
    2708:	b672      	cpsid	i
    270a:	e7fe      	b.n	270a <vTaskPriorityDisinheritAfterTimeout+0x2e>
				pxTCB->uxPriority     = uxPriorityToUse;
    270c:	62e0      	str	r0, [r4, #44]	; 0x2c
				if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL) {
    270e:	69a3      	ldr	r3, [r4, #24]
    2710:	2b00      	cmp	r3, #0
    2712:	db02      	blt.n	271a <vTaskPriorityDisinheritAfterTimeout+0x3e>
					listSET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem),
    2714:	2305      	movs	r3, #5
    2716:	1a18      	subs	r0, r3, r0
    2718:	61a0      	str	r0, [r4, #24]
				if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[uxPriorityUsedOnEntry]), &(pxTCB->xStateListItem))
    271a:	0093      	lsls	r3, r2, #2
    271c:	189a      	adds	r2, r3, r2
    271e:	0092      	lsls	r2, r2, #2
    2720:	4b0e      	ldr	r3, [pc, #56]	; (275c <vTaskPriorityDisinheritAfterTimeout+0x80>)
    2722:	3330      	adds	r3, #48	; 0x30
    2724:	189b      	adds	r3, r3, r2
    2726:	6962      	ldr	r2, [r4, #20]
    2728:	429a      	cmp	r2, r3
    272a:	d1e8      	bne.n	26fe <vTaskPriorityDisinheritAfterTimeout+0x22>
					if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
    272c:	1d25      	adds	r5, r4, #4
    272e:	0028      	movs	r0, r5
    2730:	4b0b      	ldr	r3, [pc, #44]	; (2760 <vTaskPriorityDisinheritAfterTimeout+0x84>)
    2732:	4798      	blx	r3
					prvAddTaskToReadyList(pxTCB);
    2734:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2736:	4a08      	ldr	r2, [pc, #32]	; (2758 <vTaskPriorityDisinheritAfterTimeout+0x7c>)
    2738:	6d52      	ldr	r2, [r2, #84]	; 0x54
    273a:	4293      	cmp	r3, r2
    273c:	d901      	bls.n	2742 <vTaskPriorityDisinheritAfterTimeout+0x66>
    273e:	4a06      	ldr	r2, [pc, #24]	; (2758 <vTaskPriorityDisinheritAfterTimeout+0x7c>)
    2740:	6553      	str	r3, [r2, #84]	; 0x54
    2742:	0098      	lsls	r0, r3, #2
    2744:	18c3      	adds	r3, r0, r3
    2746:	009b      	lsls	r3, r3, #2
    2748:	4804      	ldr	r0, [pc, #16]	; (275c <vTaskPriorityDisinheritAfterTimeout+0x80>)
    274a:	3030      	adds	r0, #48	; 0x30
    274c:	18c0      	adds	r0, r0, r3
    274e:	0029      	movs	r1, r5
    2750:	4b04      	ldr	r3, [pc, #16]	; (2764 <vTaskPriorityDisinheritAfterTimeout+0x88>)
    2752:	4798      	blx	r3
}
    2754:	e7d3      	b.n	26fe <vTaskPriorityDisinheritAfterTimeout+0x22>
    2756:	46c0      	nop			; (mov r8, r8)
    2758:	20000a58 	.word	0x20000a58
    275c:	200009d8 	.word	0x200009d8
    2760:	000013b3 	.word	0x000013b3
    2764:	0000136d 	.word	0x0000136d

00002768 <pvTaskIncrementMutexHeldCount>:
	if (pxCurrentTCB != NULL) {
    2768:	4b05      	ldr	r3, [pc, #20]	; (2780 <pvTaskIncrementMutexHeldCount+0x18>)
    276a:	699b      	ldr	r3, [r3, #24]
    276c:	2b00      	cmp	r3, #0
    276e:	d004      	beq.n	277a <pvTaskIncrementMutexHeldCount+0x12>
		(pxCurrentTCB->uxMutexesHeld)++;
    2770:	4b03      	ldr	r3, [pc, #12]	; (2780 <pvTaskIncrementMutexHeldCount+0x18>)
    2772:	699a      	ldr	r2, [r3, #24]
    2774:	6c93      	ldr	r3, [r2, #72]	; 0x48
    2776:	3301      	adds	r3, #1
    2778:	6493      	str	r3, [r2, #72]	; 0x48
	return pxCurrentTCB;
    277a:	4b01      	ldr	r3, [pc, #4]	; (2780 <pvTaskIncrementMutexHeldCount+0x18>)
    277c:	6998      	ldr	r0, [r3, #24]
}
    277e:	4770      	bx	lr
    2780:	20000a58 	.word	0x20000a58

00002784 <prvInsertTimerInActiveList>:
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList(Timer_t *const pxTimer, const TickType_t xNextExpiryTime,
                                             const TickType_t xTimeNow, const TickType_t xCommandTime)
{
    2784:	b510      	push	{r4, lr}
	BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
    2786:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    2788:	6100      	str	r0, [r0, #16]

	if (xNextExpiryTime <= xTimeNow) {
    278a:	4291      	cmp	r1, r2
    278c:	d80b      	bhi.n	27a6 <prvInsertTimerInActiveList+0x22>
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if (((TickType_t)(xTimeNow - xCommandTime))
    278e:	1ad2      	subs	r2, r2, r3
		    >= pxTimer->xTimerPeriodInTicks) /*lint !e961 MISRA exception as the casts are only redundant for some
		                                        ports. */
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    2790:	2401      	movs	r4, #1
		if (((TickType_t)(xTimeNow - xCommandTime))
    2792:	6983      	ldr	r3, [r0, #24]
    2794:	429a      	cmp	r2, r3
    2796:	d211      	bcs.n	27bc <prvInsertTimerInActiveList+0x38>
		} else {
			vListInsert(pxOverflowTimerList, &(pxTimer->xTimerListItem));
    2798:	1d01      	adds	r1, r0, #4
    279a:	4b09      	ldr	r3, [pc, #36]	; (27c0 <prvInsertTimerInActiveList+0x3c>)
    279c:	6818      	ldr	r0, [r3, #0]
    279e:	4b09      	ldr	r3, [pc, #36]	; (27c4 <prvInsertTimerInActiveList+0x40>)
    27a0:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    27a2:	2400      	movs	r4, #0
    27a4:	e00a      	b.n	27bc <prvInsertTimerInActiveList+0x38>
		}
	} else {
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
    27a6:	429a      	cmp	r2, r3
    27a8:	d202      	bcs.n	27b0 <prvInsertTimerInActiveList+0x2c>
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    27aa:	2401      	movs	r4, #1
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
    27ac:	4299      	cmp	r1, r3
    27ae:	d205      	bcs.n	27bc <prvInsertTimerInActiveList+0x38>
		} else {
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    27b0:	1d01      	adds	r1, r0, #4
    27b2:	4b03      	ldr	r3, [pc, #12]	; (27c0 <prvInsertTimerInActiveList+0x3c>)
    27b4:	6858      	ldr	r0, [r3, #4]
    27b6:	4b03      	ldr	r3, [pc, #12]	; (27c4 <prvInsertTimerInActiveList+0x40>)
    27b8:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    27ba:	2400      	movs	r4, #0
		}
	}

	return xProcessTimerNow;
}
    27bc:	0020      	movs	r0, r4
    27be:	bd10      	pop	{r4, pc}
    27c0:	20000ac4 	.word	0x20000ac4
    27c4:	00001385 	.word	0x00001385

000027c8 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue(void)
{
    27c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    27ca:	4b0e      	ldr	r3, [pc, #56]	; (2804 <prvCheckForValidListAndQueue+0x3c>)
    27cc:	4798      	blx	r3
	{
		if (xTimerQueue == NULL) {
    27ce:	4b0e      	ldr	r3, [pc, #56]	; (2808 <prvCheckForValidListAndQueue+0x40>)
    27d0:	689b      	ldr	r3, [r3, #8]
    27d2:	2b00      	cmp	r3, #0
    27d4:	d002      	beq.n	27dc <prvCheckForValidListAndQueue+0x14>
#endif /* configQUEUE_REGISTRY_SIZE */
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    27d6:	4b0d      	ldr	r3, [pc, #52]	; (280c <prvCheckForValidListAndQueue+0x44>)
    27d8:	4798      	blx	r3
}
    27da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			vListInitialise(&xActiveTimerList1);
    27dc:	4c0a      	ldr	r4, [pc, #40]	; (2808 <prvCheckForValidListAndQueue+0x40>)
    27de:	0026      	movs	r6, r4
    27e0:	360c      	adds	r6, #12
    27e2:	0030      	movs	r0, r6
    27e4:	4f0a      	ldr	r7, [pc, #40]	; (2810 <prvCheckForValidListAndQueue+0x48>)
    27e6:	47b8      	blx	r7
			vListInitialise(&xActiveTimerList2);
    27e8:	0025      	movs	r5, r4
    27ea:	3520      	adds	r5, #32
    27ec:	0028      	movs	r0, r5
    27ee:	47b8      	blx	r7
			pxCurrentTimerList  = &xActiveTimerList1;
    27f0:	6066      	str	r6, [r4, #4]
			pxOverflowTimerList = &xActiveTimerList2;
    27f2:	6025      	str	r5, [r4, #0]
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    27f4:	2200      	movs	r2, #0
    27f6:	210c      	movs	r1, #12
    27f8:	2002      	movs	r0, #2
    27fa:	4b06      	ldr	r3, [pc, #24]	; (2814 <prvCheckForValidListAndQueue+0x4c>)
    27fc:	4798      	blx	r3
    27fe:	60a0      	str	r0, [r4, #8]
    2800:	e7e9      	b.n	27d6 <prvCheckForValidListAndQueue+0xe>
    2802:	46c0      	nop			; (mov r8, r8)
    2804:	000014d5 	.word	0x000014d5
    2808:	20000ac4 	.word	0x20000ac4
    280c:	000014ed 	.word	0x000014ed
    2810:	00001351 	.word	0x00001351
    2814:	0000185d 	.word	0x0000185d

00002818 <xTimerCreateTimerTask>:
{
    2818:	b510      	push	{r4, lr}
    281a:	b082      	sub	sp, #8
	prvCheckForValidListAndQueue();
    281c:	4b0b      	ldr	r3, [pc, #44]	; (284c <xTimerCreateTimerTask+0x34>)
    281e:	4798      	blx	r3
	if (xTimerQueue != NULL) {
    2820:	4b0b      	ldr	r3, [pc, #44]	; (2850 <xTimerCreateTimerTask+0x38>)
    2822:	689b      	ldr	r3, [r3, #8]
    2824:	2b00      	cmp	r3, #0
    2826:	d00e      	beq.n	2846 <xTimerCreateTimerTask+0x2e>
			xReturn = xTaskCreate(prvTimerTask,
    2828:	4b09      	ldr	r3, [pc, #36]	; (2850 <xTimerCreateTimerTask+0x38>)
    282a:	3334      	adds	r3, #52	; 0x34
    282c:	9301      	str	r3, [sp, #4]
    282e:	2302      	movs	r3, #2
    2830:	9300      	str	r3, [sp, #0]
    2832:	2300      	movs	r3, #0
    2834:	2240      	movs	r2, #64	; 0x40
    2836:	4907      	ldr	r1, [pc, #28]	; (2854 <xTimerCreateTimerTask+0x3c>)
    2838:	4807      	ldr	r0, [pc, #28]	; (2858 <xTimerCreateTimerTask+0x40>)
    283a:	4c08      	ldr	r4, [pc, #32]	; (285c <xTimerCreateTimerTask+0x44>)
    283c:	47a0      	blx	r4
	configASSERT(xReturn);
    283e:	2800      	cmp	r0, #0
    2840:	d001      	beq.n	2846 <xTimerCreateTimerTask+0x2e>
}
    2842:	b002      	add	sp, #8
    2844:	bd10      	pop	{r4, pc}
	configASSERT(xReturn);
    2846:	b672      	cpsid	i
    2848:	e7fe      	b.n	2848 <xTimerCreateTimerTask+0x30>
    284a:	46c0      	nop			; (mov r8, r8)
    284c:	000027c9 	.word	0x000027c9
    2850:	20000ac4 	.word	0x20000ac4
    2854:	00002c7c 	.word	0x00002c7c
    2858:	0000297d 	.word	0x0000297d
    285c:	00001f2d 	.word	0x00001f2d

00002860 <xTimerGenericCommand>:
{
    2860:	b530      	push	{r4, r5, lr}
    2862:	b085      	sub	sp, #20
    2864:	0004      	movs	r4, r0
    2866:	001d      	movs	r5, r3
	configASSERT(xTimer);
    2868:	2800      	cmp	r0, #0
    286a:	d014      	beq.n	2896 <xTimerGenericCommand+0x36>
	if (xTimerQueue != NULL) {
    286c:	4b13      	ldr	r3, [pc, #76]	; (28bc <xTimerGenericCommand+0x5c>)
    286e:	6898      	ldr	r0, [r3, #8]
    2870:	2800      	cmp	r0, #0
    2872:	d021      	beq.n	28b8 <xTimerGenericCommand+0x58>
		xMessage.xMessageID                       = xCommandID;
    2874:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    2876:	9202      	str	r2, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer       = (Timer_t *)xTimer;
    2878:	9403      	str	r4, [sp, #12]
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    287a:	2905      	cmp	r1, #5
    287c:	dc15      	bgt.n	28aa <xTimerGenericCommand+0x4a>
			if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
    287e:	4b10      	ldr	r3, [pc, #64]	; (28c0 <xTimerGenericCommand+0x60>)
    2880:	4798      	blx	r3
    2882:	2802      	cmp	r0, #2
    2884:	d009      	beq.n	289a <xTimerGenericCommand+0x3a>
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, tmrNO_DELAY);
    2886:	4b0d      	ldr	r3, [pc, #52]	; (28bc <xTimerGenericCommand+0x5c>)
    2888:	6898      	ldr	r0, [r3, #8]
    288a:	2300      	movs	r3, #0
    288c:	2200      	movs	r2, #0
    288e:	a901      	add	r1, sp, #4
    2890:	4c0c      	ldr	r4, [pc, #48]	; (28c4 <xTimerGenericCommand+0x64>)
    2892:	47a0      	blx	r4
    2894:	e00e      	b.n	28b4 <xTimerGenericCommand+0x54>
	configASSERT(xTimer);
    2896:	b672      	cpsid	i
    2898:	e7fe      	b.n	2898 <xTimerGenericCommand+0x38>
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, xTicksToWait);
    289a:	4b08      	ldr	r3, [pc, #32]	; (28bc <xTimerGenericCommand+0x5c>)
    289c:	6898      	ldr	r0, [r3, #8]
    289e:	2300      	movs	r3, #0
    28a0:	9a08      	ldr	r2, [sp, #32]
    28a2:	a901      	add	r1, sp, #4
    28a4:	4c07      	ldr	r4, [pc, #28]	; (28c4 <xTimerGenericCommand+0x64>)
    28a6:	47a0      	blx	r4
    28a8:	e004      	b.n	28b4 <xTimerGenericCommand+0x54>
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    28aa:	2300      	movs	r3, #0
    28ac:	002a      	movs	r2, r5
    28ae:	a901      	add	r1, sp, #4
    28b0:	4c05      	ldr	r4, [pc, #20]	; (28c8 <xTimerGenericCommand+0x68>)
    28b2:	47a0      	blx	r4
}
    28b4:	b005      	add	sp, #20
    28b6:	bd30      	pop	{r4, r5, pc}
	BaseType_t          xReturn = pdFAIL;
    28b8:	2000      	movs	r0, #0
	return xReturn;
    28ba:	e7fb      	b.n	28b4 <xTimerGenericCommand+0x54>
    28bc:	20000ac4 	.word	0x20000ac4
    28c0:	000025ad 	.word	0x000025ad
    28c4:	000018a9 	.word	0x000018a9
    28c8:	00001a61 	.word	0x00001a61

000028cc <prvSampleTimeNow>:
{
    28cc:	b5f0      	push	{r4, r5, r6, r7, lr}
    28ce:	46d6      	mov	lr, sl
    28d0:	464f      	mov	r7, r9
    28d2:	4646      	mov	r6, r8
    28d4:	b5c0      	push	{r6, r7, lr}
    28d6:	b082      	sub	sp, #8
    28d8:	4680      	mov	r8, r0
	xTimeNow = xTaskGetTickCount();
    28da:	4b23      	ldr	r3, [pc, #140]	; (2968 <prvSampleTimeNow+0x9c>)
    28dc:	4798      	blx	r3
    28de:	4682      	mov	sl, r0
	if (xTimeNow < xLastTime) {
    28e0:	4b22      	ldr	r3, [pc, #136]	; (296c <prvSampleTimeNow+0xa0>)
    28e2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    28e4:	4298      	cmp	r0, r3
    28e6:	d317      	bcc.n	2918 <prvSampleTimeNow+0x4c>
		*pxTimerListsWereSwitched = pdFALSE;
    28e8:	2300      	movs	r3, #0
    28ea:	4642      	mov	r2, r8
    28ec:	6013      	str	r3, [r2, #0]
	xLastTime = xTimeNow;
    28ee:	4b1f      	ldr	r3, [pc, #124]	; (296c <prvSampleTimeNow+0xa0>)
    28f0:	4652      	mov	r2, sl
    28f2:	639a      	str	r2, [r3, #56]	; 0x38
}
    28f4:	4650      	mov	r0, sl
    28f6:	b002      	add	sp, #8
    28f8:	bc1c      	pop	{r2, r3, r4}
    28fa:	4690      	mov	r8, r2
    28fc:	4699      	mov	r9, r3
    28fe:	46a2      	mov	sl, r4
    2900:	bdf0      	pop	{r4, r5, r6, r7, pc}
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    2902:	2300      	movs	r3, #0
    2904:	9300      	str	r3, [sp, #0]
    2906:	003a      	movs	r2, r7
    2908:	2100      	movs	r1, #0
    290a:	0020      	movs	r0, r4
    290c:	4c18      	ldr	r4, [pc, #96]	; (2970 <prvSampleTimeNow+0xa4>)
    290e:	47a0      	blx	r4
				configASSERT(xResult);
    2910:	2800      	cmp	r0, #0
    2912:	d104      	bne.n	291e <prvSampleTimeNow+0x52>
    2914:	b672      	cpsid	i
    2916:	e7fe      	b.n	2916 <prvSampleTimeNow+0x4a>
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    2918:	4d14      	ldr	r5, [pc, #80]	; (296c <prvSampleTimeNow+0xa0>)
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    291a:	4b16      	ldr	r3, [pc, #88]	; (2974 <prvSampleTimeNow+0xa8>)
    291c:	4699      	mov	r9, r3
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    291e:	686b      	ldr	r3, [r5, #4]
    2920:	681a      	ldr	r2, [r3, #0]
    2922:	2a00      	cmp	r2, #0
    2924:	d017      	beq.n	2956 <prvSampleTimeNow+0x8a>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    2926:	68db      	ldr	r3, [r3, #12]
    2928:	681f      	ldr	r7, [r3, #0]
		pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    292a:	68dc      	ldr	r4, [r3, #12]
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    292c:	1d26      	adds	r6, r4, #4
    292e:	0030      	movs	r0, r6
    2930:	47c8      	blx	r9
		pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    2932:	0020      	movs	r0, r4
    2934:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2936:	4798      	blx	r3
		if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    2938:	69e3      	ldr	r3, [r4, #28]
    293a:	2b01      	cmp	r3, #1
    293c:	d1ef      	bne.n	291e <prvSampleTimeNow+0x52>
			xReloadTime = (xNextExpireTime + pxTimer->xTimerPeriodInTicks);
    293e:	69a3      	ldr	r3, [r4, #24]
    2940:	18fb      	adds	r3, r7, r3
			if (xReloadTime > xNextExpireTime) {
    2942:	429f      	cmp	r7, r3
    2944:	d2dd      	bcs.n	2902 <prvSampleTimeNow+0x36>
				listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xReloadTime);
    2946:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    2948:	6124      	str	r4, [r4, #16]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    294a:	4b08      	ldr	r3, [pc, #32]	; (296c <prvSampleTimeNow+0xa0>)
    294c:	6858      	ldr	r0, [r3, #4]
    294e:	0031      	movs	r1, r6
    2950:	4b09      	ldr	r3, [pc, #36]	; (2978 <prvSampleTimeNow+0xac>)
    2952:	4798      	blx	r3
    2954:	e7e3      	b.n	291e <prvSampleTimeNow+0x52>
	pxCurrentTimerList  = pxOverflowTimerList;
    2956:	4a05      	ldr	r2, [pc, #20]	; (296c <prvSampleTimeNow+0xa0>)
    2958:	6811      	ldr	r1, [r2, #0]
    295a:	6051      	str	r1, [r2, #4]
	pxOverflowTimerList = pxTemp;
    295c:	6013      	str	r3, [r2, #0]
		*pxTimerListsWereSwitched = pdTRUE;
    295e:	2301      	movs	r3, #1
    2960:	4642      	mov	r2, r8
    2962:	6013      	str	r3, [r2, #0]
    2964:	e7c3      	b.n	28ee <prvSampleTimeNow+0x22>
    2966:	46c0      	nop			; (mov r8, r8)
    2968:	00002171 	.word	0x00002171
    296c:	20000ac4 	.word	0x20000ac4
    2970:	00002861 	.word	0x00002861
    2974:	000013b3 	.word	0x000013b3
    2978:	00001385 	.word	0x00001385

0000297c <prvTimerTask>:
{
    297c:	b5f0      	push	{r4, r5, r6, r7, lr}
    297e:	b089      	sub	sp, #36	; 0x24
				(void)uxListRemove(&(pxTimer->xTimerListItem));
    2980:	4f52      	ldr	r7, [pc, #328]	; (2acc <prvTimerTask+0x150>)
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
    2982:	4b53      	ldr	r3, [pc, #332]	; (2ad0 <prvTimerTask+0x154>)
    2984:	685b      	ldr	r3, [r3, #4]
    2986:	681a      	ldr	r2, [r3, #0]
	if (*pxListWasEmpty == pdFALSE) {
    2988:	2a00      	cmp	r2, #0
    298a:	d00e      	beq.n	29aa <prvTimerTask+0x2e>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    298c:	68db      	ldr	r3, [r3, #12]
    298e:	681c      	ldr	r4, [r3, #0]
	vTaskSuspendAll();
    2990:	4b50      	ldr	r3, [pc, #320]	; (2ad4 <prvTimerTask+0x158>)
    2992:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    2994:	a805      	add	r0, sp, #20
    2996:	4b50      	ldr	r3, [pc, #320]	; (2ad8 <prvTimerTask+0x15c>)
    2998:	4798      	blx	r3
    299a:	0005      	movs	r5, r0
		if (xTimerListsWereSwitched == pdFALSE) {
    299c:	9b05      	ldr	r3, [sp, #20]
    299e:	2b00      	cmp	r3, #0
    29a0:	d15f      	bne.n	2a62 <prvTimerTask+0xe6>
			if ((xListWasEmpty == pdFALSE) && (xNextExpireTime <= xTimeNow)) {
    29a2:	42a0      	cmp	r0, r4
    29a4:	d236      	bcs.n	2a14 <prvTimerTask+0x98>
    29a6:	2200      	movs	r2, #0
    29a8:	e00f      	b.n	29ca <prvTimerTask+0x4e>
	vTaskSuspendAll();
    29aa:	4b4a      	ldr	r3, [pc, #296]	; (2ad4 <prvTimerTask+0x158>)
    29ac:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    29ae:	a805      	add	r0, sp, #20
    29b0:	4b49      	ldr	r3, [pc, #292]	; (2ad8 <prvTimerTask+0x15c>)
    29b2:	4798      	blx	r3
    29b4:	0005      	movs	r5, r0
		if (xTimerListsWereSwitched == pdFALSE) {
    29b6:	9b05      	ldr	r3, [sp, #20]
    29b8:	2b00      	cmp	r3, #0
    29ba:	d152      	bne.n	2a62 <prvTimerTask+0xe6>
					xListWasEmpty = listLIST_IS_EMPTY(pxOverflowTimerList);
    29bc:	4b44      	ldr	r3, [pc, #272]	; (2ad0 <prvTimerTask+0x154>)
    29be:	681b      	ldr	r3, [r3, #0]
    29c0:	681b      	ldr	r3, [r3, #0]
    29c2:	425a      	negs	r2, r3
    29c4:	415a      	adcs	r2, r3
    29c6:	b2d2      	uxtb	r2, r2
    29c8:	2400      	movs	r4, #0
				vQueueWaitForMessageRestricted(xTimerQueue, (xNextExpireTime - xTimeNow), xListWasEmpty);
    29ca:	1b61      	subs	r1, r4, r5
    29cc:	4b40      	ldr	r3, [pc, #256]	; (2ad0 <prvTimerTask+0x154>)
    29ce:	6898      	ldr	r0, [r3, #8]
    29d0:	4b42      	ldr	r3, [pc, #264]	; (2adc <prvTimerTask+0x160>)
    29d2:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    29d4:	4b42      	ldr	r3, [pc, #264]	; (2ae0 <prvTimerTask+0x164>)
    29d6:	4798      	blx	r3
    29d8:	2800      	cmp	r0, #0
    29da:	d03f      	beq.n	2a5c <prvTimerTask+0xe0>
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    29dc:	4d3c      	ldr	r5, [pc, #240]	; (2ad0 <prvTimerTask+0x154>)
    29de:	4c41      	ldr	r4, [pc, #260]	; (2ae4 <prvTimerTask+0x168>)
    29e0:	2200      	movs	r2, #0
    29e2:	a905      	add	r1, sp, #20
    29e4:	68a8      	ldr	r0, [r5, #8]
    29e6:	47a0      	blx	r4
    29e8:	2800      	cmp	r0, #0
    29ea:	d0ca      	beq.n	2982 <prvTimerTask+0x6>
		if (xMessage.xMessageID >= (BaseType_t)0) {
    29ec:	9b05      	ldr	r3, [sp, #20]
    29ee:	9303      	str	r3, [sp, #12]
    29f0:	2b00      	cmp	r3, #0
    29f2:	dbf5      	blt.n	29e0 <prvTimerTask+0x64>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    29f4:	9e07      	ldr	r6, [sp, #28]
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTimer->xTimerListItem))
    29f6:	6973      	ldr	r3, [r6, #20]
    29f8:	2b00      	cmp	r3, #0
    29fa:	d001      	beq.n	2a00 <prvTimerTask+0x84>
				(void)uxListRemove(&(pxTimer->xTimerListItem));
    29fc:	1d30      	adds	r0, r6, #4
    29fe:	47b8      	blx	r7
			xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    2a00:	a804      	add	r0, sp, #16
    2a02:	4b35      	ldr	r3, [pc, #212]	; (2ad8 <prvTimerTask+0x15c>)
    2a04:	4798      	blx	r3
			switch (xMessage.xMessageID) {
    2a06:	9b05      	ldr	r3, [sp, #20]
    2a08:	2b09      	cmp	r3, #9
    2a0a:	d8e9      	bhi.n	29e0 <prvTimerTask+0x64>
    2a0c:	009b      	lsls	r3, r3, #2
    2a0e:	4a36      	ldr	r2, [pc, #216]	; (2ae8 <prvTimerTask+0x16c>)
    2a10:	58d3      	ldr	r3, [r2, r3]
    2a12:	469f      	mov	pc, r3
				(void)xTaskResumeAll();
    2a14:	4b32      	ldr	r3, [pc, #200]	; (2ae0 <prvTimerTask+0x164>)
    2a16:	4798      	blx	r3
	Timer_t *const pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    2a18:	4b2d      	ldr	r3, [pc, #180]	; (2ad0 <prvTimerTask+0x154>)
    2a1a:	685b      	ldr	r3, [r3, #4]
    2a1c:	68db      	ldr	r3, [r3, #12]
    2a1e:	68de      	ldr	r6, [r3, #12]
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    2a20:	1d30      	adds	r0, r6, #4
    2a22:	4b2a      	ldr	r3, [pc, #168]	; (2acc <prvTimerTask+0x150>)
    2a24:	4798      	blx	r3
	if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    2a26:	69f3      	ldr	r3, [r6, #28]
    2a28:	2b01      	cmp	r3, #1
    2a2a:	d003      	beq.n	2a34 <prvTimerTask+0xb8>
	pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    2a2c:	6a73      	ldr	r3, [r6, #36]	; 0x24
    2a2e:	0030      	movs	r0, r6
    2a30:	4798      	blx	r3
    2a32:	e7d3      	b.n	29dc <prvTimerTask+0x60>
		if (prvInsertTimerInActiveList(
    2a34:	69b3      	ldr	r3, [r6, #24]
    2a36:	18e1      	adds	r1, r4, r3
    2a38:	0023      	movs	r3, r4
    2a3a:	002a      	movs	r2, r5
    2a3c:	0030      	movs	r0, r6
    2a3e:	4d2b      	ldr	r5, [pc, #172]	; (2aec <prvTimerTask+0x170>)
    2a40:	47a8      	blx	r5
    2a42:	2800      	cmp	r0, #0
    2a44:	d0f2      	beq.n	2a2c <prvTimerTask+0xb0>
			xResult = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    2a46:	2300      	movs	r3, #0
    2a48:	9300      	str	r3, [sp, #0]
    2a4a:	0022      	movs	r2, r4
    2a4c:	2100      	movs	r1, #0
    2a4e:	0030      	movs	r0, r6
    2a50:	4c27      	ldr	r4, [pc, #156]	; (2af0 <prvTimerTask+0x174>)
    2a52:	47a0      	blx	r4
			configASSERT(xResult);
    2a54:	2800      	cmp	r0, #0
    2a56:	d1e9      	bne.n	2a2c <prvTimerTask+0xb0>
    2a58:	b672      	cpsid	i
    2a5a:	e7fe      	b.n	2a5a <prvTimerTask+0xde>
					portYIELD_WITHIN_API();
    2a5c:	4b25      	ldr	r3, [pc, #148]	; (2af4 <prvTimerTask+0x178>)
    2a5e:	4798      	blx	r3
    2a60:	e7bc      	b.n	29dc <prvTimerTask+0x60>
			(void)xTaskResumeAll();
    2a62:	4b1f      	ldr	r3, [pc, #124]	; (2ae0 <prvTimerTask+0x164>)
    2a64:	4798      	blx	r3
    2a66:	e7b9      	b.n	29dc <prvTimerTask+0x60>
				if (prvInsertTimerInActiveList(pxTimer,
    2a68:	9b06      	ldr	r3, [sp, #24]
    2a6a:	69b2      	ldr	r2, [r6, #24]
    2a6c:	4694      	mov	ip, r2
    2a6e:	4463      	add	r3, ip
    2a70:	0019      	movs	r1, r3
    2a72:	9b06      	ldr	r3, [sp, #24]
    2a74:	0002      	movs	r2, r0
    2a76:	0030      	movs	r0, r6
    2a78:	4c1c      	ldr	r4, [pc, #112]	; (2aec <prvTimerTask+0x170>)
    2a7a:	47a0      	blx	r4
    2a7c:	2800      	cmp	r0, #0
    2a7e:	d0ae      	beq.n	29de <prvTimerTask+0x62>
					pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    2a80:	0030      	movs	r0, r6
    2a82:	6a73      	ldr	r3, [r6, #36]	; 0x24
    2a84:	4798      	blx	r3
					if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    2a86:	69f3      	ldr	r3, [r6, #28]
    2a88:	2b01      	cmp	r3, #1
    2a8a:	d1a8      	bne.n	29de <prvTimerTask+0x62>
						xResult = xTimerGenericCommand(pxTimer,
    2a8c:	9b06      	ldr	r3, [sp, #24]
    2a8e:	69b1      	ldr	r1, [r6, #24]
    2a90:	468c      	mov	ip, r1
    2a92:	4463      	add	r3, ip
    2a94:	001a      	movs	r2, r3
    2a96:	2300      	movs	r3, #0
    2a98:	9300      	str	r3, [sp, #0]
    2a9a:	2100      	movs	r1, #0
    2a9c:	0030      	movs	r0, r6
    2a9e:	4c14      	ldr	r4, [pc, #80]	; (2af0 <prvTimerTask+0x174>)
    2aa0:	47a0      	blx	r4
						configASSERT(xResult);
    2aa2:	2800      	cmp	r0, #0
    2aa4:	d19b      	bne.n	29de <prvTimerTask+0x62>
    2aa6:	b672      	cpsid	i
    2aa8:	e7fe      	b.n	2aa8 <prvTimerTask+0x12c>
				pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2aaa:	9906      	ldr	r1, [sp, #24]
    2aac:	61b1      	str	r1, [r6, #24]
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
    2aae:	2900      	cmp	r1, #0
    2ab0:	d006      	beq.n	2ac0 <prvTimerTask+0x144>
				(void)prvInsertTimerInActiveList(
    2ab2:	1841      	adds	r1, r0, r1
    2ab4:	0003      	movs	r3, r0
    2ab6:	0002      	movs	r2, r0
    2ab8:	0030      	movs	r0, r6
    2aba:	4c0c      	ldr	r4, [pc, #48]	; (2aec <prvTimerTask+0x170>)
    2abc:	47a0      	blx	r4
    2abe:	e78e      	b.n	29de <prvTimerTask+0x62>
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
    2ac0:	b672      	cpsid	i
    2ac2:	e7fe      	b.n	2ac2 <prvTimerTask+0x146>
				vPortFree(pxTimer);
    2ac4:	0030      	movs	r0, r6
    2ac6:	4b0c      	ldr	r3, [pc, #48]	; (2af8 <prvTimerTask+0x17c>)
    2ac8:	4798      	blx	r3
    2aca:	e788      	b.n	29de <prvTimerTask+0x62>
    2acc:	000013b3 	.word	0x000013b3
    2ad0:	20000ac4 	.word	0x20000ac4
    2ad4:	00002161 	.word	0x00002161
    2ad8:	000028cd 	.word	0x000028cd
    2adc:	00001e1d 	.word	0x00001e1d
    2ae0:	00002289 	.word	0x00002289
    2ae4:	00001b31 	.word	0x00001b31
    2ae8:	00002c54 	.word	0x00002c54
    2aec:	00002785 	.word	0x00002785
    2af0:	00002861 	.word	0x00002861
    2af4:	000014bd 	.word	0x000014bd
    2af8:	000015fd 	.word	0x000015fd

00002afc <__libc_init_array>:
    2afc:	b570      	push	{r4, r5, r6, lr}
    2afe:	2600      	movs	r6, #0
    2b00:	4d0c      	ldr	r5, [pc, #48]	; (2b34 <__libc_init_array+0x38>)
    2b02:	4c0d      	ldr	r4, [pc, #52]	; (2b38 <__libc_init_array+0x3c>)
    2b04:	1b64      	subs	r4, r4, r5
    2b06:	10a4      	asrs	r4, r4, #2
    2b08:	42a6      	cmp	r6, r4
    2b0a:	d109      	bne.n	2b20 <__libc_init_array+0x24>
    2b0c:	2600      	movs	r6, #0
    2b0e:	f000 f8b9 	bl	2c84 <_init>
    2b12:	4d0a      	ldr	r5, [pc, #40]	; (2b3c <__libc_init_array+0x40>)
    2b14:	4c0a      	ldr	r4, [pc, #40]	; (2b40 <__libc_init_array+0x44>)
    2b16:	1b64      	subs	r4, r4, r5
    2b18:	10a4      	asrs	r4, r4, #2
    2b1a:	42a6      	cmp	r6, r4
    2b1c:	d105      	bne.n	2b2a <__libc_init_array+0x2e>
    2b1e:	bd70      	pop	{r4, r5, r6, pc}
    2b20:	00b3      	lsls	r3, r6, #2
    2b22:	58eb      	ldr	r3, [r5, r3]
    2b24:	4798      	blx	r3
    2b26:	3601      	adds	r6, #1
    2b28:	e7ee      	b.n	2b08 <__libc_init_array+0xc>
    2b2a:	00b3      	lsls	r3, r6, #2
    2b2c:	58eb      	ldr	r3, [r5, r3]
    2b2e:	4798      	blx	r3
    2b30:	3601      	adds	r6, #1
    2b32:	e7f2      	b.n	2b1a <__libc_init_array+0x1e>
    2b34:	00002c90 	.word	0x00002c90
    2b38:	00002c90 	.word	0x00002c90
    2b3c:	00002c90 	.word	0x00002c90
    2b40:	00002c94 	.word	0x00002c94

00002b44 <memcpy>:
    2b44:	2300      	movs	r3, #0
    2b46:	b510      	push	{r4, lr}
    2b48:	429a      	cmp	r2, r3
    2b4a:	d100      	bne.n	2b4e <memcpy+0xa>
    2b4c:	bd10      	pop	{r4, pc}
    2b4e:	5ccc      	ldrb	r4, [r1, r3]
    2b50:	54c4      	strb	r4, [r0, r3]
    2b52:	3301      	adds	r3, #1
    2b54:	e7f8      	b.n	2b48 <memcpy+0x4>

00002b56 <memset>:
    2b56:	0003      	movs	r3, r0
    2b58:	1882      	adds	r2, r0, r2
    2b5a:	4293      	cmp	r3, r2
    2b5c:	d100      	bne.n	2b60 <memset+0xa>
    2b5e:	4770      	bx	lr
    2b60:	7019      	strb	r1, [r3, #0]
    2b62:	3301      	adds	r3, #1
    2b64:	e7f9      	b.n	2b5a <memset+0x4>
    2b66:	0000      	movs	r0, r0
    2b68:	682f2e2e 	.word	0x682f2e2e
    2b6c:	732f6c61 	.word	0x732f6c61
    2b70:	682f6372 	.word	0x682f6372
    2b74:	695f6c61 	.word	0x695f6c61
    2b78:	00632e6f 	.word	0x00632e6f
    2b7c:	682f2e2e 	.word	0x682f2e2e
    2b80:	732f6c61 	.word	0x732f6c61
    2b84:	682f6372 	.word	0x682f6372
    2b88:	735f6c61 	.word	0x735f6c61
    2b8c:	735f6970 	.word	0x735f6970
    2b90:	7973615f 	.word	0x7973615f
    2b94:	632e636e 	.word	0x632e636e
    2b98:	00000000 	.word	0x00000000
    2b9c:	682f2e2e 	.word	0x682f2e2e
    2ba0:	732f6c61 	.word	0x732f6c61
    2ba4:	682f6372 	.word	0x682f6372
    2ba8:	755f6c61 	.word	0x755f6c61
    2bac:	74726173 	.word	0x74726173
    2bb0:	7973615f 	.word	0x7973615f
    2bb4:	632e636e 	.word	0x632e636e
    2bb8:	00000000 	.word	0x00000000
    2bbc:	682f2e2e 	.word	0x682f2e2e
    2bc0:	752f6c61 	.word	0x752f6c61
    2bc4:	736c6974 	.word	0x736c6974
    2bc8:	6372732f 	.word	0x6372732f
    2bcc:	6974752f 	.word	0x6974752f
    2bd0:	725f736c 	.word	0x725f736c
    2bd4:	62676e69 	.word	0x62676e69
    2bd8:	65666675 	.word	0x65666675
    2bdc:	00632e72 	.word	0x00632e72
    2be0:	42000400 	.word	0x42000400
    2be4:	42000800 	.word	0x42000800
    2be8:	42000c00 	.word	0x42000c00
    2bec:	42001000 	.word	0x42001000
    2bf0:	42001400 	.word	0x42001400
    2bf4:	42001800 	.word	0x42001800
    2bf8:	43000000 	.word	0x43000000
    2bfc:	43000400 	.word	0x43000400

00002c00 <_i2cms>:
	...
    2c18:	682f2e2e 732f6c70 6f637265 70682f6d     ../hpl/sercom/hp
    2c28:	65735f6c 6d6f6372 0000632e 50425355     l_sercom.c..USBP
    2c38:	0054524f 454c4449 00000000 09632509     ORT.IDLE.....%c.
    2c48:	25097525 75250975 00000a0d 00002a68     %u.%u.%u....h*..
    2c58:	00002a68 00002a68 000029e0 00002aaa     h*..h*...)...*..
    2c68:	00002ac4 00002a68 00002a68 000029e0     .*..h*..h*...)..
    2c78:	00002aaa 20726d54 00637653              .*..Tmr Svc.

00002c84 <_init>:
    2c84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2c86:	46c0      	nop			; (mov r8, r8)
    2c88:	bcf8      	pop	{r3, r4, r5, r6, r7}
    2c8a:	bc08      	pop	{r3}
    2c8c:	469e      	mov	lr, r3
    2c8e:	4770      	bx	lr

00002c90 <__init_array_start>:
    2c90:	000000e5 	.word	0x000000e5

00002c94 <_fini>:
    2c94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2c96:	46c0      	nop			; (mov r8, r8)
    2c98:	bcf8      	pop	{r3, r4, r5, r6, r7}
    2c9a:	bc08      	pop	{r3}
    2c9c:	469e      	mov	lr, r3
    2c9e:	4770      	bx	lr

00002ca0 <__fini_array_start>:
    2ca0:	000000bd 	.word	0x000000bd
