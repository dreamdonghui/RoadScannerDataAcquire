
RoadScannerDataAcquire.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002554  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000010  20000000  00002554  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000b18  20000010  00002564  00020010  2**2
                  ALLOC
  3 .stack        00002000  20000b28  0000307c  00020010  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00020010  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020038  2**0
                  CONTENTS, READONLY
  6 .debug_info   0001e394  00000000  00000000  00020091  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000374a  00000000  00000000  0003e425  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000ee86  00000000  00000000  00041b6f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000db0  00000000  00000000  000509f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00001448  00000000  00000000  000517a5  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  000210c9  00000000  00000000  00052bed  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00014841  00000000  00000000  00073cb6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000a6c46  00000000  00000000  000884f7  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00002354  00000000  00000000  0012f140  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	28 2b 00 20 2d 01 00 00 29 01 00 00 29 01 00 00     (+. -...)...)...
	...
      2c:	25 0d 00 00 00 00 00 00 00 00 00 00 f1 0d 00 00     %...............
      3c:	35 0e 00 00 29 01 00 00 29 01 00 00 29 01 00 00     5...)...)...)...
      4c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
      5c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
      6c:	29 01 00 00 29 01 00 00 89 0a 00 00 29 01 00 00     )...).......)...
      7c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
      8c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
      9c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
      ac:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...

000000bc <__do_global_dtors_aux>:
      bc:	b510      	push	{r4, lr}
      be:	4c06      	ldr	r4, [pc, #24]	; (d8 <__do_global_dtors_aux+0x1c>)
      c0:	7823      	ldrb	r3, [r4, #0]
      c2:	2b00      	cmp	r3, #0
      c4:	d107      	bne.n	d6 <__do_global_dtors_aux+0x1a>
      c6:	4b05      	ldr	r3, [pc, #20]	; (dc <__do_global_dtors_aux+0x20>)
      c8:	2b00      	cmp	r3, #0
      ca:	d002      	beq.n	d2 <__do_global_dtors_aux+0x16>
      cc:	4804      	ldr	r0, [pc, #16]	; (e0 <__do_global_dtors_aux+0x24>)
      ce:	e000      	b.n	d2 <__do_global_dtors_aux+0x16>
      d0:	bf00      	nop
      d2:	2301      	movs	r3, #1
      d4:	7023      	strb	r3, [r4, #0]
      d6:	bd10      	pop	{r4, pc}
      d8:	20000010 	.word	0x20000010
      dc:	00000000 	.word	0x00000000
      e0:	00002554 	.word	0x00002554

000000e4 <frame_dummy>:
      e4:	4b08      	ldr	r3, [pc, #32]	; (108 <frame_dummy+0x24>)
      e6:	b510      	push	{r4, lr}
      e8:	2b00      	cmp	r3, #0
      ea:	d003      	beq.n	f4 <frame_dummy+0x10>
      ec:	4907      	ldr	r1, [pc, #28]	; (10c <frame_dummy+0x28>)
      ee:	4808      	ldr	r0, [pc, #32]	; (110 <frame_dummy+0x2c>)
      f0:	e000      	b.n	f4 <frame_dummy+0x10>
      f2:	bf00      	nop
      f4:	4807      	ldr	r0, [pc, #28]	; (114 <frame_dummy+0x30>)
      f6:	6803      	ldr	r3, [r0, #0]
      f8:	2b00      	cmp	r3, #0
      fa:	d100      	bne.n	fe <frame_dummy+0x1a>
      fc:	bd10      	pop	{r4, pc}
      fe:	4b06      	ldr	r3, [pc, #24]	; (118 <frame_dummy+0x34>)
     100:	2b00      	cmp	r3, #0
     102:	d0fb      	beq.n	fc <frame_dummy+0x18>
     104:	4798      	blx	r3
     106:	e7f9      	b.n	fc <frame_dummy+0x18>
     108:	00000000 	.word	0x00000000
     10c:	20000014 	.word	0x20000014
     110:	00002554 	.word	0x00002554
     114:	00002554 	.word	0x00002554
     118:	00000000 	.word	0x00000000

0000011c <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     11c:	b510      	push	{r4, lr}
	system_init();
     11e:	4b01      	ldr	r3, [pc, #4]	; (124 <atmel_start_init+0x8>)
     120:	4798      	blx	r3
}
     122:	bd10      	pop	{r4, pc}
     124:	00000265 	.word	0x00000265

00000128 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     128:	e7fe      	b.n	128 <Dummy_Handler>
	...

0000012c <Reset_Handler>:
{
     12c:	b510      	push	{r4, lr}
        if (pSrc != pDest) {
     12e:	4a17      	ldr	r2, [pc, #92]	; (18c <Reset_Handler+0x60>)
     130:	4b17      	ldr	r3, [pc, #92]	; (190 <Reset_Handler+0x64>)
     132:	429a      	cmp	r2, r3
     134:	d011      	beq.n	15a <Reset_Handler+0x2e>
                for (; pDest < &_erelocate;) {
     136:	001a      	movs	r2, r3
     138:	4b16      	ldr	r3, [pc, #88]	; (194 <Reset_Handler+0x68>)
     13a:	429a      	cmp	r2, r3
     13c:	d20d      	bcs.n	15a <Reset_Handler+0x2e>
     13e:	4a16      	ldr	r2, [pc, #88]	; (198 <Reset_Handler+0x6c>)
     140:	3303      	adds	r3, #3
     142:	1a9b      	subs	r3, r3, r2
     144:	089b      	lsrs	r3, r3, #2
     146:	3301      	adds	r3, #1
     148:	009b      	lsls	r3, r3, #2
     14a:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
     14c:	4810      	ldr	r0, [pc, #64]	; (190 <Reset_Handler+0x64>)
     14e:	490f      	ldr	r1, [pc, #60]	; (18c <Reset_Handler+0x60>)
     150:	588c      	ldr	r4, [r1, r2]
     152:	5084      	str	r4, [r0, r2]
     154:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     156:	429a      	cmp	r2, r3
     158:	d1fa      	bne.n	150 <Reset_Handler+0x24>
        for (pDest = &_szero; pDest < &_ezero;) {
     15a:	4a10      	ldr	r2, [pc, #64]	; (19c <Reset_Handler+0x70>)
     15c:	4b10      	ldr	r3, [pc, #64]	; (1a0 <Reset_Handler+0x74>)
     15e:	429a      	cmp	r2, r3
     160:	d20a      	bcs.n	178 <Reset_Handler+0x4c>
     162:	43d3      	mvns	r3, r2
     164:	490e      	ldr	r1, [pc, #56]	; (1a0 <Reset_Handler+0x74>)
     166:	185b      	adds	r3, r3, r1
     168:	2103      	movs	r1, #3
     16a:	438b      	bics	r3, r1
     16c:	3304      	adds	r3, #4
     16e:	189b      	adds	r3, r3, r2
                *pDest++ = 0;
     170:	2100      	movs	r1, #0
     172:	c202      	stmia	r2!, {r1}
        for (pDest = &_szero; pDest < &_ezero;) {
     174:	4293      	cmp	r3, r2
     176:	d1fc      	bne.n	172 <Reset_Handler+0x46>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     178:	4a0a      	ldr	r2, [pc, #40]	; (1a4 <Reset_Handler+0x78>)
     17a:	21ff      	movs	r1, #255	; 0xff
     17c:	4b0a      	ldr	r3, [pc, #40]	; (1a8 <Reset_Handler+0x7c>)
     17e:	438b      	bics	r3, r1
     180:	6093      	str	r3, [r2, #8]
        __libc_init_array();
     182:	4b0a      	ldr	r3, [pc, #40]	; (1ac <Reset_Handler+0x80>)
     184:	4798      	blx	r3
        main();
     186:	4b0a      	ldr	r3, [pc, #40]	; (1b0 <Reset_Handler+0x84>)
     188:	4798      	blx	r3
     18a:	e7fe      	b.n	18a <Reset_Handler+0x5e>
     18c:	00002554 	.word	0x00002554
     190:	20000000 	.word	0x20000000
     194:	20000010 	.word	0x20000010
     198:	20000004 	.word	0x20000004
     19c:	20000010 	.word	0x20000010
     1a0:	20000b28 	.word	0x20000b28
     1a4:	e000ed00 	.word	0xe000ed00
     1a8:	00000000 	.word	0x00000000
     1ac:	000023cd 	.word	0x000023cd
     1b0:	00000b5d 	.word	0x00000b5d

000001b4 <USART_On_USBPort_CLOCK_init>:
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
     1b4:	4b06      	ldr	r3, [pc, #24]	; (1d0 <USART_On_USBPort_CLOCK_init+0x1c>)
     1b6:	2140      	movs	r1, #64	; 0x40
     1b8:	22dc      	movs	r2, #220	; 0xdc
     1ba:	5099      	str	r1, [r3, r2]
     1bc:	3103      	adds	r1, #3
     1be:	3a14      	subs	r2, #20
     1c0:	5099      	str	r1, [r3, r2]
}

static inline void hri_mclk_set_APBCMASK_SERCOM4_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_SERCOM4;
     1c2:	4a04      	ldr	r2, [pc, #16]	; (1d4 <USART_On_USBPort_CLOCK_init+0x20>)
     1c4:	69d3      	ldr	r3, [r2, #28]
     1c6:	3923      	subs	r1, #35	; 0x23
     1c8:	430b      	orrs	r3, r1
     1ca:	61d3      	str	r3, [r2, #28]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM4_GCLK_ID_CORE, CONF_GCLK_SERCOM4_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM4_GCLK_ID_SLOW, CONF_GCLK_SERCOM4_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBCMASK_SERCOM4_bit(MCLK);
}
     1cc:	4770      	bx	lr
     1ce:	46c0      	nop			; (mov r8, r8)
     1d0:	40001c00 	.word	0x40001c00
     1d4:	40000800 	.word	0x40000800

000001d8 <USART_On_USBPort_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_On_USBPort_PORT_init()
{
     1d8:	b530      	push	{r4, r5, lr}
static inline void hri_port_write_PINCFG_PMUXEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                    bool value)
{
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     1da:	2382      	movs	r3, #130	; 0x82
     1dc:	05db      	lsls	r3, r3, #23
     1de:	22ca      	movs	r2, #202	; 0xca
     1e0:	5c99      	ldrb	r1, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
     1e2:	2501      	movs	r5, #1
     1e4:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     1e6:	2401      	movs	r4, #1
     1e8:	4321      	orrs	r1, r4
     1ea:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     1ec:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     1ee:	20b5      	movs	r0, #181	; 0xb5
     1f0:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     1f2:	3abb      	subs	r2, #187	; 0xbb
     1f4:	4391      	bics	r1, r2
	tmp |= PORT_PMUX_PMUXE(data);
     1f6:	3a0c      	subs	r2, #12
     1f8:	4311      	orrs	r1, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     1fa:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     1fc:	21cb      	movs	r1, #203	; 0xcb
     1fe:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     200:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     202:	4322      	orrs	r2, r4
     204:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     206:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     208:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     20a:	39bc      	subs	r1, #188	; 0xbc
     20c:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
     20e:	3121      	adds	r1, #33	; 0x21
     210:	430a      	orrs	r2, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     212:	541a      	strb	r2, [r3, r0]

	gpio_set_pin_function(PB10, PINMUX_PB10D_SERCOM4_PAD2);

	gpio_set_pin_function(PB11, PINMUX_PB11D_SERCOM4_PAD3);
}
     214:	bd30      	pop	{r4, r5, pc}
	...

00000218 <USART_On_USBPort_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_On_USBPort_init(void)
{
     218:	b510      	push	{r4, lr}
     21a:	b082      	sub	sp, #8
	USART_On_USBPort_CLOCK_init();
     21c:	4b06      	ldr	r3, [pc, #24]	; (238 <USART_On_USBPort_init+0x20>)
     21e:	4798      	blx	r3
	usart_async_init(&USART_On_USBPort, SERCOM4, USART_On_USBPort_buffer, USART_ON_USBPORT_BUFFER_SIZE, (void *)NULL);
     220:	2300      	movs	r3, #0
     222:	9300      	str	r3, [sp, #0]
     224:	3310      	adds	r3, #16
     226:	4a05      	ldr	r2, [pc, #20]	; (23c <USART_On_USBPort_init+0x24>)
     228:	4905      	ldr	r1, [pc, #20]	; (240 <USART_On_USBPort_init+0x28>)
     22a:	4806      	ldr	r0, [pc, #24]	; (244 <USART_On_USBPort_init+0x2c>)
     22c:	4c06      	ldr	r4, [pc, #24]	; (248 <USART_On_USBPort_init+0x30>)
     22e:	47a0      	blx	r4
	USART_On_USBPort_PORT_init();
     230:	4b06      	ldr	r3, [pc, #24]	; (24c <USART_On_USBPort_init+0x34>)
     232:	4798      	blx	r3
}
     234:	b002      	add	sp, #8
     236:	bd10      	pop	{r4, pc}
     238:	000001b5 	.word	0x000001b5
     23c:	2000002c 	.word	0x2000002c
     240:	42001400 	.word	0x42001400
     244:	20000ad8 	.word	0x20000ad8
     248:	00000515 	.word	0x00000515
     24c:	000001d9 	.word	0x000001d9

00000250 <delay_driver_init>:

void delay_driver_init(void)
{
     250:	b510      	push	{r4, lr}
	delay_init(SysTick);
     252:	4802      	ldr	r0, [pc, #8]	; (25c <delay_driver_init+0xc>)
     254:	4b02      	ldr	r3, [pc, #8]	; (260 <delay_driver_init+0x10>)
     256:	4798      	blx	r3
}
     258:	bd10      	pop	{r4, pc}
     25a:	46c0      	nop			; (mov r8, r8)
     25c:	e000e010 	.word	0xe000e010
     260:	000002e9 	.word	0x000002e9

00000264 <system_init>:

void system_init(void)
{
     264:	b510      	push	{r4, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
     266:	4b03      	ldr	r3, [pc, #12]	; (274 <system_init+0x10>)
     268:	4798      	blx	r3
	init_mcu();

	USART_On_USBPort_init();
     26a:	4b03      	ldr	r3, [pc, #12]	; (278 <system_init+0x14>)
     26c:	4798      	blx	r3

	delay_driver_init();
     26e:	4b03      	ldr	r3, [pc, #12]	; (27c <system_init+0x18>)
     270:	4798      	blx	r3
}
     272:	bd10      	pop	{r4, pc}
     274:	0000078d 	.word	0x0000078d
     278:	00000219 	.word	0x00000219
     27c:	00000251 	.word	0x00000251

00000280 <tx_cb_USART_On_USBPort>:
static uint8_t example_USART_On_USBPort[12] = "Hello World!";

static void tx_cb_USART_On_USBPort(const struct usart_async_descriptor *const io_descr)
{
	/* Transfer completed */
}
     280:	4770      	bx	lr
	...

00000284 <USART_On_USBPort_example>:

void USART_On_USBPort_example(void)
{
     284:	b510      	push	{r4, lr}
     286:	b082      	sub	sp, #8
	struct io_descriptor *io;

	usart_async_register_callback(&USART_On_USBPort, USART_ASYNC_TXC_CB, tx_cb_USART_On_USBPort);
     288:	4c09      	ldr	r4, [pc, #36]	; (2b0 <USART_On_USBPort_example+0x2c>)
     28a:	4a0a      	ldr	r2, [pc, #40]	; (2b4 <USART_On_USBPort_example+0x30>)
     28c:	2101      	movs	r1, #1
     28e:	0020      	movs	r0, r4
     290:	4b09      	ldr	r3, [pc, #36]	; (2b8 <USART_On_USBPort_example+0x34>)
     292:	4798      	blx	r3
	/*usart_async_register_callback(&USART_On_USBPort, USART_ASYNC_RXC_CB, rx_cb);
	usart_async_register_callback(&USART_On_USBPort, USART_ASYNC_ERROR_CB, err_cb);*/
	usart_async_get_io_descriptor(&USART_On_USBPort, &io);
     294:	a901      	add	r1, sp, #4
     296:	0020      	movs	r0, r4
     298:	4b08      	ldr	r3, [pc, #32]	; (2bc <USART_On_USBPort_example+0x38>)
     29a:	4798      	blx	r3
	usart_async_enable(&USART_On_USBPort);
     29c:	0020      	movs	r0, r4
     29e:	4b08      	ldr	r3, [pc, #32]	; (2c0 <USART_On_USBPort_example+0x3c>)
     2a0:	4798      	blx	r3

	io_write(io, example_USART_On_USBPort, 12);
     2a2:	220c      	movs	r2, #12
     2a4:	4907      	ldr	r1, [pc, #28]	; (2c4 <USART_On_USBPort_example+0x40>)
     2a6:	9801      	ldr	r0, [sp, #4]
     2a8:	4b07      	ldr	r3, [pc, #28]	; (2c8 <USART_On_USBPort_example+0x44>)
     2aa:	4798      	blx	r3
}
     2ac:	b002      	add	sp, #8
     2ae:	bd10      	pop	{r4, pc}
     2b0:	20000ad8 	.word	0x20000ad8
     2b4:	00000281 	.word	0x00000281
     2b8:	00000605 	.word	0x00000605
     2bc:	000005d9 	.word	0x000005d9
     2c0:	000005ad 	.word	0x000005ad
     2c4:	20000000 	.word	0x20000000
     2c8:	0000031d 	.word	0x0000031d

000002cc <atomic_enter_critical>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
     2cc:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
     2d0:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
     2d2:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
     2d4:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
     2d8:	4770      	bx	lr

000002da <atomic_leave_critical>:
     2da:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
     2de:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
     2e0:	f383 8810 	msr	PRIMASK, r3
}
     2e4:	4770      	bx	lr
	...

000002e8 <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
     2e8:	b510      	push	{r4, lr}
	_delay_init(hardware = hw);
     2ea:	4b02      	ldr	r3, [pc, #8]	; (2f4 <delay_init+0xc>)
     2ec:	6018      	str	r0, [r3, #0]
     2ee:	4b02      	ldr	r3, [pc, #8]	; (2f8 <delay_init+0x10>)
     2f0:	4798      	blx	r3
}
     2f2:	bd10      	pop	{r4, pc}
     2f4:	2000003c 	.word	0x2000003c
     2f8:	00000af5 	.word	0x00000af5

000002fc <delay_ms>:

/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
     2fc:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
     2fe:	4b04      	ldr	r3, [pc, #16]	; (310 <delay_ms+0x14>)
     300:	681c      	ldr	r4, [r3, #0]
     302:	4b04      	ldr	r3, [pc, #16]	; (314 <delay_ms+0x18>)
     304:	4798      	blx	r3
     306:	0001      	movs	r1, r0
     308:	0020      	movs	r0, r4
     30a:	4b03      	ldr	r3, [pc, #12]	; (318 <delay_ms+0x1c>)
     30c:	4798      	blx	r3
}
     30e:	bd10      	pop	{r4, pc}
     310:	2000003c 	.word	0x2000003c
     314:	00000785 	.word	0x00000785
     318:	00000b09 	.word	0x00000b09

0000031c <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
     31c:	b570      	push	{r4, r5, r6, lr}
     31e:	0006      	movs	r6, r0
     320:	000c      	movs	r4, r1
     322:	0015      	movs	r5, r2
	ASSERT(io_descr && buf);
     324:	2800      	cmp	r0, #0
     326:	d00d      	beq.n	344 <io_write+0x28>
     328:	0008      	movs	r0, r1
     32a:	1e43      	subs	r3, r0, #1
     32c:	4198      	sbcs	r0, r3
     32e:	b2c0      	uxtb	r0, r0
     330:	2234      	movs	r2, #52	; 0x34
     332:	4905      	ldr	r1, [pc, #20]	; (348 <io_write+0x2c>)
     334:	4b05      	ldr	r3, [pc, #20]	; (34c <io_write+0x30>)
     336:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
     338:	6833      	ldr	r3, [r6, #0]
     33a:	002a      	movs	r2, r5
     33c:	0021      	movs	r1, r4
     33e:	0030      	movs	r0, r6
     340:	4798      	blx	r3
}
     342:	bd70      	pop	{r4, r5, r6, pc}
     344:	2000      	movs	r0, #0
     346:	e7f3      	b.n	330 <io_write+0x14>
     348:	00002438 	.word	0x00002438
     34c:	0000067d 	.word	0x0000067d

00000350 <usart_transmission_complete>:
 * \brief Process completion of data sending
 *
 * \param[in] device The pointer to device structure
 */
static void usart_transmission_complete(struct _usart_async_device *device)
{
     350:	b510      	push	{r4, lr}
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
     352:	3808      	subs	r0, #8

	descr->stat = 0;
     354:	2300      	movs	r3, #0
     356:	6303      	str	r3, [r0, #48]	; 0x30
	if (descr->usart_cb.tx_done) {
     358:	6a43      	ldr	r3, [r0, #36]	; 0x24
     35a:	2b00      	cmp	r3, #0
     35c:	d000      	beq.n	360 <usart_transmission_complete+0x10>
		descr->usart_cb.tx_done(descr);
     35e:	4798      	blx	r3
	}
}
     360:	bd10      	pop	{r4, pc}

00000362 <usart_error>:
 * \brief Process error interrupt
 *
 * \param[in] device The pointer to device structure
 */
static void usart_error(struct _usart_async_device *device)
{
     362:	b510      	push	{r4, lr}
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
     364:	3808      	subs	r0, #8

	descr->stat = 0;
     366:	2300      	movs	r3, #0
     368:	6303      	str	r3, [r0, #48]	; 0x30
	if (descr->usart_cb.error) {
     36a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
     36c:	2b00      	cmp	r3, #0
     36e:	d000      	beq.n	372 <usart_error+0x10>
		descr->usart_cb.error(descr);
     370:	4798      	blx	r3
	}
}
     372:	bd10      	pop	{r4, pc}

00000374 <usart_fill_rx_buffer>:
{
     374:	b510      	push	{r4, lr}
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
     376:	0004      	movs	r4, r0
	ringbuffer_put(&descr->rx, data);
     378:	302c      	adds	r0, #44	; 0x2c
     37a:	4b04      	ldr	r3, [pc, #16]	; (38c <usart_fill_rx_buffer+0x18>)
     37c:	4798      	blx	r3
	if (descr->usart_cb.rx_done) {
     37e:	6a23      	ldr	r3, [r4, #32]
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
     380:	3c08      	subs	r4, #8
	if (descr->usart_cb.rx_done) {
     382:	2b00      	cmp	r3, #0
     384:	d001      	beq.n	38a <usart_fill_rx_buffer+0x16>
		descr->usart_cb.rx_done(descr);
     386:	0020      	movs	r0, r4
     388:	4798      	blx	r3
}
     38a:	bd10      	pop	{r4, pc}
     38c:	00000721 	.word	0x00000721

00000390 <usart_async_write>:
{
     390:	b570      	push	{r4, r5, r6, lr}
     392:	0004      	movs	r4, r0
     394:	000e      	movs	r6, r1
     396:	0015      	movs	r5, r2
	ASSERT(descr && buf && length);
     398:	2800      	cmp	r0, #0
     39a:	d01d      	beq.n	3d8 <usart_async_write+0x48>
     39c:	2900      	cmp	r1, #0
     39e:	d01d      	beq.n	3dc <usart_async_write+0x4c>
     3a0:	0010      	movs	r0, r2
     3a2:	1e43      	subs	r3, r0, #1
     3a4:	4198      	sbcs	r0, r3
     3a6:	223c      	movs	r2, #60	; 0x3c
     3a8:	32ff      	adds	r2, #255	; 0xff
     3aa:	490f      	ldr	r1, [pc, #60]	; (3e8 <usart_async_write+0x58>)
     3ac:	4b0f      	ldr	r3, [pc, #60]	; (3ec <usart_async_write+0x5c>)
     3ae:	4798      	blx	r3
	if (descr->tx_por != descr->tx_buffer_length) {
     3b0:	2344      	movs	r3, #68	; 0x44
     3b2:	5ae2      	ldrh	r2, [r4, r3]
     3b4:	3308      	adds	r3, #8
     3b6:	5ae3      	ldrh	r3, [r4, r3]
     3b8:	429a      	cmp	r2, r3
     3ba:	d111      	bne.n	3e0 <usart_async_write+0x50>
	descr->tx_buffer        = (uint8_t *)buf;
     3bc:	64a6      	str	r6, [r4, #72]	; 0x48
	descr->tx_buffer_length = length;
     3be:	234c      	movs	r3, #76	; 0x4c
     3c0:	52e5      	strh	r5, [r4, r3]
	descr->tx_por           = 0;
     3c2:	2200      	movs	r2, #0
     3c4:	3b08      	subs	r3, #8
     3c6:	52e2      	strh	r2, [r4, r3]
	descr->stat             = USART_ASYNC_STATUS_BUSY;
     3c8:	3b43      	subs	r3, #67	; 0x43
     3ca:	6323      	str	r3, [r4, #48]	; 0x30
	_usart_async_enable_byte_sent_irq(&descr->device);
     3cc:	0020      	movs	r0, r4
     3ce:	3008      	adds	r0, #8
     3d0:	4b07      	ldr	r3, [pc, #28]	; (3f0 <usart_async_write+0x60>)
     3d2:	4798      	blx	r3
	return (int32_t)length;
     3d4:	0028      	movs	r0, r5
}
     3d6:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && buf && length);
     3d8:	2000      	movs	r0, #0
     3da:	e7e4      	b.n	3a6 <usart_async_write+0x16>
     3dc:	2000      	movs	r0, #0
     3de:	e7e2      	b.n	3a6 <usart_async_write+0x16>
		return ERR_NO_RESOURCE;
     3e0:	201c      	movs	r0, #28
     3e2:	4240      	negs	r0, r0
     3e4:	e7f7      	b.n	3d6 <usart_async_write+0x46>
     3e6:	46c0      	nop			; (mov r8, r8)
     3e8:	0000244c 	.word	0x0000244c
     3ec:	0000067d 	.word	0x0000067d
     3f0:	00000a05 	.word	0x00000a05

000003f4 <usart_process_byte_sent>:
{
     3f4:	b570      	push	{r4, r5, r6, lr}
     3f6:	0004      	movs	r4, r0
	if (descr->tx_por != descr->tx_buffer_length) {
     3f8:	0001      	movs	r1, r0
     3fa:	3908      	subs	r1, #8
     3fc:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
     3fe:	224c      	movs	r2, #76	; 0x4c
     400:	5a8a      	ldrh	r2, [r1, r2]
     402:	429a      	cmp	r2, r3
     404:	d00c      	beq.n	420 <usart_process_byte_sent+0x2c>
		_usart_async_write_byte(&descr->device, descr->tx_buffer[descr->tx_por++]);
     406:	000a      	movs	r2, r1
     408:	6c89      	ldr	r1, [r1, #72]	; 0x48
     40a:	1c5d      	adds	r5, r3, #1
     40c:	2044      	movs	r0, #68	; 0x44
     40e:	5215      	strh	r5, [r2, r0]
     410:	5cc9      	ldrb	r1, [r1, r3]
     412:	0020      	movs	r0, r4
     414:	4b04      	ldr	r3, [pc, #16]	; (428 <usart_process_byte_sent+0x34>)
     416:	4798      	blx	r3
		_usart_async_enable_byte_sent_irq(&descr->device);
     418:	0020      	movs	r0, r4
     41a:	4b04      	ldr	r3, [pc, #16]	; (42c <usart_process_byte_sent+0x38>)
     41c:	4798      	blx	r3
}
     41e:	bd70      	pop	{r4, r5, r6, pc}
		_usart_async_enable_tx_done_irq(&descr->device);
     420:	4b03      	ldr	r3, [pc, #12]	; (430 <usart_process_byte_sent+0x3c>)
     422:	4798      	blx	r3
}
     424:	e7fb      	b.n	41e <usart_process_byte_sent+0x2a>
     426:	46c0      	nop			; (mov r8, r8)
     428:	000009fd 	.word	0x000009fd
     42c:	00000a05 	.word	0x00000a05
     430:	00000a0d 	.word	0x00000a0d

00000434 <usart_async_read>:
{
     434:	b5f0      	push	{r4, r5, r6, r7, lr}
     436:	46ce      	mov	lr, r9
     438:	4647      	mov	r7, r8
     43a:	b580      	push	{r7, lr}
     43c:	b085      	sub	sp, #20
     43e:	0005      	movs	r5, r0
     440:	000e      	movs	r6, r1
     442:	0017      	movs	r7, r2
	ASSERT(descr && buf && length);
     444:	2800      	cmp	r0, #0
     446:	d015      	beq.n	474 <usart_async_read+0x40>
     448:	2900      	cmp	r1, #0
     44a:	d013      	beq.n	474 <usart_async_read+0x40>
     44c:	2a00      	cmp	r2, #0
     44e:	d12a      	bne.n	4a6 <usart_async_read+0x72>
     450:	22ac      	movs	r2, #172	; 0xac
     452:	0052      	lsls	r2, r2, #1
     454:	4929      	ldr	r1, [pc, #164]	; (4fc <usart_async_read+0xc8>)
     456:	2000      	movs	r0, #0
     458:	4b29      	ldr	r3, [pc, #164]	; (500 <usart_async_read+0xcc>)
     45a:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
     45c:	a803      	add	r0, sp, #12
     45e:	4b29      	ldr	r3, [pc, #164]	; (504 <usart_async_read+0xd0>)
     460:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
     462:	0028      	movs	r0, r5
     464:	3034      	adds	r0, #52	; 0x34
     466:	4b28      	ldr	r3, [pc, #160]	; (508 <usart_async_read+0xd4>)
     468:	4798      	blx	r3
	CRITICAL_SECTION_LEAVE()
     46a:	a803      	add	r0, sp, #12
     46c:	4b27      	ldr	r3, [pc, #156]	; (50c <usart_async_read+0xd8>)
     46e:	4798      	blx	r3
	uint16_t                       was_read = 0;
     470:	2500      	movs	r5, #0
	return (int32_t)was_read;
     472:	e03c      	b.n	4ee <usart_async_read+0xba>
	ASSERT(descr && buf && length);
     474:	22ac      	movs	r2, #172	; 0xac
     476:	0052      	lsls	r2, r2, #1
     478:	4920      	ldr	r1, [pc, #128]	; (4fc <usart_async_read+0xc8>)
     47a:	2000      	movs	r0, #0
     47c:	4b20      	ldr	r3, [pc, #128]	; (500 <usart_async_read+0xcc>)
     47e:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
     480:	a803      	add	r0, sp, #12
     482:	4b20      	ldr	r3, [pc, #128]	; (504 <usart_async_read+0xd0>)
     484:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
     486:	3534      	adds	r5, #52	; 0x34
     488:	0028      	movs	r0, r5
     48a:	9501      	str	r5, [sp, #4]
     48c:	4b1e      	ldr	r3, [pc, #120]	; (508 <usart_async_read+0xd4>)
     48e:	4798      	blx	r3
     490:	4680      	mov	r8, r0
	CRITICAL_SECTION_LEAVE()
     492:	a803      	add	r0, sp, #12
     494:	4b1d      	ldr	r3, [pc, #116]	; (50c <usart_async_read+0xd8>)
     496:	4798      	blx	r3
	uint16_t                       was_read = 0;
     498:	2500      	movs	r5, #0
	while ((was_read < num) && (was_read < length)) {
     49a:	4643      	mov	r3, r8
     49c:	2b00      	cmp	r3, #0
     49e:	d026      	beq.n	4ee <usart_async_read+0xba>
     4a0:	2f00      	cmp	r7, #0
     4a2:	d116      	bne.n	4d2 <usart_async_read+0x9e>
     4a4:	e023      	b.n	4ee <usart_async_read+0xba>
	ASSERT(descr && buf && length);
     4a6:	22ac      	movs	r2, #172	; 0xac
     4a8:	0052      	lsls	r2, r2, #1
     4aa:	4914      	ldr	r1, [pc, #80]	; (4fc <usart_async_read+0xc8>)
     4ac:	2001      	movs	r0, #1
     4ae:	4b14      	ldr	r3, [pc, #80]	; (500 <usart_async_read+0xcc>)
     4b0:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
     4b2:	a803      	add	r0, sp, #12
     4b4:	4b13      	ldr	r3, [pc, #76]	; (504 <usart_async_read+0xd0>)
     4b6:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
     4b8:	3534      	adds	r5, #52	; 0x34
     4ba:	0028      	movs	r0, r5
     4bc:	9501      	str	r5, [sp, #4]
     4be:	4b12      	ldr	r3, [pc, #72]	; (508 <usart_async_read+0xd4>)
     4c0:	4798      	blx	r3
     4c2:	4680      	mov	r8, r0
	CRITICAL_SECTION_LEAVE()
     4c4:	a803      	add	r0, sp, #12
     4c6:	4b11      	ldr	r3, [pc, #68]	; (50c <usart_async_read+0xd8>)
     4c8:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
     4ca:	4643      	mov	r3, r8
	uint16_t                       was_read = 0;
     4cc:	2500      	movs	r5, #0
	while ((was_read < num) && (was_read < length)) {
     4ce:	2b00      	cmp	r3, #0
     4d0:	d00d      	beq.n	4ee <usart_async_read+0xba>
{
     4d2:	2400      	movs	r4, #0
		ringbuffer_get(&descr->rx, &buf[was_read++]);
     4d4:	4b0e      	ldr	r3, [pc, #56]	; (510 <usart_async_read+0xdc>)
     4d6:	4699      	mov	r9, r3
     4d8:	1c65      	adds	r5, r4, #1
     4da:	b2ad      	uxth	r5, r5
     4dc:	1931      	adds	r1, r6, r4
     4de:	9801      	ldr	r0, [sp, #4]
     4e0:	47c8      	blx	r9
     4e2:	3401      	adds	r4, #1
	while ((was_read < num) && (was_read < length)) {
     4e4:	4544      	cmp	r4, r8
     4e6:	d202      	bcs.n	4ee <usart_async_read+0xba>
     4e8:	b2a3      	uxth	r3, r4
     4ea:	429f      	cmp	r7, r3
     4ec:	d8f4      	bhi.n	4d8 <usart_async_read+0xa4>
}
     4ee:	0028      	movs	r0, r5
     4f0:	b005      	add	sp, #20
     4f2:	bc0c      	pop	{r2, r3}
     4f4:	4690      	mov	r8, r2
     4f6:	4699      	mov	r9, r3
     4f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
     4fa:	46c0      	nop			; (mov r8, r8)
     4fc:	0000244c 	.word	0x0000244c
     500:	0000067d 	.word	0x0000067d
     504:	000002cd 	.word	0x000002cd
     508:	00000761 	.word	0x00000761
     50c:	000002db 	.word	0x000002db
     510:	000006d9 	.word	0x000006d9

00000514 <usart_async_init>:
{
     514:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     516:	0004      	movs	r4, r0
     518:	000d      	movs	r5, r1
     51a:	0016      	movs	r6, r2
     51c:	001f      	movs	r7, r3
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
     51e:	2800      	cmp	r0, #0
     520:	d026      	beq.n	570 <usart_async_init+0x5c>
     522:	2900      	cmp	r1, #0
     524:	d026      	beq.n	574 <usart_async_init+0x60>
     526:	2a00      	cmp	r2, #0
     528:	d026      	beq.n	578 <usart_async_init+0x64>
     52a:	0018      	movs	r0, r3
     52c:	1e43      	subs	r3, r0, #1
     52e:	4198      	sbcs	r0, r3
     530:	223a      	movs	r2, #58	; 0x3a
     532:	4914      	ldr	r1, [pc, #80]	; (584 <usart_async_init+0x70>)
     534:	4b14      	ldr	r3, [pc, #80]	; (588 <usart_async_init+0x74>)
     536:	4798      	blx	r3
	if (ERR_NONE != ringbuffer_init(&descr->rx, rx_buffer, rx_buffer_length)) {
     538:	0020      	movs	r0, r4
     53a:	3034      	adds	r0, #52	; 0x34
     53c:	003a      	movs	r2, r7
     53e:	0031      	movs	r1, r6
     540:	4b12      	ldr	r3, [pc, #72]	; (58c <usart_async_init+0x78>)
     542:	4798      	blx	r3
     544:	2800      	cmp	r0, #0
     546:	d119      	bne.n	57c <usart_async_init+0x68>
	init_status = _usart_async_init(&descr->device, hw);
     548:	0020      	movs	r0, r4
     54a:	3008      	adds	r0, #8
     54c:	0029      	movs	r1, r5
     54e:	4b10      	ldr	r3, [pc, #64]	; (590 <usart_async_init+0x7c>)
     550:	4798      	blx	r3
	if (init_status) {
     552:	2800      	cmp	r0, #0
     554:	d10b      	bne.n	56e <usart_async_init+0x5a>
	descr->io.read  = usart_async_read;
     556:	4b0f      	ldr	r3, [pc, #60]	; (594 <usart_async_init+0x80>)
     558:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_async_write;
     55a:	4b0f      	ldr	r3, [pc, #60]	; (598 <usart_async_init+0x84>)
     55c:	6023      	str	r3, [r4, #0]
	descr->device.usart_cb.tx_byte_sent = usart_process_byte_sent;
     55e:	4b0f      	ldr	r3, [pc, #60]	; (59c <usart_async_init+0x88>)
     560:	60a3      	str	r3, [r4, #8]
	descr->device.usart_cb.rx_done_cb   = usart_fill_rx_buffer;
     562:	4b0f      	ldr	r3, [pc, #60]	; (5a0 <usart_async_init+0x8c>)
     564:	60e3      	str	r3, [r4, #12]
	descr->device.usart_cb.tx_done_cb   = usart_transmission_complete;
     566:	4b0f      	ldr	r3, [pc, #60]	; (5a4 <usart_async_init+0x90>)
     568:	6123      	str	r3, [r4, #16]
	descr->device.usart_cb.error_cb     = usart_error;
     56a:	4b0f      	ldr	r3, [pc, #60]	; (5a8 <usart_async_init+0x94>)
     56c:	6163      	str	r3, [r4, #20]
}
     56e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
     570:	2000      	movs	r0, #0
     572:	e7dd      	b.n	530 <usart_async_init+0x1c>
     574:	2000      	movs	r0, #0
     576:	e7db      	b.n	530 <usart_async_init+0x1c>
     578:	2000      	movs	r0, #0
     57a:	e7d9      	b.n	530 <usart_async_init+0x1c>
		return ERR_INVALID_ARG;
     57c:	200d      	movs	r0, #13
     57e:	4240      	negs	r0, r0
     580:	e7f5      	b.n	56e <usart_async_init+0x5a>
     582:	46c0      	nop			; (mov r8, r8)
     584:	0000244c 	.word	0x0000244c
     588:	0000067d 	.word	0x0000067d
     58c:	00000685 	.word	0x00000685
     590:	00000971 	.word	0x00000971
     594:	00000435 	.word	0x00000435
     598:	00000391 	.word	0x00000391
     59c:	000003f5 	.word	0x000003f5
     5a0:	00000375 	.word	0x00000375
     5a4:	00000351 	.word	0x00000351
     5a8:	00000363 	.word	0x00000363

000005ac <usart_async_enable>:
{
     5ac:	b510      	push	{r4, lr}
     5ae:	0004      	movs	r4, r0
	ASSERT(descr);
     5b0:	1e43      	subs	r3, r0, #1
     5b2:	4198      	sbcs	r0, r3
     5b4:	b2c0      	uxtb	r0, r0
     5b6:	2261      	movs	r2, #97	; 0x61
     5b8:	4904      	ldr	r1, [pc, #16]	; (5cc <usart_async_enable+0x20>)
     5ba:	4b05      	ldr	r3, [pc, #20]	; (5d0 <usart_async_enable+0x24>)
     5bc:	4798      	blx	r3
	_usart_async_enable(&descr->device);
     5be:	0020      	movs	r0, r4
     5c0:	3008      	adds	r0, #8
     5c2:	4b04      	ldr	r3, [pc, #16]	; (5d4 <usart_async_enable+0x28>)
     5c4:	4798      	blx	r3
}
     5c6:	2000      	movs	r0, #0
     5c8:	bd10      	pop	{r4, pc}
     5ca:	46c0      	nop			; (mov r8, r8)
     5cc:	0000244c 	.word	0x0000244c
     5d0:	0000067d 	.word	0x0000067d
     5d4:	000009e9 	.word	0x000009e9

000005d8 <usart_async_get_io_descriptor>:
{
     5d8:	b570      	push	{r4, r5, r6, lr}
     5da:	0004      	movs	r4, r0
     5dc:	000d      	movs	r5, r1
	ASSERT(descr && io);
     5de:	2800      	cmp	r0, #0
     5e0:	d00a      	beq.n	5f8 <usart_async_get_io_descriptor+0x20>
     5e2:	0008      	movs	r0, r1
     5e4:	1e43      	subs	r3, r0, #1
     5e6:	4198      	sbcs	r0, r3
     5e8:	b2c0      	uxtb	r0, r0
     5ea:	2277      	movs	r2, #119	; 0x77
     5ec:	4903      	ldr	r1, [pc, #12]	; (5fc <usart_async_get_io_descriptor+0x24>)
     5ee:	4b04      	ldr	r3, [pc, #16]	; (600 <usart_async_get_io_descriptor+0x28>)
     5f0:	4798      	blx	r3
	*io = &descr->io;
     5f2:	602c      	str	r4, [r5, #0]
}
     5f4:	2000      	movs	r0, #0
     5f6:	bd70      	pop	{r4, r5, r6, pc}
     5f8:	2000      	movs	r0, #0
     5fa:	e7f6      	b.n	5ea <usart_async_get_io_descriptor+0x12>
     5fc:	0000244c 	.word	0x0000244c
     600:	0000067d 	.word	0x0000067d

00000604 <usart_async_register_callback>:
{
     604:	b570      	push	{r4, r5, r6, lr}
     606:	0005      	movs	r5, r0
     608:	000e      	movs	r6, r1
     60a:	0014      	movs	r4, r2
	ASSERT(descr);
     60c:	1e43      	subs	r3, r0, #1
     60e:	4198      	sbcs	r0, r3
     610:	b2c0      	uxtb	r0, r0
     612:	2283      	movs	r2, #131	; 0x83
     614:	4916      	ldr	r1, [pc, #88]	; (670 <usart_async_register_callback+0x6c>)
     616:	4b17      	ldr	r3, [pc, #92]	; (674 <usart_async_register_callback+0x70>)
     618:	4798      	blx	r3
	switch (type) {
     61a:	2e01      	cmp	r6, #1
     61c:	d011      	beq.n	642 <usart_async_register_callback+0x3e>
     61e:	2e00      	cmp	r6, #0
     620:	d004      	beq.n	62c <usart_async_register_callback+0x28>
     622:	2e02      	cmp	r6, #2
     624:	d018      	beq.n	658 <usart_async_register_callback+0x54>
		return ERR_INVALID_ARG;
     626:	200d      	movs	r0, #13
     628:	4240      	negs	r0, r0
     62a:	e009      	b.n	640 <usart_async_register_callback+0x3c>
		descr->usart_cb.rx_done = cb;
     62c:	62ac      	str	r4, [r5, #40]	; 0x28
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, NULL != cb);
     62e:	1e62      	subs	r2, r4, #1
     630:	4194      	sbcs	r4, r2
     632:	b2e2      	uxtb	r2, r4
     634:	0028      	movs	r0, r5
     636:	3008      	adds	r0, #8
     638:	2101      	movs	r1, #1
     63a:	4b0f      	ldr	r3, [pc, #60]	; (678 <usart_async_register_callback+0x74>)
     63c:	4798      	blx	r3
	return ERR_NONE;
     63e:	2000      	movs	r0, #0
}
     640:	bd70      	pop	{r4, r5, r6, pc}
		descr->usart_cb.tx_done = cb;
     642:	626c      	str	r4, [r5, #36]	; 0x24
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_TX_DONE, NULL != cb);
     644:	1e62      	subs	r2, r4, #1
     646:	4194      	sbcs	r4, r2
     648:	b2e2      	uxtb	r2, r4
     64a:	0028      	movs	r0, r5
     64c:	3008      	adds	r0, #8
     64e:	2102      	movs	r1, #2
     650:	4b09      	ldr	r3, [pc, #36]	; (678 <usart_async_register_callback+0x74>)
     652:	4798      	blx	r3
	return ERR_NONE;
     654:	2000      	movs	r0, #0
		break;
     656:	e7f3      	b.n	640 <usart_async_register_callback+0x3c>
		descr->usart_cb.error = cb;
     658:	62ec      	str	r4, [r5, #44]	; 0x2c
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
     65a:	1e62      	subs	r2, r4, #1
     65c:	4194      	sbcs	r4, r2
     65e:	b2e2      	uxtb	r2, r4
     660:	0028      	movs	r0, r5
     662:	3008      	adds	r0, #8
     664:	2103      	movs	r1, #3
     666:	4b04      	ldr	r3, [pc, #16]	; (678 <usart_async_register_callback+0x74>)
     668:	4798      	blx	r3
	return ERR_NONE;
     66a:	2000      	movs	r0, #0
		break;
     66c:	e7e8      	b.n	640 <usart_async_register_callback+0x3c>
     66e:	46c0      	nop			; (mov r8, r8)
     670:	0000244c 	.word	0x0000244c
     674:	0000067d 	.word	0x0000067d
     678:	00000a15 	.word	0x00000a15

0000067c <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
     67c:	2800      	cmp	r0, #0
     67e:	d100      	bne.n	682 <assert+0x6>
		__asm("BKPT #0");
     680:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
     682:	4770      	bx	lr

00000684 <ringbuffer_init>:

/**
 * \brief Ringbuffer init
 */
int32_t ringbuffer_init(struct ringbuffer *const rb, void *buf, uint32_t size)
{
     684:	b570      	push	{r4, r5, r6, lr}
     686:	0004      	movs	r4, r0
     688:	000e      	movs	r6, r1
     68a:	0015      	movs	r5, r2
	ASSERT(rb && buf && size);
     68c:	2800      	cmp	r0, #0
     68e:	d00b      	beq.n	6a8 <ringbuffer_init+0x24>
     690:	2900      	cmp	r1, #0
     692:	d018      	beq.n	6c6 <ringbuffer_init+0x42>
     694:	2001      	movs	r0, #1
     696:	2a00      	cmp	r2, #0
     698:	d107      	bne.n	6aa <ringbuffer_init+0x26>
     69a:	2228      	movs	r2, #40	; 0x28
     69c:	490c      	ldr	r1, [pc, #48]	; (6d0 <ringbuffer_init+0x4c>)
     69e:	2000      	movs	r0, #0
     6a0:	4b0c      	ldr	r3, [pc, #48]	; (6d4 <ringbuffer_init+0x50>)
     6a2:	4798      	blx	r3

	/*
	 * buf size must be aligned to power of 2
	 */
	if ((size & (size - 1)) != 0) {
     6a4:	1e6b      	subs	r3, r5, #1
     6a6:	e007      	b.n	6b8 <ringbuffer_init+0x34>
	ASSERT(rb && buf && size);
     6a8:	2000      	movs	r0, #0
     6aa:	2228      	movs	r2, #40	; 0x28
     6ac:	4908      	ldr	r1, [pc, #32]	; (6d0 <ringbuffer_init+0x4c>)
     6ae:	4b09      	ldr	r3, [pc, #36]	; (6d4 <ringbuffer_init+0x50>)
     6b0:	4798      	blx	r3
	if ((size & (size - 1)) != 0) {
     6b2:	1e6b      	subs	r3, r5, #1
     6b4:	422b      	tst	r3, r5
     6b6:	d108      	bne.n	6ca <ringbuffer_init+0x46>
		return ERR_INVALID_ARG;
	}

	/* size - 1 is faster in calculation */
	rb->size        = size - 1;
     6b8:	6063      	str	r3, [r4, #4]
	rb->read_index  = 0;
     6ba:	2300      	movs	r3, #0
     6bc:	60a3      	str	r3, [r4, #8]
	rb->write_index = rb->read_index;
     6be:	60e3      	str	r3, [r4, #12]
	rb->buf         = (uint8_t *)buf;
     6c0:	6026      	str	r6, [r4, #0]

	return ERR_NONE;
     6c2:	2000      	movs	r0, #0
}
     6c4:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
     6c6:	2000      	movs	r0, #0
     6c8:	e7ef      	b.n	6aa <ringbuffer_init+0x26>
		return ERR_INVALID_ARG;
     6ca:	200d      	movs	r0, #13
     6cc:	4240      	negs	r0, r0
     6ce:	e7f9      	b.n	6c4 <ringbuffer_init+0x40>
     6d0:	0000246c 	.word	0x0000246c
     6d4:	0000067d 	.word	0x0000067d

000006d8 <ringbuffer_get>:
/**
 * \brief Get one byte from ringbuffer
 *
 */
int32_t ringbuffer_get(struct ringbuffer *const rb, uint8_t *data)
{
     6d8:	b570      	push	{r4, r5, r6, lr}
     6da:	0004      	movs	r4, r0
     6dc:	000d      	movs	r5, r1
	ASSERT(rb && data);
     6de:	2800      	cmp	r0, #0
     6e0:	d015      	beq.n	70e <ringbuffer_get+0x36>
     6e2:	0008      	movs	r0, r1
     6e4:	1e43      	subs	r3, r0, #1
     6e6:	4198      	sbcs	r0, r3
     6e8:	b2c0      	uxtb	r0, r0
     6ea:	2240      	movs	r2, #64	; 0x40
     6ec:	490a      	ldr	r1, [pc, #40]	; (718 <ringbuffer_get+0x40>)
     6ee:	4b0b      	ldr	r3, [pc, #44]	; (71c <ringbuffer_get+0x44>)
     6f0:	4798      	blx	r3

	if (rb->write_index != rb->read_index) {
     6f2:	68a3      	ldr	r3, [r4, #8]
     6f4:	68e2      	ldr	r2, [r4, #12]
     6f6:	429a      	cmp	r2, r3
     6f8:	d00b      	beq.n	712 <ringbuffer_get+0x3a>
		*data = rb->buf[rb->read_index & rb->size];
     6fa:	6862      	ldr	r2, [r4, #4]
     6fc:	4013      	ands	r3, r2
     6fe:	6822      	ldr	r2, [r4, #0]
     700:	5cd3      	ldrb	r3, [r2, r3]
     702:	702b      	strb	r3, [r5, #0]
		rb->read_index++;
     704:	68a3      	ldr	r3, [r4, #8]
     706:	3301      	adds	r3, #1
     708:	60a3      	str	r3, [r4, #8]
		return ERR_NONE;
     70a:	2000      	movs	r0, #0
	}

	return ERR_NOT_FOUND;
}
     70c:	bd70      	pop	{r4, r5, r6, pc}
     70e:	2000      	movs	r0, #0
     710:	e7eb      	b.n	6ea <ringbuffer_get+0x12>
	return ERR_NOT_FOUND;
     712:	200a      	movs	r0, #10
     714:	4240      	negs	r0, r0
     716:	e7f9      	b.n	70c <ringbuffer_get+0x34>
     718:	0000246c 	.word	0x0000246c
     71c:	0000067d 	.word	0x0000067d

00000720 <ringbuffer_put>:
/**
 * \brief Put one byte to ringbuffer
 *
 */
int32_t ringbuffer_put(struct ringbuffer *const rb, uint8_t data)
{
     720:	b570      	push	{r4, r5, r6, lr}
     722:	0004      	movs	r4, r0
     724:	000d      	movs	r5, r1
	ASSERT(rb);
     726:	1e43      	subs	r3, r0, #1
     728:	4198      	sbcs	r0, r3
     72a:	b2c0      	uxtb	r0, r0
     72c:	2251      	movs	r2, #81	; 0x51
     72e:	490a      	ldr	r1, [pc, #40]	; (758 <ringbuffer_put+0x38>)
     730:	4b0a      	ldr	r3, [pc, #40]	; (75c <ringbuffer_put+0x3c>)
     732:	4798      	blx	r3

	rb->buf[rb->write_index & rb->size] = data;
     734:	6863      	ldr	r3, [r4, #4]
     736:	68e2      	ldr	r2, [r4, #12]
     738:	4013      	ands	r3, r2
     73a:	6822      	ldr	r2, [r4, #0]
     73c:	54d5      	strb	r5, [r2, r3]

	/*
	 * buffer full strategy: new data will overwrite the oldest data in
	 * the buffer
	 */
	if ((rb->write_index - rb->read_index) > rb->size) {
     73e:	68e3      	ldr	r3, [r4, #12]
     740:	6861      	ldr	r1, [r4, #4]
     742:	68a2      	ldr	r2, [r4, #8]
     744:	1a9a      	subs	r2, r3, r2
     746:	428a      	cmp	r2, r1
     748:	d901      	bls.n	74e <ringbuffer_put+0x2e>
		rb->read_index = rb->write_index - rb->size;
     74a:	1a59      	subs	r1, r3, r1
     74c:	60a1      	str	r1, [r4, #8]
	}

	rb->write_index++;
     74e:	3301      	adds	r3, #1
     750:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
}
     752:	2000      	movs	r0, #0
     754:	bd70      	pop	{r4, r5, r6, pc}
     756:	46c0      	nop			; (mov r8, r8)
     758:	0000246c 	.word	0x0000246c
     75c:	0000067d 	.word	0x0000067d

00000760 <ringbuffer_num>:

/**
 * \brief Return the element number of ringbuffer
 */
uint32_t ringbuffer_num(const struct ringbuffer *const rb)
{
     760:	b510      	push	{r4, lr}
     762:	0004      	movs	r4, r0
	ASSERT(rb);
     764:	1e43      	subs	r3, r0, #1
     766:	4198      	sbcs	r0, r3
     768:	b2c0      	uxtb	r0, r0
     76a:	2267      	movs	r2, #103	; 0x67
     76c:	4903      	ldr	r1, [pc, #12]	; (77c <ringbuffer_num+0x1c>)
     76e:	4b04      	ldr	r3, [pc, #16]	; (780 <ringbuffer_num+0x20>)
     770:	4798      	blx	r3

	return rb->write_index - rb->read_index;
     772:	68e0      	ldr	r0, [r4, #12]
     774:	68a3      	ldr	r3, [r4, #8]
     776:	1ac0      	subs	r0, r0, r3
}
     778:	bd10      	pop	{r4, pc}
     77a:	46c0      	nop			; (mov r8, r8)
     77c:	0000246c 	.word	0x0000246c
     780:	0000067d 	.word	0x0000067d

00000784 <_get_cycles_for_ms>:
{
	switch (power) {
	case 8:
		return (ms * (freq / 100000)) * 100;
	case 7:
		return (ms * (freq / 10000)) * 10;
     784:	23fa      	movs	r3, #250	; 0xfa
     786:	011b      	lsls	r3, r3, #4
     788:	4358      	muls	r0, r3
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
}
     78a:	4770      	bx	lr

0000078c <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
     78c:	b510      	push	{r4, lr}
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
     78e:	4b08      	ldr	r3, [pc, #32]	; (7b0 <_init_chip+0x24>)
     790:	685a      	ldr	r2, [r3, #4]
     792:	605a      	str	r2, [r3, #4]
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
     794:	4b07      	ldr	r3, [pc, #28]	; (7b4 <_init_chip+0x28>)
     796:	4798      	blx	r3
	_oscctrl_init_sources();
     798:	4b07      	ldr	r3, [pc, #28]	; (7b8 <_init_chip+0x2c>)
     79a:	4798      	blx	r3
	_mclk_init();
     79c:	4b07      	ldr	r3, [pc, #28]	; (7bc <_init_chip+0x30>)
     79e:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
#endif
	_oscctrl_init_referenced_generators();
     7a0:	4b07      	ldr	r3, [pc, #28]	; (7c0 <_init_chip+0x34>)
     7a2:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
     7a4:	20ff      	movs	r0, #255	; 0xff
     7a6:	4b07      	ldr	r3, [pc, #28]	; (7c4 <_init_chip+0x38>)
     7a8:	4798      	blx	r3

	_div_init();
     7aa:	4b07      	ldr	r3, [pc, #28]	; (7c8 <_init_chip+0x3c>)
     7ac:	4798      	blx	r3
#endif

#if (CONF_PORT_EVCTRL_PORT_0 | CONF_PORT_EVCTRL_PORT_1 | CONF_PORT_EVCTRL_PORT_2 | CONF_PORT_EVCTRL_PORT_3)
	_port_event_init();
#endif
}
     7ae:	bd10      	pop	{r4, pc}
     7b0:	41004000 	.word	0x41004000
     7b4:	0000080d 	.word	0x0000080d
     7b8:	00000825 	.word	0x00000825
     7bc:	00000801 	.word	0x00000801
     7c0:	00000865 	.word	0x00000865
     7c4:	000007dd 	.word	0x000007dd
     7c8:	000007cd 	.word	0x000007cd

000007cc <_div_init>:

static inline void hri_divas_write_CTRLA_DLZ_bit(const void *const hw, bool value)
{
	uint8_t tmp;
	DIVAS_CRITICAL_SECTION_ENTER();
	tmp = ((Divas *)hw)->CTRLA.reg;
     7cc:	2290      	movs	r2, #144	; 0x90
     7ce:	05d2      	lsls	r2, r2, #23
     7d0:	7813      	ldrb	r3, [r2, #0]
	tmp &= ~DIVAS_CTRLA_DLZ;
     7d2:	2102      	movs	r1, #2
     7d4:	438b      	bics	r3, r1
	tmp |= value << DIVAS_CTRLA_DLZ_Pos;
	((Divas *)hw)->CTRLA.reg = tmp;
     7d6:	7013      	strb	r3, [r2, #0]
 * \brief Initialize hardware for division operation
 */
void _div_init(void)
{
	hri_divas_write_CTRLA_DLZ_bit(DIVAS, CONF_DIVAS_DLZ);
}
     7d8:	4770      	bx	lr
	...

000007dc <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
     7dc:	07c3      	lsls	r3, r0, #31
     7de:	d507      	bpl.n	7f0 <_gclk_init_generators_by_fref+0x14>
	((Gclk *)hw)->GENCTRL[index].reg = data;
     7e0:	4a04      	ldr	r2, [pc, #16]	; (7f4 <_gclk_init_generators_by_fref+0x18>)
     7e2:	4b05      	ldr	r3, [pc, #20]	; (7f8 <_gclk_init_generators_by_fref+0x1c>)
     7e4:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
     7e6:	0019      	movs	r1, r3
     7e8:	4a04      	ldr	r2, [pc, #16]	; (7fc <_gclk_init_generators_by_fref+0x20>)
     7ea:	684b      	ldr	r3, [r1, #4]
     7ec:	4213      	tst	r3, r2
     7ee:	d1fc      	bne.n	7ea <_gclk_init_generators_by_fref+0xe>
		        | (CONF_GCLK_GEN_8_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_8_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_8_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_8_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_8_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_8_SOURCE);
	}
#endif
}
     7f0:	4770      	bx	lr
     7f2:	46c0      	nop			; (mov r8, r8)
     7f4:	00010106 	.word	0x00010106
     7f8:	40001c00 	.word	0x40001c00
     7fc:	000007fd 	.word	0x000007fd

00000800 <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
     800:	2201      	movs	r2, #1
     802:	4b01      	ldr	r3, [pc, #4]	; (808 <_mclk_init+0x8>)
     804:	711a      	strb	r2, [r3, #4]
 */
void _mclk_init(void)
{
	void *hw = (void *)MCLK;
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_CPUDIV(CONF_MCLK_CPUDIV));
}
     806:	4770      	bx	lr
     808:	40000800 	.word	0x40000800

0000080c <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
     80c:	4b04      	ldr	r3, [pc, #16]	; (820 <_osc32kctrl_init_sources+0x14>)
     80e:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSC32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSC32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
     810:	21f8      	movs	r1, #248	; 0xf8
     812:	0149      	lsls	r1, r1, #5
     814:	400a      	ands	r2, r1
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
     816:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
     818:	2201      	movs	r2, #1
     81a:	611a      	str	r2, [r3, #16]
		;
#endif
#endif
	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
	(void)calib;
}
     81c:	4770      	bx	lr
     81e:	46c0      	nop			; (mov r8, r8)
     820:	40001400 	.word	0x40001400

00000824 <_oscctrl_init_sources>:
}

static inline void hri_oscctrl_write_OSC48MCTRL_reg(const void *const hw, hri_oscctrl_osc48mctrl_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MCTRL.reg = data;
     824:	4b0e      	ldr	r3, [pc, #56]	; (860 <_oscctrl_init_sources+0x3c>)
     826:	2202      	movs	r2, #2
     828:	751a      	strb	r2, [r3, #20]
}

static inline void hri_oscctrl_write_OSC48MDIV_reg(const void *const hw, hri_oscctrl_osc48mdiv_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MDIV.reg = data;
     82a:	3209      	adds	r2, #9
     82c:	755a      	strb	r2, [r3, #21]
	while (((Oscctrl *)hw)->OSC48MSYNCBUSY.reg & reg) {
     82e:	0019      	movs	r1, r3
     830:	3a07      	subs	r2, #7
     832:	698b      	ldr	r3, [r1, #24]
     834:	421a      	tst	r2, r3
     836:	d1fc      	bne.n	832 <_oscctrl_init_sources+0xe>
	return (((Oscctrl *)hw)->OSC48MSYNCBUSY.reg & OSCCTRL_OSC48MSYNCBUSY_OSC48MDIV)
     838:	4909      	ldr	r1, [pc, #36]	; (860 <_oscctrl_init_sources+0x3c>)
#if CONF_OSC48M_CONFIG == 1
	hri_oscctrl_write_OSC48MCTRL_reg(hw,
	                                 (CONF_OSC48M_RUNSTDBY << OSCCTRL_OSC48MCTRL_RUNSTDBY_Pos)
	                                     | (CONF_OSC48M_ENABLE << OSCCTRL_OSC48MCTRL_ENABLE_Pos));
	hri_oscctrl_write_OSC48MDIV_reg(hw, OSCCTRL_OSC48MDIV_DIV(CONF_OSC48M_DIV));
	while (hri_oscctrl_get_OSC48MSYNCBUSY_OSC48MDIV_bit(hw))
     83a:	2204      	movs	r2, #4
     83c:	698b      	ldr	r3, [r1, #24]
     83e:	421a      	tst	r2, r3
     840:	d1fc      	bne.n	83c <_oscctrl_init_sources+0x18>
}

static inline void hri_oscctrl_write_OSC48MSTUP_reg(const void *const hw, hri_oscctrl_osc48mstup_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MSTUP.reg = data;
     842:	2207      	movs	r2, #7
     844:	4b06      	ldr	r3, [pc, #24]	; (860 <_oscctrl_init_sources+0x3c>)
     846:	759a      	strb	r2, [r3, #22]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_OSC48MRDY) >> OSCCTRL_STATUS_OSC48MRDY_Pos;
     848:	0019      	movs	r1, r3
#endif
#endif

#if CONF_OSC48M_CONFIG == 1
#if CONF_OSC48M_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_OSC48MRDY_bit(hw))
     84a:	3209      	adds	r2, #9
     84c:	68cb      	ldr	r3, [r1, #12]
     84e:	421a      	tst	r2, r3
     850:	d0fc      	beq.n	84c <_oscctrl_init_sources+0x28>
	((Oscctrl *)hw)->OSC48MCTRL.reg |= OSCCTRL_OSC48MCTRL_ONDEMAND;
     852:	4a03      	ldr	r2, [pc, #12]	; (860 <_oscctrl_init_sources+0x3c>)
     854:	7d13      	ldrb	r3, [r2, #20]
     856:	2180      	movs	r1, #128	; 0x80
     858:	430b      	orrs	r3, r1
     85a:	7513      	strb	r3, [r2, #20]
#if CONF_OSC48M_ONDEMAND == 1
	hri_oscctrl_set_OSC48MCTRL_ONDEMAND_bit(hw);
#endif
#endif
	(void)hw;
}
     85c:	4770      	bx	lr
     85e:	46c0      	nop			; (mov r8, r8)
     860:	40001000 	.word	0x40001000

00000864 <_oscctrl_init_referenced_generators>:
#if CONF_DPLL_ONDEMAND == 1
	hri_oscctrl_set_DPLLCTRLA_ONDEMAND_bit(hw);
#endif
#endif
	(void)hw;
}
     864:	4770      	bx	lr
	...

00000868 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
     868:	b530      	push	{r4, r5, lr}
     86a:	b089      	sub	sp, #36	; 0x24
	Sercom *const sercom_modules[] = SERCOM_INSTS;
     86c:	4b0c      	ldr	r3, [pc, #48]	; (8a0 <_sercom_get_hardware_index+0x38>)
     86e:	466a      	mov	r2, sp
     870:	cb32      	ldmia	r3!, {r1, r4, r5}
     872:	c232      	stmia	r2!, {r1, r4, r5}
     874:	cb32      	ldmia	r3!, {r1, r4, r5}
     876:	c232      	stmia	r2!, {r1, r4, r5}
     878:	cb12      	ldmia	r3!, {r1, r4}
     87a:	c212      	stmia	r2!, {r1, r4}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
     87c:	9b00      	ldr	r3, [sp, #0]
     87e:	4283      	cmp	r3, r0
     880:	d00b      	beq.n	89a <_sercom_get_hardware_index+0x32>
     882:	2301      	movs	r3, #1
     884:	009a      	lsls	r2, r3, #2
     886:	4669      	mov	r1, sp
     888:	5852      	ldr	r2, [r2, r1]
     88a:	4282      	cmp	r2, r0
     88c:	d006      	beq.n	89c <_sercom_get_hardware_index+0x34>
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     88e:	3301      	adds	r3, #1
     890:	2b08      	cmp	r3, #8
     892:	d1f7      	bne.n	884 <_sercom_get_hardware_index+0x1c>
			return i;
		}
	}
	return 0;
     894:	2000      	movs	r0, #0
}
     896:	b009      	add	sp, #36	; 0x24
     898:	bd30      	pop	{r4, r5, pc}
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     89a:	2300      	movs	r3, #0
			return i;
     89c:	b2d8      	uxtb	r0, r3
     89e:	e7fa      	b.n	896 <_sercom_get_hardware_index+0x2e>
     8a0:	00002490 	.word	0x00002490

000008a4 <_sercom_get_irq_num>:

/**
 * \brief Retrieve IRQ number for the given hardware instance
 */
static uint8_t _sercom_get_irq_num(const void *const hw)
{
     8a4:	b510      	push	{r4, lr}
	if (SERCOM6 == hw || SERCOM7 == hw) {
     8a6:	2386      	movs	r3, #134	; 0x86
     8a8:	05db      	lsls	r3, r3, #23
     8aa:	4298      	cmp	r0, r3
     8ac:	d007      	beq.n	8be <_sercom_get_irq_num+0x1a>
     8ae:	4b08      	ldr	r3, [pc, #32]	; (8d0 <_sercom_get_irq_num+0x2c>)
     8b0:	4298      	cmp	r0, r3
     8b2:	d004      	beq.n	8be <_sercom_get_irq_num+0x1a>
		return SERCOM6_IRQn + (((uint32_t)hw - (uint32_t)SERCOM6) >> 10);
	} else {
		return SERCOM0_IRQn + _sercom_get_hardware_index(hw);
     8b4:	4b07      	ldr	r3, [pc, #28]	; (8d4 <_sercom_get_irq_num+0x30>)
     8b6:	4798      	blx	r3
     8b8:	3009      	adds	r0, #9
     8ba:	b2c0      	uxtb	r0, r0
	}
}
     8bc:	bd10      	pop	{r4, pc}
		return SERCOM6_IRQn + (((uint32_t)hw - (uint32_t)SERCOM6) >> 10);
     8be:	23bd      	movs	r3, #189	; 0xbd
     8c0:	061b      	lsls	r3, r3, #24
     8c2:	469c      	mov	ip, r3
     8c4:	4460      	add	r0, ip
     8c6:	0a80      	lsrs	r0, r0, #10
     8c8:	3009      	adds	r0, #9
     8ca:	b2c0      	uxtb	r0, r0
     8cc:	e7f6      	b.n	8bc <_sercom_get_irq_num+0x18>
     8ce:	46c0      	nop			; (mov r8, r8)
     8d0:	43000400 	.word	0x43000400
     8d4:	00000869 	.word	0x00000869

000008d8 <_usart_init>:
{
     8d8:	b510      	push	{r4, lr}
     8da:	0004      	movs	r4, r0
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
     8dc:	4b1e      	ldr	r3, [pc, #120]	; (958 <_usart_init+0x80>)
     8de:	4798      	blx	r3
		if (_usarts[i].number == sercom_offset) {
     8e0:	2804      	cmp	r0, #4
     8e2:	d004      	beq.n	8ee <_usart_init+0x16>
	ASSERT(false);
     8e4:	4a1d      	ldr	r2, [pc, #116]	; (95c <_usart_init+0x84>)
     8e6:	491e      	ldr	r1, [pc, #120]	; (960 <_usart_init+0x88>)
     8e8:	2000      	movs	r0, #0
     8ea:	4b1e      	ldr	r3, [pc, #120]	; (964 <_usart_init+0x8c>)
     8ec:	4798      	blx	r3
	};
}

static inline bool hri_sercomusart_is_syncing(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
     8ee:	69e3      	ldr	r3, [r4, #28]
	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
     8f0:	07db      	lsls	r3, r3, #31
     8f2:	d418      	bmi.n	926 <_usart_init+0x4e>
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     8f4:	2203      	movs	r2, #3
     8f6:	69e3      	ldr	r3, [r4, #28]
     8f8:	421a      	tst	r2, r3
     8fa:	d1fc      	bne.n	8f6 <_usart_init+0x1e>
static inline hri_sercomusart_ctrla_reg_t hri_sercomusart_get_CTRLA_reg(const void *const           hw,
                                                                        hri_sercomusart_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
     8fc:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
     8fe:	079b      	lsls	r3, r3, #30
     900:	d50b      	bpl.n	91a <_usart_init+0x42>
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
     902:	6823      	ldr	r3, [r4, #0]
     904:	2202      	movs	r2, #2
     906:	4393      	bics	r3, r2
     908:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     90a:	3201      	adds	r2, #1
     90c:	69e3      	ldr	r3, [r4, #28]
     90e:	421a      	tst	r2, r3
     910:	d1fc      	bne.n	90c <_usart_init+0x34>
     912:	2202      	movs	r2, #2
     914:	69e3      	ldr	r3, [r4, #28]
     916:	421a      	tst	r2, r3
     918:	d1fc      	bne.n	914 <_usart_init+0x3c>
}

static inline void hri_sercomusart_write_CTRLA_reg(const void *const hw, hri_sercomusart_ctrla_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg = data;
     91a:	2305      	movs	r3, #5
     91c:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     91e:	2203      	movs	r2, #3
     920:	69e3      	ldr	r3, [r4, #28]
     922:	421a      	tst	r2, r3
     924:	d1fc      	bne.n	920 <_usart_init+0x48>
     926:	2201      	movs	r2, #1
     928:	69e3      	ldr	r3, [r4, #28]
     92a:	421a      	tst	r2, r3
     92c:	d1fc      	bne.n	928 <_usart_init+0x50>
	((Sercom *)hw)->USART.CTRLA.reg = data;
     92e:	4b0e      	ldr	r3, [pc, #56]	; (968 <_usart_init+0x90>)
     930:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     932:	2203      	movs	r2, #3
     934:	69e3      	ldr	r3, [r4, #28]
     936:	421a      	tst	r2, r3
     938:	d1fc      	bne.n	934 <_usart_init+0x5c>
}

static inline void hri_sercomusart_write_CTRLB_reg(const void *const hw, hri_sercomusart_ctrlb_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLB.reg = data;
     93a:	23c0      	movs	r3, #192	; 0xc0
     93c:	029b      	lsls	r3, r3, #10
     93e:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     940:	2207      	movs	r2, #7
     942:	69e3      	ldr	r3, [r4, #28]
     944:	421a      	tst	r2, r3
     946:	d1fc      	bne.n	942 <_usart_init+0x6a>
}

static inline void hri_sercomusart_write_BAUD_reg(const void *const hw, hri_sercomusart_baud_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.BAUD.reg = data;
     948:	4b08      	ldr	r3, [pc, #32]	; (96c <_usart_init+0x94>)
     94a:	81a3      	strh	r3, [r4, #12]
}

static inline void hri_sercomusart_write_RXPL_reg(const void *const hw, hri_sercomusart_rxpl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.RXPL.reg = data;
     94c:	2300      	movs	r3, #0
     94e:	73a3      	strb	r3, [r4, #14]
}

static inline void hri_sercomusart_write_DBGCTRL_reg(const void *const hw, hri_sercomusart_dbgctrl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
     950:	2230      	movs	r2, #48	; 0x30
     952:	54a3      	strb	r3, [r4, r2]
}
     954:	2000      	movs	r0, #0
     956:	bd10      	pop	{r4, pc}
     958:	00000869 	.word	0x00000869
     95c:	00000261 	.word	0x00000261
     960:	000024c8 	.word	0x000024c8
     964:	0000067d 	.word	0x0000067d
     968:	40310004 	.word	0x40310004
     96c:	fffff62b 	.word	0xfffff62b

00000970 <_usart_async_init>:
{
     970:	b570      	push	{r4, r5, r6, lr}
     972:	0006      	movs	r6, r0
     974:	000c      	movs	r4, r1
	ASSERT(device);
     976:	1e43      	subs	r3, r0, #1
     978:	4198      	sbcs	r0, r3
     97a:	b2c0      	uxtb	r0, r0
     97c:	22c4      	movs	r2, #196	; 0xc4
     97e:	4913      	ldr	r1, [pc, #76]	; (9cc <_usart_async_init+0x5c>)
     980:	4b13      	ldr	r3, [pc, #76]	; (9d0 <_usart_async_init+0x60>)
     982:	4798      	blx	r3
	init_status = _usart_init(hw);
     984:	0020      	movs	r0, r4
     986:	4b13      	ldr	r3, [pc, #76]	; (9d4 <_usart_async_init+0x64>)
     988:	4798      	blx	r3
     98a:	1e05      	subs	r5, r0, #0
	if (init_status) {
     98c:	d001      	beq.n	992 <_usart_async_init+0x22>
}
     98e:	0028      	movs	r0, r5
     990:	bd70      	pop	{r4, r5, r6, pc}
	device->hw = hw;
     992:	61b4      	str	r4, [r6, #24]
	if (hw == SERCOM4) {
     994:	4b10      	ldr	r3, [pc, #64]	; (9d8 <_usart_async_init+0x68>)
     996:	429c      	cmp	r4, r3
     998:	d014      	beq.n	9c4 <_usart_async_init+0x54>
	NVIC_DisableIRQ((IRQn_Type)_sercom_get_irq_num(hw));
     99a:	0020      	movs	r0, r4
     99c:	4b0f      	ldr	r3, [pc, #60]	; (9dc <_usart_async_init+0x6c>)
     99e:	4798      	blx	r3
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
     9a0:	0603      	lsls	r3, r0, #24
     9a2:	d4f4      	bmi.n	98e <_usart_async_init+0x1e>
  {
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     9a4:	231f      	movs	r3, #31
     9a6:	4018      	ands	r0, r3
     9a8:	3b1e      	subs	r3, #30
     9aa:	4083      	lsls	r3, r0
     9ac:	4a0c      	ldr	r2, [pc, #48]	; (9e0 <_usart_async_init+0x70>)
     9ae:	2180      	movs	r1, #128	; 0x80
     9b0:	5053      	str	r3, [r2, r1]
  __ASM volatile ("dsb 0xF":::"memory");
     9b2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     9b6:	f3bf 8f6f 	isb	sy
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     9ba:	3101      	adds	r1, #1
     9bc:	31ff      	adds	r1, #255	; 0xff
     9be:	5053      	str	r3, [r2, r1]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     9c0:	6013      	str	r3, [r2, #0]
     9c2:	e7e4      	b.n	98e <_usart_async_init+0x1e>
		_sercom4_dev = (struct _usart_async_device *)dev;
     9c4:	4b07      	ldr	r3, [pc, #28]	; (9e4 <_usart_async_init+0x74>)
     9c6:	601e      	str	r6, [r3, #0]
     9c8:	e7e7      	b.n	99a <_usart_async_init+0x2a>
     9ca:	46c0      	nop			; (mov r8, r8)
     9cc:	000024c8 	.word	0x000024c8
     9d0:	0000067d 	.word	0x0000067d
     9d4:	000008d9 	.word	0x000008d9
     9d8:	42001400 	.word	0x42001400
     9dc:	000008a5 	.word	0x000008a5
     9e0:	e000e100 	.word	0xe000e100
     9e4:	20000040 	.word	0x20000040

000009e8 <_usart_async_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
     9e8:	6982      	ldr	r2, [r0, #24]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
     9ea:	6813      	ldr	r3, [r2, #0]
     9ec:	2102      	movs	r1, #2
     9ee:	430b      	orrs	r3, r1
     9f0:	6013      	str	r3, [r2, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     9f2:	3101      	adds	r1, #1
     9f4:	69d3      	ldr	r3, [r2, #28]
     9f6:	4219      	tst	r1, r3
     9f8:	d1fc      	bne.n	9f4 <_usart_async_enable+0xc>
}
     9fa:	4770      	bx	lr

000009fc <_usart_async_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
     9fc:	6983      	ldr	r3, [r0, #24]
     9fe:	b289      	uxth	r1, r1
	((Sercom *)hw)->USART.DATA.reg = data;
     a00:	8519      	strh	r1, [r3, #40]	; 0x28
}
     a02:	4770      	bx	lr

00000a04 <_usart_async_enable_byte_sent_irq>:
	hri_sercomusart_set_INTEN_DRE_bit(device->hw);
     a04:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
     a06:	2201      	movs	r2, #1
     a08:	759a      	strb	r2, [r3, #22]
}
     a0a:	4770      	bx	lr

00000a0c <_usart_async_enable_tx_done_irq>:
	hri_sercomusart_set_INTEN_TXC_bit(device->hw);
     a0c:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
     a0e:	2202      	movs	r2, #2
     a10:	759a      	strb	r2, [r3, #22]
}
     a12:	4770      	bx	lr

00000a14 <_usart_async_set_irq_state>:
{
     a14:	b570      	push	{r4, r5, r6, lr}
     a16:	0004      	movs	r4, r0
     a18:	000d      	movs	r5, r1
     a1a:	0016      	movs	r6, r2
	ASSERT(device);
     a1c:	1e43      	subs	r3, r0, #1
     a1e:	4198      	sbcs	r0, r3
     a20:	b2c0      	uxtb	r0, r0
     a22:	4a16      	ldr	r2, [pc, #88]	; (a7c <_usart_async_set_irq_state+0x68>)
     a24:	4916      	ldr	r1, [pc, #88]	; (a80 <_usart_async_set_irq_state+0x6c>)
     a26:	4b17      	ldr	r3, [pc, #92]	; (a84 <_usart_async_set_irq_state+0x70>)
     a28:	4798      	blx	r3
	if (USART_ASYNC_BYTE_SENT == type || USART_ASYNC_TX_DONE == type) {
     a2a:	2302      	movs	r3, #2
     a2c:	002a      	movs	r2, r5
     a2e:	439a      	bics	r2, r3
     a30:	d10e      	bne.n	a50 <_usart_async_set_irq_state+0x3c>
		hri_sercomusart_write_INTEN_DRE_bit(device->hw, state);
     a32:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
     a34:	2e00      	cmp	r6, #0
     a36:	d105      	bne.n	a44 <_usart_async_set_irq_state+0x30>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
     a38:	2201      	movs	r2, #1
     a3a:	751a      	strb	r2, [r3, #20]
		hri_sercomusart_write_INTEN_TXC_bit(device->hw, state);
     a3c:	69a3      	ldr	r3, [r4, #24]
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
     a3e:	3201      	adds	r2, #1
     a40:	751a      	strb	r2, [r3, #20]
}
     a42:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
     a44:	2201      	movs	r2, #1
     a46:	759a      	strb	r2, [r3, #22]
		hri_sercomusart_write_INTEN_TXC_bit(device->hw, state);
     a48:	69a3      	ldr	r3, [r4, #24]
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
     a4a:	3201      	adds	r2, #1
     a4c:	759a      	strb	r2, [r3, #22]
     a4e:	e7f8      	b.n	a42 <_usart_async_set_irq_state+0x2e>
	} else if (USART_ASYNC_RX_DONE == type) {
     a50:	2d01      	cmp	r5, #1
     a52:	d007      	beq.n	a64 <_usart_async_set_irq_state+0x50>
	} else if (USART_ASYNC_ERROR == type) {
     a54:	2d03      	cmp	r5, #3
     a56:	d1f4      	bne.n	a42 <_usart_async_set_irq_state+0x2e>
		hri_sercomusart_write_INTEN_ERROR_bit(device->hw, state);
     a58:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
     a5a:	2e00      	cmp	r6, #0
     a5c:	d00b      	beq.n	a76 <_usart_async_set_irq_state+0x62>
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_ERROR;
     a5e:	2280      	movs	r2, #128	; 0x80
     a60:	759a      	strb	r2, [r3, #22]
}
     a62:	e7ee      	b.n	a42 <_usart_async_set_irq_state+0x2e>
		hri_sercomusart_write_INTEN_RXC_bit(device->hw, state);
     a64:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
     a66:	2e00      	cmp	r6, #0
     a68:	d102      	bne.n	a70 <_usart_async_set_irq_state+0x5c>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_RXC;
     a6a:	2204      	movs	r2, #4
     a6c:	751a      	strb	r2, [r3, #20]
     a6e:	e7e8      	b.n	a42 <_usart_async_set_irq_state+0x2e>
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_RXC;
     a70:	2204      	movs	r2, #4
     a72:	759a      	strb	r2, [r3, #22]
     a74:	e7e5      	b.n	a42 <_usart_async_set_irq_state+0x2e>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_ERROR;
     a76:	2280      	movs	r2, #128	; 0x80
     a78:	751a      	strb	r2, [r3, #20]
     a7a:	e7e2      	b.n	a42 <_usart_async_set_irq_state+0x2e>
     a7c:	00000221 	.word	0x00000221
     a80:	000024c8 	.word	0x000024c8
     a84:	0000067d 	.word	0x0000067d

00000a88 <SERCOM4_Handler>:

	return NULL;
}

void SERCOM4_Handler(void)
{
     a88:	b510      	push	{r4, lr}
	_sercom_usart_interrupt_handler(_sercom4_dev);
     a8a:	4b19      	ldr	r3, [pc, #100]	; (af0 <SERCOM4_Handler+0x68>)
     a8c:	6818      	ldr	r0, [r3, #0]
	void *hw = device->hw;
     a8e:	6984      	ldr	r4, [r0, #24]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
     a90:	7e23      	ldrb	r3, [r4, #24]
	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
     a92:	07db      	lsls	r3, r3, #31
     a94:	d502      	bpl.n	a9c <SERCOM4_Handler+0x14>
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_DRE) >> SERCOM_USART_INTENSET_DRE_Pos;
     a96:	7da3      	ldrb	r3, [r4, #22]
     a98:	07db      	lsls	r3, r3, #31
     a9a:	d40f      	bmi.n	abc <SERCOM4_Handler+0x34>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
     a9c:	7e23      	ldrb	r3, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_TXC_bit(hw) && hri_sercomusart_get_INTEN_TXC_bit(hw)) {
     a9e:	079b      	lsls	r3, r3, #30
     aa0:	d502      	bpl.n	aa8 <SERCOM4_Handler+0x20>
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_TXC) >> SERCOM_USART_INTENSET_TXC_Pos;
     aa2:	7da3      	ldrb	r3, [r4, #22]
     aa4:	079b      	lsls	r3, r3, #30
     aa6:	d40e      	bmi.n	ac6 <SERCOM4_Handler+0x3e>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
     aa8:	7e23      	ldrb	r3, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_RXC_bit(hw)) {
     aaa:	075b      	lsls	r3, r3, #29
     aac:	d515      	bpl.n	ada <SERCOM4_Handler+0x52>
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_status_reg_t hri_sercomusart_read_STATUS_reg(const void *const hw)
{
	return ((Sercom *)hw)->USART.STATUS.reg;
     aae:	8b62      	ldrh	r2, [r4, #26]
		if (hri_sercomusart_read_STATUS_reg(hw)
     ab0:	2337      	movs	r3, #55	; 0x37
     ab2:	421a      	tst	r2, r3
     ab4:	d00c      	beq.n	ad0 <SERCOM4_Handler+0x48>
	((Sercom *)hw)->USART.STATUS.reg = mask;
     ab6:	3348      	adds	r3, #72	; 0x48
     ab8:	8363      	strh	r3, [r4, #26]
}
     aba:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
     abc:	2301      	movs	r3, #1
     abe:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_byte_sent(device);
     ac0:	6803      	ldr	r3, [r0, #0]
     ac2:	4798      	blx	r3
     ac4:	e7f9      	b.n	aba <SERCOM4_Handler+0x32>
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
     ac6:	2302      	movs	r3, #2
     ac8:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_done_cb(device);
     aca:	6883      	ldr	r3, [r0, #8]
     acc:	4798      	blx	r3
     ace:	e7f4      	b.n	aba <SERCOM4_Handler+0x32>
	return ((Sercom *)hw)->USART.DATA.reg;
     ad0:	8d21      	ldrh	r1, [r4, #40]	; 0x28
		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
     ad2:	b2c9      	uxtb	r1, r1
     ad4:	6843      	ldr	r3, [r0, #4]
     ad6:	4798      	blx	r3
     ad8:	e7ef      	b.n	aba <SERCOM4_Handler+0x32>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_ERROR) >> SERCOM_USART_INTFLAG_ERROR_Pos;
     ada:	7e23      	ldrb	r3, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_ERROR_bit(hw)) {
     adc:	09db      	lsrs	r3, r3, #7
     ade:	d0ec      	beq.n	aba <SERCOM4_Handler+0x32>
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
     ae0:	2380      	movs	r3, #128	; 0x80
     ae2:	7623      	strb	r3, [r4, #24]
		device->usart_cb.error_cb(device);
     ae4:	68c3      	ldr	r3, [r0, #12]
     ae6:	4798      	blx	r3
	return ((Sercom *)hw)->USART.STATUS.reg;
     ae8:	8b63      	ldrh	r3, [r4, #26]
     aea:	b29b      	uxth	r3, r3
	((Sercom *)hw)->USART.STATUS.reg = mask;
     aec:	8363      	strh	r3, [r4, #26]
}
     aee:	e7e4      	b.n	aba <SERCOM4_Handler+0x32>
     af0:	20000040 	.word	0x20000040

00000af4 <_delay_init>:
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
     af4:	4b02      	ldr	r3, [pc, #8]	; (b00 <_delay_init+0xc>)
     af6:	4a03      	ldr	r2, [pc, #12]	; (b04 <_delay_init+0x10>)
     af8:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
     afa:	2205      	movs	r2, #5
     afc:	601a      	str	r2, [r3, #0]
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
	_system_time_init(hw);
}
     afe:	4770      	bx	lr
     b00:	e000e010 	.word	0xe000e010
     b04:	00ffffff 	.word	0x00ffffff

00000b08 <_delay_cycles>:
}
/**
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
     b08:	b570      	push	{r4, r5, r6, lr}
	(void)hw;
	uint8_t  n   = cycles >> 24;
     b0a:	0e0b      	lsrs	r3, r1, #24
	uint32_t buf = cycles;

	while (n--) {
     b0c:	1e5e      	subs	r6, r3, #1
     b0e:	b2f6      	uxtb	r6, r6
     b10:	2b00      	cmp	r3, #0
     b12:	d013      	beq.n	b3c <_delay_cycles+0x34>
     b14:	0034      	movs	r4, r6
		SysTick->LOAD = 0xFFFFFF;
     b16:	4a0e      	ldr	r2, [pc, #56]	; (b50 <_delay_cycles+0x48>)
     b18:	4d0e      	ldr	r5, [pc, #56]	; (b54 <_delay_cycles+0x4c>)
		SysTick->VAL  = 0xFFFFFF;
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
     b1a:	2080      	movs	r0, #128	; 0x80
     b1c:	0240      	lsls	r0, r0, #9
		SysTick->LOAD = 0xFFFFFF;
     b1e:	6055      	str	r5, [r2, #4]
		SysTick->VAL  = 0xFFFFFF;
     b20:	6095      	str	r5, [r2, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
     b22:	6813      	ldr	r3, [r2, #0]
     b24:	4203      	tst	r3, r0
     b26:	d0fc      	beq.n	b22 <_delay_cycles+0x1a>
	while (n--) {
     b28:	3c01      	subs	r4, #1
     b2a:	b2e4      	uxtb	r4, r4
     b2c:	2cff      	cmp	r4, #255	; 0xff
     b2e:	d1f6      	bne.n	b1e <_delay_cycles+0x16>
     b30:	0633      	lsls	r3, r6, #24
     b32:	1af6      	subs	r6, r6, r3
     b34:	4b08      	ldr	r3, [pc, #32]	; (b58 <_delay_cycles+0x50>)
     b36:	469c      	mov	ip, r3
     b38:	4461      	add	r1, ip
     b3a:	1871      	adds	r1, r6, r1
			;
		buf -= 0xFFFFFF;
	}

	SysTick->LOAD = buf;
     b3c:	4b04      	ldr	r3, [pc, #16]	; (b50 <_delay_cycles+0x48>)
     b3e:	6059      	str	r1, [r3, #4]
	SysTick->VAL  = buf;
     b40:	6099      	str	r1, [r3, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
     b42:	0019      	movs	r1, r3
     b44:	2280      	movs	r2, #128	; 0x80
     b46:	0252      	lsls	r2, r2, #9
     b48:	680b      	ldr	r3, [r1, #0]
     b4a:	4213      	tst	r3, r2
     b4c:	d0fc      	beq.n	b48 <_delay_cycles+0x40>
		;
}
     b4e:	bd70      	pop	{r4, r5, r6, pc}
     b50:	e000e010 	.word	0xe000e010
     b54:	00ffffff 	.word	0x00ffffff
     b58:	ff000001 	.word	0xff000001

00000b5c <main>:
#include <atmel_start.h>
#include <driver_examples.h>
#include "rtos_start.h"

int main(void)
{
     b5c:	b570      	push	{r4, r5, r6, lr}
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     b5e:	4b06      	ldr	r3, [pc, #24]	; (b78 <main+0x1c>)
     b60:	4798      	blx	r3
	FREERTOS_V1000_0_example();
     b62:	4b06      	ldr	r3, [pc, #24]	; (b7c <main+0x20>)
     b64:	4798      	blx	r3

	/* Replace with your application code */
	while (1) {
	USART_On_USBPort_example();
     b66:	4e06      	ldr	r6, [pc, #24]	; (b80 <main+0x24>)
	delay_ms(1000);
     b68:	25fa      	movs	r5, #250	; 0xfa
     b6a:	00ad      	lsls	r5, r5, #2
     b6c:	4c05      	ldr	r4, [pc, #20]	; (b84 <main+0x28>)
	USART_On_USBPort_example();
     b6e:	47b0      	blx	r6
	delay_ms(1000);
     b70:	0028      	movs	r0, r5
     b72:	47a0      	blx	r4
     b74:	e7fb      	b.n	b6e <main+0x12>
     b76:	46c0      	nop			; (mov r8, r8)
     b78:	0000011d 	.word	0x0000011d
     b7c:	00000bcd 	.word	0x00000bcd
     b80:	00000285 	.word	0x00000285
     b84:	000002fd 	.word	0x000002fd

00000b88 <example_task>:
 *
 * \param[in] p The void pointer for OS task Standard model.
 *
 */
static void example_task(void *p)
{
     b88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	(void)p;
	while (1) {
		if (xSemaphoreTake(disp_mutex, ~0)) {
     b8a:	4d0b      	ldr	r5, [pc, #44]	; (bb8 <example_task+0x30>)
     b8c:	4c0b      	ldr	r4, [pc, #44]	; (bbc <example_task+0x34>)
			/* add your code */
				USART_On_USBPort_example();
     b8e:	4f0c      	ldr	r7, [pc, #48]	; (bc0 <example_task+0x38>)
     b90:	e003      	b.n	b9a <example_task+0x12>
//				delay_ms(1000);
			xSemaphoreGive(disp_mutex);
		}
		os_sleep(500);
     b92:	20fa      	movs	r0, #250	; 0xfa
     b94:	0040      	lsls	r0, r0, #1
     b96:	4b0b      	ldr	r3, [pc, #44]	; (bc4 <example_task+0x3c>)
     b98:	4798      	blx	r3
		if (xSemaphoreTake(disp_mutex, ~0)) {
     b9a:	2101      	movs	r1, #1
     b9c:	4249      	negs	r1, r1
     b9e:	6828      	ldr	r0, [r5, #0]
     ba0:	47a0      	blx	r4
     ba2:	2800      	cmp	r0, #0
     ba4:	d0f5      	beq.n	b92 <example_task+0xa>
				USART_On_USBPort_example();
     ba6:	47b8      	blx	r7
			xSemaphoreGive(disp_mutex);
     ba8:	4b03      	ldr	r3, [pc, #12]	; (bb8 <example_task+0x30>)
     baa:	6818      	ldr	r0, [r3, #0]
     bac:	2300      	movs	r3, #0
     bae:	2200      	movs	r2, #0
     bb0:	2100      	movs	r1, #0
     bb2:	4e05      	ldr	r6, [pc, #20]	; (bc8 <example_task+0x40>)
     bb4:	47b0      	blx	r6
     bb6:	e7ec      	b.n	b92 <example_task+0xa>
     bb8:	20000044 	.word	0x20000044
     bbc:	00001555 	.word	0x00001555
     bc0:	00000285 	.word	0x00000285
     bc4:	00001c49 	.word	0x00001c49
     bc8:	00001179 	.word	0x00001179

00000bcc <FREERTOS_V1000_0_example>:

/*
 * Example
 */
void FREERTOS_V1000_0_example(void)
{
     bcc:	b510      	push	{r4, lr}
     bce:	b082      	sub	sp, #8
	disp_mutex = xSemaphoreCreateMutex();
     bd0:	2001      	movs	r0, #1
     bd2:	4b0c      	ldr	r3, [pc, #48]	; (c04 <FREERTOS_V1000_0_example+0x38>)
     bd4:	4798      	blx	r3
     bd6:	4b0c      	ldr	r3, [pc, #48]	; (c08 <FREERTOS_V1000_0_example+0x3c>)
     bd8:	6018      	str	r0, [r3, #0]

	if (disp_mutex == NULL) {
     bda:	2800      	cmp	r0, #0
     bdc:	d100      	bne.n	be0 <FREERTOS_V1000_0_example+0x14>
     bde:	e7fe      	b.n	bde <FREERTOS_V1000_0_example+0x12>
		while (1) {
			;
		}
	}

	if (xTaskCreate(
     be0:	2300      	movs	r3, #0
     be2:	9301      	str	r3, [sp, #4]
     be4:	3301      	adds	r3, #1
     be6:	9300      	str	r3, [sp, #0]
     be8:	2300      	movs	r3, #0
     bea:	2220      	movs	r2, #32
     bec:	4907      	ldr	r1, [pc, #28]	; (c0c <FREERTOS_V1000_0_example+0x40>)
     bee:	4808      	ldr	r0, [pc, #32]	; (c10 <FREERTOS_V1000_0_example+0x44>)
     bf0:	4c08      	ldr	r4, [pc, #32]	; (c14 <FREERTOS_V1000_0_example+0x48>)
     bf2:	47a0      	blx	r4
     bf4:	2801      	cmp	r0, #1
     bf6:	d000      	beq.n	bfa <FREERTOS_V1000_0_example+0x2e>
     bf8:	e7fe      	b.n	bf8 <FREERTOS_V1000_0_example+0x2c>
		while (1) {
			;
		}
	}

	vTaskStartScheduler();
     bfa:	4b07      	ldr	r3, [pc, #28]	; (c18 <FREERTOS_V1000_0_example+0x4c>)
     bfc:	4798      	blx	r3

	return;
}
     bfe:	b002      	add	sp, #8
     c00:	bd10      	pop	{r4, pc}
     c02:	46c0      	nop			; (mov r8, r8)
     c04:	00001305 	.word	0x00001305
     c08:	20000044 	.word	0x20000044
     c0c:	000024e4 	.word	0x000024e4
     c10:	00000b89 	.word	0x00000b89
     c14:	000017fd 	.word	0x000017fd
     c18:	000019c9 	.word	0x000019c9

00000c1c <vListInitialise>:
void vListInitialise(List_t *const pxList)
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = (ListItem_t *)&(
     c1c:	0003      	movs	r3, r0
     c1e:	3308      	adds	r3, #8
     c20:	6043      	str	r3, [r0, #4]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     c22:	2201      	movs	r2, #1
     c24:	4252      	negs	r2, r2
     c26:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = (ListItem_t *)&(pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as
     c28:	60c3      	str	r3, [r0, #12]
	                                                                the list end to save RAM.  This is checked and
	                                                                valid. */
	pxList->xListEnd.pxPrevious = (ListItem_t *)&(
     c2a:	6103      	str	r3, [r0, #16]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	pxList->uxNumberOfItems = (UBaseType_t)0U;
     c2c:	2300      	movs	r3, #0
     c2e:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE(pxList);
	listSET_LIST_INTEGRITY_CHECK_2_VALUE(pxList);
}
     c30:	4770      	bx	lr

00000c32 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem(ListItem_t *const pxItem)
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     c32:	2300      	movs	r3, #0
     c34:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
}
     c36:	4770      	bx	lr

00000c38 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
	ListItem_t *const pxIndex = pxList->pxIndex;
     c38:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
     c3a:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     c3c:	689a      	ldr	r2, [r3, #8]
     c3e:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     c40:	689a      	ldr	r2, [r3, #8]
     c42:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious         = pxNewListItem;
     c44:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;
     c46:	6108      	str	r0, [r1, #16]

	(pxList->uxNumberOfItems)++;
     c48:	6803      	ldr	r3, [r0, #0]
     c4a:	3301      	adds	r3, #1
     c4c:	6003      	str	r3, [r0, #0]
}
     c4e:	4770      	bx	lr

00000c50 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert(List_t *const pxList, ListItem_t *const pxNewListItem)
{
     c50:	b530      	push	{r4, r5, lr}
	ListItem_t *     pxIterator;
	const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     c52:	680c      	ldr	r4, [r1, #0]
		    4) Using a queue or semaphore before it has been initialised or
		       before the scheduler has been started (are interrupts firing
		       before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
     c54:	0002      	movs	r2, r0
     c56:	3208      	adds	r2, #8
	if (xValueOfInsertion == portMAX_DELAY) {
     c58:	1c63      	adds	r3, r4, #1
     c5a:	d102      	bne.n	c62 <vListInsert+0x12>
		pxIterator = pxList->xListEnd.pxPrevious;
     c5c:	6902      	ldr	r2, [r0, #16]
     c5e:	e004      	b.n	c6a <vListInsert+0x1a>
		     pxIterator
		     = pxIterator
     c60:	001a      	movs	r2, r3
		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
     c62:	6853      	ldr	r3, [r2, #4]
     c64:	681d      	ldr	r5, [r3, #0]
     c66:	42ac      	cmp	r4, r5
     c68:	d2fa      	bcs.n	c60 <vListInsert+0x10>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext             = pxIterator->pxNext;
     c6a:	6853      	ldr	r3, [r2, #4]
     c6c:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     c6e:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious         = pxIterator;
     c70:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext                = pxNewListItem;
     c72:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = (void *)pxList;
     c74:	6108      	str	r0, [r1, #16]

	(pxList->uxNumberOfItems)++;
     c76:	6803      	ldr	r3, [r0, #0]
     c78:	3301      	adds	r3, #1
     c7a:	6003      	str	r3, [r0, #0]
}
     c7c:	bd30      	pop	{r4, r5, pc}

00000c7e <uxListRemove>:

UBaseType_t uxListRemove(ListItem_t *const pxItemToRemove)
{
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
     c7e:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     c80:	6842      	ldr	r2, [r0, #4]
     c82:	6881      	ldr	r1, [r0, #8]
     c84:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     c86:	6882      	ldr	r2, [r0, #8]
     c88:	6841      	ldr	r1, [r0, #4]
     c8a:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
     c8c:	685a      	ldr	r2, [r3, #4]
     c8e:	4290      	cmp	r0, r2
     c90:	d006      	beq.n	ca0 <uxListRemove+0x22>
		pxList->pxIndex = pxItemToRemove->pxPrevious;
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     c92:	2200      	movs	r2, #0
     c94:	6102      	str	r2, [r0, #16]
	(pxList->uxNumberOfItems)--;
     c96:	681a      	ldr	r2, [r3, #0]
     c98:	3a01      	subs	r2, #1
     c9a:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
     c9c:	6818      	ldr	r0, [r3, #0]
}
     c9e:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     ca0:	6882      	ldr	r2, [r0, #8]
     ca2:	605a      	str	r2, [r3, #4]
     ca4:	e7f5      	b.n	c92 <uxListRemove+0x14>
	...

00000ca8 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError(void)
{
     ca8:	b082      	sub	sp, #8
	volatile uint32_t ulDummy = 0UL;
     caa:	2300      	movs	r3, #0
     cac:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT(uxCriticalNesting == ~0UL);
     cae:	4b06      	ldr	r3, [pc, #24]	; (cc8 <prvTaskExitError+0x20>)
     cb0:	681b      	ldr	r3, [r3, #0]
     cb2:	3301      	adds	r3, #1
     cb4:	d001      	beq.n	cba <prvTaskExitError+0x12>
     cb6:	b672      	cpsid	i
     cb8:	e7fe      	b.n	cb8 <prvTaskExitError+0x10>
	portDISABLE_INTERRUPTS();
     cba:	b672      	cpsid	i
	while (ulDummy == 0) {
     cbc:	9b01      	ldr	r3, [sp, #4]
     cbe:	2b00      	cmp	r3, #0
     cc0:	d0fc      	beq.n	cbc <prvTaskExitError+0x14>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
     cc2:	b002      	add	sp, #8
     cc4:	4770      	bx	lr
     cc6:	46c0      	nop			; (mov r8, r8)
     cc8:	2000000c 	.word	0x2000000c
     ccc:	00000000 	.word	0x00000000

00000cd0 <vPortStartFirstTask>:
void vPortStartFirstTask(void)
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
     cd0:	4a0b      	ldr	r2, [pc, #44]	; (d00 <pxCurrentTCBConst2>)
     cd2:	6813      	ldr	r3, [r2, #0]
     cd4:	6818      	ldr	r0, [r3, #0]
     cd6:	3020      	adds	r0, #32
     cd8:	f380 8809 	msr	PSP, r0
     cdc:	2002      	movs	r0, #2
     cde:	f380 8814 	msr	CONTROL, r0
     ce2:	f3bf 8f6f 	isb	sy
     ce6:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
     ce8:	46ae      	mov	lr, r5
     cea:	bc08      	pop	{r3}
     cec:	bc04      	pop	{r2}
     cee:	b662      	cpsie	i
     cf0:	4718      	bx	r3
     cf2:	46c0      	nop			; (mov r8, r8)
     cf4:	46c0      	nop			; (mov r8, r8)
     cf6:	46c0      	nop			; (mov r8, r8)
     cf8:	46c0      	nop			; (mov r8, r8)
     cfa:	46c0      	nop			; (mov r8, r8)
     cfc:	46c0      	nop			; (mov r8, r8)
     cfe:	46c0      	nop			; (mov r8, r8)

00000d00 <pxCurrentTCBConst2>:
     d00:	20000a48 	.word	0x20000a48

00000d04 <pxPortInitialiseStack>:
{
     d04:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR; /* xPSR */
     d06:	1f03      	subs	r3, r0, #4
     d08:	2480      	movs	r4, #128	; 0x80
     d0a:	0464      	lsls	r4, r4, #17
     d0c:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = (StackType_t)pxCode; /* PC */
     d0e:	3b04      	subs	r3, #4
     d10:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */
     d12:	3b04      	subs	r3, #4
     d14:	4902      	ldr	r1, [pc, #8]	; (d20 <pxPortInitialiseStack+0x1c>)
     d16:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = (StackType_t)pvParameters;            /* R0 */
     d18:	3b14      	subs	r3, #20
     d1a:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;                                    /* R11..R4. */
     d1c:	3840      	subs	r0, #64	; 0x40
}
     d1e:	bd10      	pop	{r4, pc}
     d20:	00000ca9 	.word	0x00000ca9

00000d24 <SVCall_Handler>:
}
     d24:	4770      	bx	lr
	...

00000d28 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler(void)
{
     d28:	b510      	push	{r4, lr}
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
     d2a:	4b0f      	ldr	r3, [pc, #60]	; (d68 <xPortStartScheduler+0x40>)
     d2c:	6819      	ldr	r1, [r3, #0]
     d2e:	22ff      	movs	r2, #255	; 0xff
     d30:	0412      	lsls	r2, r2, #16
     d32:	430a      	orrs	r2, r1
     d34:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
     d36:	6819      	ldr	r1, [r3, #0]
     d38:	22ff      	movs	r2, #255	; 0xff
     d3a:	0612      	lsls	r2, r2, #24
     d3c:	430a      	orrs	r2, r1
     d3e:	601a      	str	r2, [r3, #0]
 * frequency.
 */
void prvSetupTimerInterrupt(void)
{
	/* Stop and reset the SysTick. */
	*(portNVIC_SYSTICK_CTRL)          = 0UL;
     d40:	4a0a      	ldr	r2, [pc, #40]	; (d6c <xPortStartScheduler+0x44>)
     d42:	2300      	movs	r3, #0
     d44:	6013      	str	r3, [r2, #0]
	*(portNVIC_SYSTICK_CURRENT_VALUE) = 0UL;
     d46:	490a      	ldr	r1, [pc, #40]	; (d70 <xPortStartScheduler+0x48>)
     d48:	600b      	str	r3, [r1, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = (configCPU_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
     d4a:	480a      	ldr	r0, [pc, #40]	; (d74 <xPortStartScheduler+0x4c>)
     d4c:	490a      	ldr	r1, [pc, #40]	; (d78 <xPortStartScheduler+0x50>)
     d4e:	6008      	str	r0, [r1, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
     d50:	2107      	movs	r1, #7
     d52:	6011      	str	r1, [r2, #0]
	uxCriticalNesting = 0;
     d54:	4a09      	ldr	r2, [pc, #36]	; (d7c <xPortStartScheduler+0x54>)
     d56:	6013      	str	r3, [r2, #0]
	vPortStartFirstTask();
     d58:	4b09      	ldr	r3, [pc, #36]	; (d80 <xPortStartScheduler+0x58>)
     d5a:	4798      	blx	r3
	vTaskSwitchContext();
     d5c:	4b09      	ldr	r3, [pc, #36]	; (d84 <xPortStartScheduler+0x5c>)
     d5e:	4798      	blx	r3
	prvTaskExitError();
     d60:	4b09      	ldr	r3, [pc, #36]	; (d88 <xPortStartScheduler+0x60>)
     d62:	4798      	blx	r3
}
     d64:	2000      	movs	r0, #0
     d66:	bd10      	pop	{r4, pc}
     d68:	e000ed20 	.word	0xe000ed20
     d6c:	e000e010 	.word	0xe000e010
     d70:	e000e018 	.word	0xe000e018
     d74:	00000f9f 	.word	0x00000f9f
     d78:	e000e014 	.word	0xe000e014
     d7c:	2000000c 	.word	0x2000000c
     d80:	00000cd1 	.word	0x00000cd1
     d84:	00001c89 	.word	0x00001c89
     d88:	00000ca9 	.word	0x00000ca9

00000d8c <vPortYield>:
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
     d8c:	2280      	movs	r2, #128	; 0x80
     d8e:	0552      	lsls	r2, r2, #21
     d90:	4b03      	ldr	r3, [pc, #12]	; (da0 <vPortYield+0x14>)
     d92:	601a      	str	r2, [r3, #0]
	__asm volatile("dsb" ::: "memory");
     d94:	f3bf 8f4f 	dsb	sy
	__asm volatile("isb");
     d98:	f3bf 8f6f 	isb	sy
}
     d9c:	4770      	bx	lr
     d9e:	46c0      	nop			; (mov r8, r8)
     da0:	e000ed04 	.word	0xe000ed04

00000da4 <vPortEnterCritical>:
	portDISABLE_INTERRUPTS();
     da4:	b672      	cpsid	i
	uxCriticalNesting++;
     da6:	4a04      	ldr	r2, [pc, #16]	; (db8 <vPortEnterCritical+0x14>)
     da8:	6813      	ldr	r3, [r2, #0]
     daa:	3301      	adds	r3, #1
     dac:	6013      	str	r3, [r2, #0]
	__asm volatile("dsb" ::: "memory");
     dae:	f3bf 8f4f 	dsb	sy
	__asm volatile("isb");
     db2:	f3bf 8f6f 	isb	sy
}
     db6:	4770      	bx	lr
     db8:	2000000c 	.word	0x2000000c

00000dbc <vPortExitCritical>:
	configASSERT(uxCriticalNesting);
     dbc:	4b06      	ldr	r3, [pc, #24]	; (dd8 <vPortExitCritical+0x1c>)
     dbe:	681b      	ldr	r3, [r3, #0]
     dc0:	2b00      	cmp	r3, #0
     dc2:	d101      	bne.n	dc8 <vPortExitCritical+0xc>
     dc4:	b672      	cpsid	i
     dc6:	e7fe      	b.n	dc6 <vPortExitCritical+0xa>
	uxCriticalNesting--;
     dc8:	3b01      	subs	r3, #1
     dca:	4a03      	ldr	r2, [pc, #12]	; (dd8 <vPortExitCritical+0x1c>)
     dcc:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
     dce:	2b00      	cmp	r3, #0
     dd0:	d100      	bne.n	dd4 <vPortExitCritical+0x18>
		portENABLE_INTERRUPTS();
     dd2:	b662      	cpsie	i
}
     dd4:	4770      	bx	lr
     dd6:	46c0      	nop			; (mov r8, r8)
     dd8:	2000000c 	.word	0x2000000c

00000ddc <ulSetInterruptMaskFromISR>:
	__asm volatile(" mrs r0, PRIMASK	\n"
     ddc:	f3ef 8010 	mrs	r0, PRIMASK
     de0:	b672      	cpsid	i
     de2:	4770      	bx	lr

00000de4 <vClearInterruptMaskFromISR>:
	__asm volatile(" msr PRIMASK, r0	\n"
     de4:	f380 8810 	msr	PRIMASK, r0
     de8:	4770      	bx	lr
     dea:	0000      	movs	r0, r0
     dec:	0000      	movs	r0, r0
	...

00000df0 <PendSV_Handler>:
	__asm volatile(
     df0:	f3ef 8009 	mrs	r0, PSP
     df4:	4b0e      	ldr	r3, [pc, #56]	; (e30 <pxCurrentTCBConst>)
     df6:	681a      	ldr	r2, [r3, #0]
     df8:	3820      	subs	r0, #32
     dfa:	6010      	str	r0, [r2, #0]
     dfc:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     dfe:	4644      	mov	r4, r8
     e00:	464d      	mov	r5, r9
     e02:	4656      	mov	r6, sl
     e04:	465f      	mov	r7, fp
     e06:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     e08:	b508      	push	{r3, lr}
     e0a:	b672      	cpsid	i
     e0c:	f000 ff3c 	bl	1c88 <vTaskSwitchContext>
     e10:	b662      	cpsie	i
     e12:	bc0c      	pop	{r2, r3}
     e14:	6811      	ldr	r1, [r2, #0]
     e16:	6808      	ldr	r0, [r1, #0]
     e18:	3010      	adds	r0, #16
     e1a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     e1c:	46a0      	mov	r8, r4
     e1e:	46a9      	mov	r9, r5
     e20:	46b2      	mov	sl, r6
     e22:	46bb      	mov	fp, r7
     e24:	f380 8809 	msr	PSP, r0
     e28:	3820      	subs	r0, #32
     e2a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     e2c:	4718      	bx	r3
     e2e:	46c0      	nop			; (mov r8, r8)

00000e30 <pxCurrentTCBConst>:
     e30:	20000a48 	.word	0x20000a48

00000e34 <SysTick_Handler>:
{
     e34:	b510      	push	{r4, lr}
	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
     e36:	4b07      	ldr	r3, [pc, #28]	; (e54 <SysTick_Handler+0x20>)
     e38:	4798      	blx	r3
     e3a:	0004      	movs	r4, r0
		if (xTaskIncrementTick() != pdFALSE) {
     e3c:	4b06      	ldr	r3, [pc, #24]	; (e58 <SysTick_Handler+0x24>)
     e3e:	4798      	blx	r3
     e40:	2800      	cmp	r0, #0
     e42:	d003      	beq.n	e4c <SysTick_Handler+0x18>
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
     e44:	2280      	movs	r2, #128	; 0x80
     e46:	0552      	lsls	r2, r2, #21
     e48:	4b04      	ldr	r3, [pc, #16]	; (e5c <SysTick_Handler+0x28>)
     e4a:	601a      	str	r2, [r3, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR(ulPreviousMask);
     e4c:	0020      	movs	r0, r4
     e4e:	4b04      	ldr	r3, [pc, #16]	; (e60 <SysTick_Handler+0x2c>)
     e50:	4798      	blx	r3
}
     e52:	bd10      	pop	{r4, pc}
     e54:	00000ddd 	.word	0x00000ddd
     e58:	00001a4d 	.word	0x00001a4d
     e5c:	e000ed04 	.word	0xe000ed04
     e60:	00000de5 	.word	0x00000de5

00000e64 <pvPortMalloc>:
static size_t xNextFreeByte = (size_t)0;

/*-----------------------------------------------------------*/

void *pvPortMalloc(size_t xWantedSize)
{
     e64:	b570      	push	{r4, r5, r6, lr}
     e66:	0004      	movs	r4, r0
	static uint8_t *pucAlignedHeap = NULL;

/* Ensure that blocks are always aligned to the required number of bytes. */
#if (portBYTE_ALIGNMENT != 1)
	{
		if (xWantedSize & portBYTE_ALIGNMENT_MASK) {
     e68:	0743      	lsls	r3, r0, #29
     e6a:	d002      	beq.n	e72 <pvPortMalloc+0xe>
			/* Byte alignment required. */
			xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
     e6c:	2307      	movs	r3, #7
     e6e:	439c      	bics	r4, r3
     e70:	3408      	adds	r4, #8
		}
	}
#endif

	vTaskSuspendAll();
     e72:	4b11      	ldr	r3, [pc, #68]	; (eb8 <pvPortMalloc+0x54>)
     e74:	4798      	blx	r3
	{
		if (pucAlignedHeap == NULL) {
     e76:	4b11      	ldr	r3, [pc, #68]	; (ebc <pvPortMalloc+0x58>)
     e78:	681b      	ldr	r3, [r3, #0]
     e7a:	2b00      	cmp	r3, #0
     e7c:	d010      	beq.n	ea0 <pvPortMalloc+0x3c>
			pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
			                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
		}

		/* Check there is enough room left for the allocation. */
		if (((xNextFreeByte + xWantedSize) < configADJUSTED_HEAP_SIZE)
     e7e:	4b10      	ldr	r3, [pc, #64]	; (ec0 <pvPortMalloc+0x5c>)
     e80:	6e5b      	ldr	r3, [r3, #100]	; 0x64
     e82:	18e4      	adds	r4, r4, r3
     e84:	4a0f      	ldr	r2, [pc, #60]	; (ec4 <pvPortMalloc+0x60>)
     e86:	4294      	cmp	r4, r2
     e88:	d811      	bhi.n	eae <pvPortMalloc+0x4a>
		    && ((xNextFreeByte + xWantedSize) > xNextFreeByte)) /* Check for overflow. */
     e8a:	42a3      	cmp	r3, r4
     e8c:	d211      	bcs.n	eb2 <pvPortMalloc+0x4e>
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     e8e:	4a0b      	ldr	r2, [pc, #44]	; (ebc <pvPortMalloc+0x58>)
     e90:	6815      	ldr	r5, [r2, #0]
     e92:	18ed      	adds	r5, r5, r3
			xNextFreeByte += xWantedSize;
     e94:	4b0a      	ldr	r3, [pc, #40]	; (ec0 <pvPortMalloc+0x5c>)
     e96:	665c      	str	r4, [r3, #100]	; 0x64
		}

		traceMALLOC(pvReturn, xWantedSize);
	}
	(void)xTaskResumeAll();
     e98:	4b0b      	ldr	r3, [pc, #44]	; (ec8 <pvPortMalloc+0x64>)
     e9a:	4798      	blx	r3
		}
	}
#endif

	return pvReturn;
}
     e9c:	0028      	movs	r0, r5
     e9e:	bd70      	pop	{r4, r5, r6, pc}
			pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
     ea0:	4a06      	ldr	r2, [pc, #24]	; (ebc <pvPortMalloc+0x58>)
     ea2:	0013      	movs	r3, r2
     ea4:	330c      	adds	r3, #12
			                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
     ea6:	2107      	movs	r1, #7
     ea8:	438b      	bics	r3, r1
			pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
     eaa:	6013      	str	r3, [r2, #0]
     eac:	e7e7      	b.n	e7e <pvPortMalloc+0x1a>
	void *          pvReturn       = NULL;
     eae:	2500      	movs	r5, #0
     eb0:	e7f2      	b.n	e98 <pvPortMalloc+0x34>
     eb2:	2500      	movs	r5, #0
     eb4:	e7f0      	b.n	e98 <pvPortMalloc+0x34>
     eb6:	46c0      	nop			; (mov r8, r8)
     eb8:	00001a31 	.word	0x00001a31
     ebc:	20000048 	.word	0x20000048
     ec0:	20000948 	.word	0x20000948
     ec4:	00000957 	.word	0x00000957
     ec8:	00001b59 	.word	0x00001b59

00000ecc <vPortFree>:
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	(void)pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT(pv == NULL);
     ecc:	2800      	cmp	r0, #0
     ece:	d001      	beq.n	ed4 <vPortFree+0x8>
     ed0:	b672      	cpsid	i
     ed2:	e7fe      	b.n	ed2 <vPortFree+0x6>
}
     ed4:	4770      	bx	lr
	...

00000ed8 <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty(const Queue_t *pxQueue)
{
     ed8:	b510      	push	{r4, lr}
     eda:	0004      	movs	r4, r0
	BaseType_t xReturn;

	taskENTER_CRITICAL();
     edc:	4b03      	ldr	r3, [pc, #12]	; (eec <prvIsQueueEmpty+0x14>)
     ede:	4798      	blx	r3
	{
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
     ee0:	6ba4      	ldr	r4, [r4, #56]	; 0x38
			xReturn = pdTRUE;
		} else {
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     ee2:	4b03      	ldr	r3, [pc, #12]	; (ef0 <prvIsQueueEmpty+0x18>)
     ee4:	4798      	blx	r3
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
     ee6:	4260      	negs	r0, r4
     ee8:	4160      	adcs	r0, r4

	return xReturn;
}
     eea:	bd10      	pop	{r4, pc}
     eec:	00000da5 	.word	0x00000da5
     ef0:	00000dbd 	.word	0x00000dbd

00000ef4 <prvCopyDataToQueue>:
{
     ef4:	b570      	push	{r4, r5, r6, lr}
     ef6:	0004      	movs	r4, r0
     ef8:	0016      	movs	r6, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     efa:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
     efc:	6c02      	ldr	r2, [r0, #64]	; 0x40
     efe:	2a00      	cmp	r2, #0
     f00:	d10b      	bne.n	f1a <prvCopyDataToQueue+0x26>
	BaseType_t  xReturn = pdFALSE;
     f02:	2000      	movs	r0, #0
			if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
     f04:	6823      	ldr	r3, [r4, #0]
     f06:	4283      	cmp	r3, r0
     f08:	d104      	bne.n	f14 <prvCopyDataToQueue+0x20>
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
     f0a:	6860      	ldr	r0, [r4, #4]
     f0c:	4b16      	ldr	r3, [pc, #88]	; (f68 <prvCopyDataToQueue+0x74>)
     f0e:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
     f10:	2300      	movs	r3, #0
     f12:	6063      	str	r3, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + (UBaseType_t)1;
     f14:	3501      	adds	r5, #1
     f16:	63a5      	str	r5, [r4, #56]	; 0x38
}
     f18:	bd70      	pop	{r4, r5, r6, pc}
	} else if (xPosition == queueSEND_TO_BACK) {
     f1a:	2e00      	cmp	r6, #0
     f1c:	d10e      	bne.n	f3c <prvCopyDataToQueue+0x48>
		(void)memcpy((void *)pxQueue->pcWriteTo,
     f1e:	6880      	ldr	r0, [r0, #8]
     f20:	4b12      	ldr	r3, [pc, #72]	; (f6c <prvCopyDataToQueue+0x78>)
     f22:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     f24:	68a3      	ldr	r3, [r4, #8]
     f26:	6c22      	ldr	r2, [r4, #64]	; 0x40
     f28:	4694      	mov	ip, r2
     f2a:	4463      	add	r3, ip
     f2c:	60a3      	str	r3, [r4, #8]
	BaseType_t  xReturn = pdFALSE;
     f2e:	2000      	movs	r0, #0
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
     f30:	6862      	ldr	r2, [r4, #4]
     f32:	4293      	cmp	r3, r2
     f34:	d3ee      	bcc.n	f14 <prvCopyDataToQueue+0x20>
			pxQueue->pcWriteTo = pxQueue->pcHead;
     f36:	6823      	ldr	r3, [r4, #0]
     f38:	60a3      	str	r3, [r4, #8]
     f3a:	e7eb      	b.n	f14 <prvCopyDataToQueue+0x20>
		(void)memcpy((void *)pxQueue->u.pcReadFrom,
     f3c:	68c0      	ldr	r0, [r0, #12]
     f3e:	4b0b      	ldr	r3, [pc, #44]	; (f6c <prvCopyDataToQueue+0x78>)
     f40:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     f42:	6c23      	ldr	r3, [r4, #64]	; 0x40
     f44:	425b      	negs	r3, r3
     f46:	68e2      	ldr	r2, [r4, #12]
     f48:	18d2      	adds	r2, r2, r3
     f4a:	60e2      	str	r2, [r4, #12]
		if (pxQueue->u.pcReadFrom
     f4c:	6821      	ldr	r1, [r4, #0]
     f4e:	428a      	cmp	r2, r1
     f50:	d203      	bcs.n	f5a <prvCopyDataToQueue+0x66>
			pxQueue->u.pcReadFrom = (pxQueue->pcTail - pxQueue->uxItemSize);
     f52:	6862      	ldr	r2, [r4, #4]
     f54:	4694      	mov	ip, r2
     f56:	4463      	add	r3, ip
     f58:	60e3      	str	r3, [r4, #12]
	BaseType_t  xReturn = pdFALSE;
     f5a:	2000      	movs	r0, #0
		if (xPosition == queueOVERWRITE) {
     f5c:	2e02      	cmp	r6, #2
     f5e:	d1d9      	bne.n	f14 <prvCopyDataToQueue+0x20>
			if (uxMessagesWaiting > (UBaseType_t)0) {
     f60:	4285      	cmp	r5, r0
     f62:	d0d7      	beq.n	f14 <prvCopyDataToQueue+0x20>
				--uxMessagesWaiting;
     f64:	3d01      	subs	r5, #1
     f66:	e7d5      	b.n	f14 <prvCopyDataToQueue+0x20>
     f68:	00001f31 	.word	0x00001f31
     f6c:	00002415 	.word	0x00002415

00000f70 <prvNotifyQueueSetContainer>:
	/*-----------------------------------------------------------*/

#if (configUSE_QUEUE_SETS == 1)

static BaseType_t prvNotifyQueueSetContainer(const Queue_t *const pxQueue, const BaseType_t xCopyPosition)
{
     f70:	b570      	push	{r4, r5, r6, lr}
     f72:	b082      	sub	sp, #8
     f74:	9001      	str	r0, [sp, #4]
     f76:	000a      	movs	r2, r1
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
     f78:	6c84      	ldr	r4, [r0, #72]	; 0x48
	BaseType_t xReturn             = pdFALSE;

	/* This function must be called form a critical section. */

	configASSERT(pxQueueSetContainer);
     f7a:	2c00      	cmp	r4, #0
     f7c:	d005      	beq.n	f8a <prvNotifyQueueSetContainer+0x1a>
	configASSERT(pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength);
     f7e:	6ba1      	ldr	r1, [r4, #56]	; 0x38
     f80:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     f82:	4299      	cmp	r1, r3
     f84:	d303      	bcc.n	f8e <prvNotifyQueueSetContainer+0x1e>
     f86:	b672      	cpsid	i
     f88:	e7fe      	b.n	f88 <prvNotifyQueueSetContainer+0x18>
	configASSERT(pxQueueSetContainer);
     f8a:	b672      	cpsid	i
     f8c:	e7fe      	b.n	f8c <prvNotifyQueueSetContainer+0x1c>

	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
     f8e:	6ba1      	ldr	r1, [r4, #56]	; 0x38
	BaseType_t xReturn             = pdFALSE;
     f90:	2600      	movs	r6, #0
	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
     f92:	428b      	cmp	r3, r1
     f94:	d802      	bhi.n	f9c <prvNotifyQueueSetContainer+0x2c>
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
     f96:	0030      	movs	r0, r6
     f98:	b002      	add	sp, #8
     f9a:	bd70      	pop	{r4, r5, r6, pc}
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
     f9c:	2345      	movs	r3, #69	; 0x45
     f9e:	5ce5      	ldrb	r5, [r4, r3]
     fa0:	b26d      	sxtb	r5, r5
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
     fa2:	a901      	add	r1, sp, #4
     fa4:	0020      	movs	r0, r4
     fa6:	4b0a      	ldr	r3, [pc, #40]	; (fd0 <prvNotifyQueueSetContainer+0x60>)
     fa8:	4798      	blx	r3
     faa:	0006      	movs	r6, r0
		if (cTxLock == queueUNLOCKED) {
     fac:	1c6b      	adds	r3, r5, #1
     fae:	d10a      	bne.n	fc6 <prvNotifyQueueSetContainer+0x56>
			if (listLIST_IS_EMPTY(&(pxQueueSetContainer->xTasksWaitingToReceive)) == pdFALSE) {
     fb0:	6a63      	ldr	r3, [r4, #36]	; 0x24
     fb2:	2b00      	cmp	r3, #0
     fb4:	d0ef      	beq.n	f96 <prvNotifyQueueSetContainer+0x26>
				if (xTaskRemoveFromEventList(&(pxQueueSetContainer->xTasksWaitingToReceive)) != pdFALSE) {
     fb6:	0020      	movs	r0, r4
     fb8:	3024      	adds	r0, #36	; 0x24
     fba:	4b06      	ldr	r3, [pc, #24]	; (fd4 <prvNotifyQueueSetContainer+0x64>)
     fbc:	4798      	blx	r3
     fbe:	2800      	cmp	r0, #0
     fc0:	d0e9      	beq.n	f96 <prvNotifyQueueSetContainer+0x26>
					xReturn = pdTRUE;
     fc2:	2601      	movs	r6, #1
     fc4:	e7e7      	b.n	f96 <prvNotifyQueueSetContainer+0x26>
			pxQueueSetContainer->cTxLock = (int8_t)(cTxLock + 1);
     fc6:	3501      	adds	r5, #1
     fc8:	b26d      	sxtb	r5, r5
     fca:	2345      	movs	r3, #69	; 0x45
     fcc:	54e5      	strb	r5, [r4, r3]
     fce:	e7e2      	b.n	f96 <prvNotifyQueueSetContainer+0x26>
     fd0:	00000ef5 	.word	0x00000ef5
     fd4:	00001d79 	.word	0x00001d79

00000fd8 <prvCopyDataFromQueue>:
{
     fd8:	b510      	push	{r4, lr}
     fda:	000c      	movs	r4, r1
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
     fdc:	6c02      	ldr	r2, [r0, #64]	; 0x40
     fde:	2a00      	cmp	r2, #0
     fe0:	d00b      	beq.n	ffa <prvCopyDataFromQueue+0x22>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     fe2:	68c3      	ldr	r3, [r0, #12]
     fe4:	189b      	adds	r3, r3, r2
     fe6:	60c3      	str	r3, [r0, #12]
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
     fe8:	6841      	ldr	r1, [r0, #4]
     fea:	428b      	cmp	r3, r1
     fec:	d301      	bcc.n	ff2 <prvCopyDataFromQueue+0x1a>
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     fee:	6803      	ldr	r3, [r0, #0]
     ff0:	60c3      	str	r3, [r0, #12]
		(void)memcpy((void *)pvBuffer,
     ff2:	68c1      	ldr	r1, [r0, #12]
     ff4:	0020      	movs	r0, r4
     ff6:	4b01      	ldr	r3, [pc, #4]	; (ffc <prvCopyDataFromQueue+0x24>)
     ff8:	4798      	blx	r3
}
     ffa:	bd10      	pop	{r4, pc}
     ffc:	00002415 	.word	0x00002415

00001000 <prvUnlockQueue>:
{
    1000:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1002:	0007      	movs	r7, r0
	taskENTER_CRITICAL();
    1004:	4b25      	ldr	r3, [pc, #148]	; (109c <prvUnlockQueue+0x9c>)
    1006:	4798      	blx	r3
		int8_t cTxLock = pxQueue->cTxLock;
    1008:	2345      	movs	r3, #69	; 0x45
    100a:	5cfc      	ldrb	r4, [r7, r3]
    100c:	b264      	sxtb	r4, r4
		while (cTxLock > queueLOCKED_UNMODIFIED) {
    100e:	2c00      	cmp	r4, #0
    1010:	dd1c      	ble.n	104c <prvUnlockQueue+0x4c>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    1012:	4e23      	ldr	r6, [pc, #140]	; (10a0 <prvUnlockQueue+0xa0>)
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    1014:	4d23      	ldr	r5, [pc, #140]	; (10a4 <prvUnlockQueue+0xa4>)
    1016:	e00b      	b.n	1030 <prvUnlockQueue+0x30>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    1018:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    101a:	2b00      	cmp	r3, #0
    101c:	d016      	beq.n	104c <prvUnlockQueue+0x4c>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    101e:	0038      	movs	r0, r7
    1020:	3024      	adds	r0, #36	; 0x24
    1022:	47a8      	blx	r5
    1024:	2800      	cmp	r0, #0
    1026:	d10e      	bne.n	1046 <prvUnlockQueue+0x46>
    1028:	3c01      	subs	r4, #1
    102a:	b264      	sxtb	r4, r4
		while (cTxLock > queueLOCKED_UNMODIFIED) {
    102c:	2c00      	cmp	r4, #0
    102e:	d00d      	beq.n	104c <prvUnlockQueue+0x4c>
				if (pxQueue->pxQueueSetContainer != NULL) {
    1030:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    1032:	2b00      	cmp	r3, #0
    1034:	d0f0      	beq.n	1018 <prvUnlockQueue+0x18>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    1036:	2100      	movs	r1, #0
    1038:	0038      	movs	r0, r7
    103a:	47b0      	blx	r6
    103c:	2800      	cmp	r0, #0
    103e:	d0f3      	beq.n	1028 <prvUnlockQueue+0x28>
						vTaskMissedYield();
    1040:	4b19      	ldr	r3, [pc, #100]	; (10a8 <prvUnlockQueue+0xa8>)
    1042:	4798      	blx	r3
    1044:	e7f0      	b.n	1028 <prvUnlockQueue+0x28>
							vTaskMissedYield();
    1046:	4b18      	ldr	r3, [pc, #96]	; (10a8 <prvUnlockQueue+0xa8>)
    1048:	4798      	blx	r3
    104a:	e7ed      	b.n	1028 <prvUnlockQueue+0x28>
		pxQueue->cTxLock = queueUNLOCKED;
    104c:	22ff      	movs	r2, #255	; 0xff
    104e:	2345      	movs	r3, #69	; 0x45
    1050:	54fa      	strb	r2, [r7, r3]
	taskEXIT_CRITICAL();
    1052:	4b16      	ldr	r3, [pc, #88]	; (10ac <prvUnlockQueue+0xac>)
    1054:	4798      	blx	r3
	taskENTER_CRITICAL();
    1056:	4b11      	ldr	r3, [pc, #68]	; (109c <prvUnlockQueue+0x9c>)
    1058:	4798      	blx	r3
		int8_t cRxLock = pxQueue->cRxLock;
    105a:	2344      	movs	r3, #68	; 0x44
    105c:	5cfc      	ldrb	r4, [r7, r3]
    105e:	b264      	sxtb	r4, r4
		while (cRxLock > queueLOCKED_UNMODIFIED) {
    1060:	2c00      	cmp	r4, #0
    1062:	dd14      	ble.n	108e <prvUnlockQueue+0x8e>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    1064:	693b      	ldr	r3, [r7, #16]
    1066:	2b00      	cmp	r3, #0
    1068:	d011      	beq.n	108e <prvUnlockQueue+0x8e>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    106a:	003d      	movs	r5, r7
    106c:	3510      	adds	r5, #16
    106e:	4e0d      	ldr	r6, [pc, #52]	; (10a4 <prvUnlockQueue+0xa4>)
    1070:	e006      	b.n	1080 <prvUnlockQueue+0x80>
    1072:	3c01      	subs	r4, #1
    1074:	b264      	sxtb	r4, r4
		while (cRxLock > queueLOCKED_UNMODIFIED) {
    1076:	2c00      	cmp	r4, #0
    1078:	d009      	beq.n	108e <prvUnlockQueue+0x8e>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    107a:	693b      	ldr	r3, [r7, #16]
    107c:	2b00      	cmp	r3, #0
    107e:	d006      	beq.n	108e <prvUnlockQueue+0x8e>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    1080:	0028      	movs	r0, r5
    1082:	47b0      	blx	r6
    1084:	2800      	cmp	r0, #0
    1086:	d0f4      	beq.n	1072 <prvUnlockQueue+0x72>
					vTaskMissedYield();
    1088:	4b07      	ldr	r3, [pc, #28]	; (10a8 <prvUnlockQueue+0xa8>)
    108a:	4798      	blx	r3
    108c:	e7f1      	b.n	1072 <prvUnlockQueue+0x72>
		pxQueue->cRxLock = queueUNLOCKED;
    108e:	22ff      	movs	r2, #255	; 0xff
    1090:	2344      	movs	r3, #68	; 0x44
    1092:	54fa      	strb	r2, [r7, r3]
	taskEXIT_CRITICAL();
    1094:	4b05      	ldr	r3, [pc, #20]	; (10ac <prvUnlockQueue+0xac>)
    1096:	4798      	blx	r3
}
    1098:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    109a:	46c0      	nop			; (mov r8, r8)
    109c:	00000da5 	.word	0x00000da5
    10a0:	00000f71 	.word	0x00000f71
    10a4:	00001d79 	.word	0x00001d79
    10a8:	00001e71 	.word	0x00001e71
    10ac:	00000dbd 	.word	0x00000dbd

000010b0 <xQueueGenericReset>:
{
    10b0:	b570      	push	{r4, r5, r6, lr}
    10b2:	0004      	movs	r4, r0
    10b4:	000d      	movs	r5, r1
	configASSERT(pxQueue);
    10b6:	2800      	cmp	r0, #0
    10b8:	d021      	beq.n	10fe <xQueueGenericReset+0x4e>
	taskENTER_CRITICAL();
    10ba:	4b17      	ldr	r3, [pc, #92]	; (1118 <xQueueGenericReset+0x68>)
    10bc:	4798      	blx	r3
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    10be:	6822      	ldr	r2, [r4, #0]
    10c0:	6c21      	ldr	r1, [r4, #64]	; 0x40
    10c2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    10c4:	434b      	muls	r3, r1
    10c6:	18d0      	adds	r0, r2, r3
    10c8:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
    10ca:	2000      	movs	r0, #0
    10cc:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo         = pxQueue->pcHead;
    10ce:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
    10d0:	1a5b      	subs	r3, r3, r1
    10d2:	18d3      	adds	r3, r2, r3
    10d4:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock           = queueUNLOCKED;
    10d6:	23ff      	movs	r3, #255	; 0xff
    10d8:	2244      	movs	r2, #68	; 0x44
    10da:	54a3      	strb	r3, [r4, r2]
		pxQueue->cTxLock           = queueUNLOCKED;
    10dc:	3201      	adds	r2, #1
    10de:	54a3      	strb	r3, [r4, r2]
		if (xNewQueue == pdFALSE) {
    10e0:	2d00      	cmp	r5, #0
    10e2:	d111      	bne.n	1108 <xQueueGenericReset+0x58>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    10e4:	6923      	ldr	r3, [r4, #16]
    10e6:	2b00      	cmp	r3, #0
    10e8:	d005      	beq.n	10f6 <xQueueGenericReset+0x46>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    10ea:	0020      	movs	r0, r4
    10ec:	3010      	adds	r0, #16
    10ee:	4b0b      	ldr	r3, [pc, #44]	; (111c <xQueueGenericReset+0x6c>)
    10f0:	4798      	blx	r3
    10f2:	2800      	cmp	r0, #0
    10f4:	d105      	bne.n	1102 <xQueueGenericReset+0x52>
	taskEXIT_CRITICAL();
    10f6:	4b0a      	ldr	r3, [pc, #40]	; (1120 <xQueueGenericReset+0x70>)
    10f8:	4798      	blx	r3
}
    10fa:	2001      	movs	r0, #1
    10fc:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT(pxQueue);
    10fe:	b672      	cpsid	i
    1100:	e7fe      	b.n	1100 <xQueueGenericReset+0x50>
					queueYIELD_IF_USING_PREEMPTION();
    1102:	4b08      	ldr	r3, [pc, #32]	; (1124 <xQueueGenericReset+0x74>)
    1104:	4798      	blx	r3
    1106:	e7f6      	b.n	10f6 <xQueueGenericReset+0x46>
			vListInitialise(&(pxQueue->xTasksWaitingToSend));
    1108:	0020      	movs	r0, r4
    110a:	3010      	adds	r0, #16
    110c:	4d06      	ldr	r5, [pc, #24]	; (1128 <xQueueGenericReset+0x78>)
    110e:	47a8      	blx	r5
			vListInitialise(&(pxQueue->xTasksWaitingToReceive));
    1110:	0020      	movs	r0, r4
    1112:	3024      	adds	r0, #36	; 0x24
    1114:	47a8      	blx	r5
    1116:	e7ee      	b.n	10f6 <xQueueGenericReset+0x46>
    1118:	00000da5 	.word	0x00000da5
    111c:	00001d79 	.word	0x00001d79
    1120:	00000dbd 	.word	0x00000dbd
    1124:	00000d8d 	.word	0x00000d8d
    1128:	00000c1d 	.word	0x00000c1d

0000112c <xQueueGenericCreate>:
{
    112c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    112e:	0006      	movs	r6, r0
    1130:	000d      	movs	r5, r1
    1132:	0017      	movs	r7, r2
	configASSERT(uxQueueLength > (UBaseType_t)0);
    1134:	2800      	cmp	r0, #0
    1136:	d101      	bne.n	113c <xQueueGenericCreate+0x10>
    1138:	b672      	cpsid	i
    113a:	e7fe      	b.n	113a <xQueueGenericCreate+0xe>
		xQueueSizeInBytes = (size_t)(
    113c:	0008      	movs	r0, r1
    113e:	4370      	muls	r0, r6
	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t) + xQueueSizeInBytes);
    1140:	3054      	adds	r0, #84	; 0x54
    1142:	4b0b      	ldr	r3, [pc, #44]	; (1170 <xQueueGenericCreate+0x44>)
    1144:	4798      	blx	r3
    1146:	1e04      	subs	r4, r0, #0
	if (pxNewQueue != NULL) {
    1148:	d010      	beq.n	116c <xQueueGenericCreate+0x40>
	if (uxItemSize == (UBaseType_t)0) {
    114a:	2d00      	cmp	r5, #0
    114c:	d003      	beq.n	1156 <xQueueGenericCreate+0x2a>
		pucQueueStorage = ((uint8_t *)pxNewQueue) + sizeof(Queue_t);
    114e:	0003      	movs	r3, r0
    1150:	3354      	adds	r3, #84	; 0x54
		pxNewQueue->pcHead = (int8_t *)pucQueueStorage;
    1152:	6003      	str	r3, [r0, #0]
    1154:	e000      	b.n	1158 <xQueueGenericCreate+0x2c>
		pxNewQueue->pcHead = (int8_t *)pxNewQueue;
    1156:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength   = uxQueueLength;
    1158:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
    115a:	6425      	str	r5, [r4, #64]	; 0x40
	(void)xQueueGenericReset(pxNewQueue, pdTRUE);
    115c:	2101      	movs	r1, #1
    115e:	0020      	movs	r0, r4
    1160:	4b04      	ldr	r3, [pc, #16]	; (1174 <xQueueGenericCreate+0x48>)
    1162:	4798      	blx	r3
		pxNewQueue->ucQueueType = ucQueueType;
    1164:	2350      	movs	r3, #80	; 0x50
    1166:	54e7      	strb	r7, [r4, r3]
		pxNewQueue->pxQueueSetContainer = NULL;
    1168:	2300      	movs	r3, #0
    116a:	64a3      	str	r3, [r4, #72]	; 0x48
}
    116c:	0020      	movs	r0, r4
    116e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1170:	00000e65 	.word	0x00000e65
    1174:	000010b1 	.word	0x000010b1

00001178 <xQueueGenericSend>:
{
    1178:	b5f0      	push	{r4, r5, r6, r7, lr}
    117a:	46ce      	mov	lr, r9
    117c:	4647      	mov	r7, r8
    117e:	b580      	push	{r7, lr}
    1180:	b085      	sub	sp, #20
    1182:	0004      	movs	r4, r0
    1184:	000f      	movs	r7, r1
    1186:	9201      	str	r2, [sp, #4]
    1188:	001d      	movs	r5, r3
	configASSERT(pxQueue);
    118a:	2800      	cmp	r0, #0
    118c:	d00c      	beq.n	11a8 <xQueueGenericSend+0x30>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    118e:	2900      	cmp	r1, #0
    1190:	d00c      	beq.n	11ac <xQueueGenericSend+0x34>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    1192:	2d02      	cmp	r5, #2
    1194:	d00f      	beq.n	11b6 <xQueueGenericSend+0x3e>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    1196:	4b4e      	ldr	r3, [pc, #312]	; (12d0 <xQueueGenericSend+0x158>)
    1198:	4798      	blx	r3
    119a:	2800      	cmp	r0, #0
    119c:	d110      	bne.n	11c0 <xQueueGenericSend+0x48>
    119e:	9b01      	ldr	r3, [sp, #4]
    11a0:	2b00      	cmp	r3, #0
    11a2:	d011      	beq.n	11c8 <xQueueGenericSend+0x50>
    11a4:	b672      	cpsid	i
    11a6:	e7fe      	b.n	11a6 <xQueueGenericSend+0x2e>
	configASSERT(pxQueue);
    11a8:	b672      	cpsid	i
    11aa:	e7fe      	b.n	11aa <xQueueGenericSend+0x32>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    11ac:	6c03      	ldr	r3, [r0, #64]	; 0x40
    11ae:	2b00      	cmp	r3, #0
    11b0:	d0ef      	beq.n	1192 <xQueueGenericSend+0x1a>
    11b2:	b672      	cpsid	i
    11b4:	e7fe      	b.n	11b4 <xQueueGenericSend+0x3c>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    11b6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    11b8:	2b01      	cmp	r3, #1
    11ba:	d0ec      	beq.n	1196 <xQueueGenericSend+0x1e>
    11bc:	b672      	cpsid	i
    11be:	e7fe      	b.n	11be <xQueueGenericSend+0x46>
    11c0:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
    11c2:	4b44      	ldr	r3, [pc, #272]	; (12d4 <xQueueGenericSend+0x15c>)
    11c4:	4698      	mov	r8, r3
    11c6:	e04c      	b.n	1262 <xQueueGenericSend+0xea>
    11c8:	2600      	movs	r6, #0
    11ca:	e7fa      	b.n	11c2 <xQueueGenericSend+0x4a>
				xYieldRequired = prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    11cc:	002a      	movs	r2, r5
    11ce:	0039      	movs	r1, r7
    11d0:	0020      	movs	r0, r4
    11d2:	4b41      	ldr	r3, [pc, #260]	; (12d8 <xQueueGenericSend+0x160>)
    11d4:	4798      	blx	r3
					if (pxQueue->pxQueueSetContainer != NULL) {
    11d6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    11d8:	2b00      	cmp	r3, #0
    11da:	d00f      	beq.n	11fc <xQueueGenericSend+0x84>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    11dc:	0029      	movs	r1, r5
    11de:	0020      	movs	r0, r4
    11e0:	4b3e      	ldr	r3, [pc, #248]	; (12dc <xQueueGenericSend+0x164>)
    11e2:	4798      	blx	r3
    11e4:	2800      	cmp	r0, #0
    11e6:	d001      	beq.n	11ec <xQueueGenericSend+0x74>
							queueYIELD_IF_USING_PREEMPTION();
    11e8:	4b3d      	ldr	r3, [pc, #244]	; (12e0 <xQueueGenericSend+0x168>)
    11ea:	4798      	blx	r3
				taskEXIT_CRITICAL();
    11ec:	4b3d      	ldr	r3, [pc, #244]	; (12e4 <xQueueGenericSend+0x16c>)
    11ee:	4798      	blx	r3
				return pdPASS;
    11f0:	2001      	movs	r0, #1
}
    11f2:	b005      	add	sp, #20
    11f4:	bc0c      	pop	{r2, r3}
    11f6:	4690      	mov	r8, r2
    11f8:	4699      	mov	r9, r3
    11fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    11fc:	6a63      	ldr	r3, [r4, #36]	; 0x24
    11fe:	2b00      	cmp	r3, #0
    1200:	d008      	beq.n	1214 <xQueueGenericSend+0x9c>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    1202:	0020      	movs	r0, r4
    1204:	3024      	adds	r0, #36	; 0x24
    1206:	4b38      	ldr	r3, [pc, #224]	; (12e8 <xQueueGenericSend+0x170>)
    1208:	4798      	blx	r3
    120a:	2800      	cmp	r0, #0
    120c:	d0ee      	beq.n	11ec <xQueueGenericSend+0x74>
								queueYIELD_IF_USING_PREEMPTION();
    120e:	4b34      	ldr	r3, [pc, #208]	; (12e0 <xQueueGenericSend+0x168>)
    1210:	4798      	blx	r3
    1212:	e7eb      	b.n	11ec <xQueueGenericSend+0x74>
						} else if (xYieldRequired != pdFALSE) {
    1214:	2800      	cmp	r0, #0
    1216:	d0e9      	beq.n	11ec <xQueueGenericSend+0x74>
							queueYIELD_IF_USING_PREEMPTION();
    1218:	4b31      	ldr	r3, [pc, #196]	; (12e0 <xQueueGenericSend+0x168>)
    121a:	4798      	blx	r3
    121c:	e7e6      	b.n	11ec <xQueueGenericSend+0x74>
					taskEXIT_CRITICAL();
    121e:	4b31      	ldr	r3, [pc, #196]	; (12e4 <xQueueGenericSend+0x16c>)
    1220:	4798      	blx	r3
					return errQUEUE_FULL;
    1222:	2000      	movs	r0, #0
    1224:	e7e5      	b.n	11f2 <xQueueGenericSend+0x7a>
		prvLockQueue(pxQueue);
    1226:	4b2f      	ldr	r3, [pc, #188]	; (12e4 <xQueueGenericSend+0x16c>)
    1228:	4798      	blx	r3
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    122a:	a901      	add	r1, sp, #4
    122c:	a802      	add	r0, sp, #8
    122e:	4b2f      	ldr	r3, [pc, #188]	; (12ec <xQueueGenericSend+0x174>)
    1230:	4798      	blx	r3
    1232:	2800      	cmp	r0, #0
    1234:	d144      	bne.n	12c0 <xQueueGenericSend+0x148>
	taskENTER_CRITICAL();
    1236:	4b27      	ldr	r3, [pc, #156]	; (12d4 <xQueueGenericSend+0x15c>)
    1238:	4798      	blx	r3
		if (pxQueue->uxMessagesWaiting == pxQueue->uxLength) {
    123a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    123c:	4699      	mov	r9, r3
    123e:	6be6      	ldr	r6, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
    1240:	4b28      	ldr	r3, [pc, #160]	; (12e4 <xQueueGenericSend+0x16c>)
    1242:	4798      	blx	r3
			if (prvIsQueueFull(pxQueue) != pdFALSE) {
    1244:	45b1      	cmp	r9, r6
    1246:	d135      	bne.n	12b4 <xQueueGenericSend+0x13c>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToSend), xTicksToWait);
    1248:	0020      	movs	r0, r4
    124a:	3010      	adds	r0, #16
    124c:	9901      	ldr	r1, [sp, #4]
    124e:	4b28      	ldr	r3, [pc, #160]	; (12f0 <xQueueGenericSend+0x178>)
    1250:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    1252:	0020      	movs	r0, r4
    1254:	4b27      	ldr	r3, [pc, #156]	; (12f4 <xQueueGenericSend+0x17c>)
    1256:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    1258:	4b27      	ldr	r3, [pc, #156]	; (12f8 <xQueueGenericSend+0x180>)
    125a:	4798      	blx	r3
    125c:	2800      	cmp	r0, #0
    125e:	d026      	beq.n	12ae <xQueueGenericSend+0x136>
    1260:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    1262:	47c0      	blx	r8
			if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    1264:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    1266:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    1268:	4293      	cmp	r3, r2
    126a:	d3af      	bcc.n	11cc <xQueueGenericSend+0x54>
    126c:	2d02      	cmp	r5, #2
    126e:	d0ad      	beq.n	11cc <xQueueGenericSend+0x54>
				if (xTicksToWait == (TickType_t)0) {
    1270:	9b01      	ldr	r3, [sp, #4]
    1272:	2b00      	cmp	r3, #0
    1274:	d0d3      	beq.n	121e <xQueueGenericSend+0xa6>
				} else if (xEntryTimeSet == pdFALSE) {
    1276:	2e00      	cmp	r6, #0
    1278:	d102      	bne.n	1280 <xQueueGenericSend+0x108>
					vTaskInternalSetTimeOutState(&xTimeOut);
    127a:	a802      	add	r0, sp, #8
    127c:	4b1f      	ldr	r3, [pc, #124]	; (12fc <xQueueGenericSend+0x184>)
    127e:	4798      	blx	r3
		taskEXIT_CRITICAL();
    1280:	4b18      	ldr	r3, [pc, #96]	; (12e4 <xQueueGenericSend+0x16c>)
    1282:	4798      	blx	r3
		vTaskSuspendAll();
    1284:	4b1e      	ldr	r3, [pc, #120]	; (1300 <xQueueGenericSend+0x188>)
    1286:	4798      	blx	r3
		prvLockQueue(pxQueue);
    1288:	4b12      	ldr	r3, [pc, #72]	; (12d4 <xQueueGenericSend+0x15c>)
    128a:	4798      	blx	r3
    128c:	2344      	movs	r3, #68	; 0x44
    128e:	5ce3      	ldrb	r3, [r4, r3]
    1290:	b25b      	sxtb	r3, r3
    1292:	3301      	adds	r3, #1
    1294:	d102      	bne.n	129c <xQueueGenericSend+0x124>
    1296:	2200      	movs	r2, #0
    1298:	2344      	movs	r3, #68	; 0x44
    129a:	54e2      	strb	r2, [r4, r3]
    129c:	2345      	movs	r3, #69	; 0x45
    129e:	5ce3      	ldrb	r3, [r4, r3]
    12a0:	b25b      	sxtb	r3, r3
    12a2:	3301      	adds	r3, #1
    12a4:	d1bf      	bne.n	1226 <xQueueGenericSend+0xae>
    12a6:	2200      	movs	r2, #0
    12a8:	2345      	movs	r3, #69	; 0x45
    12aa:	54e2      	strb	r2, [r4, r3]
    12ac:	e7bb      	b.n	1226 <xQueueGenericSend+0xae>
					portYIELD_WITHIN_API();
    12ae:	4b0c      	ldr	r3, [pc, #48]	; (12e0 <xQueueGenericSend+0x168>)
    12b0:	4798      	blx	r3
    12b2:	e7d5      	b.n	1260 <xQueueGenericSend+0xe8>
				prvUnlockQueue(pxQueue);
    12b4:	0020      	movs	r0, r4
    12b6:	4b0f      	ldr	r3, [pc, #60]	; (12f4 <xQueueGenericSend+0x17c>)
    12b8:	4798      	blx	r3
				(void)xTaskResumeAll();
    12ba:	4b0f      	ldr	r3, [pc, #60]	; (12f8 <xQueueGenericSend+0x180>)
    12bc:	4798      	blx	r3
    12be:	e7cf      	b.n	1260 <xQueueGenericSend+0xe8>
			prvUnlockQueue(pxQueue);
    12c0:	0020      	movs	r0, r4
    12c2:	4b0c      	ldr	r3, [pc, #48]	; (12f4 <xQueueGenericSend+0x17c>)
    12c4:	4798      	blx	r3
			(void)xTaskResumeAll();
    12c6:	4b0c      	ldr	r3, [pc, #48]	; (12f8 <xQueueGenericSend+0x180>)
    12c8:	4798      	blx	r3
			return errQUEUE_FULL;
    12ca:	2000      	movs	r0, #0
    12cc:	e791      	b.n	11f2 <xQueueGenericSend+0x7a>
    12ce:	46c0      	nop			; (mov r8, r8)
    12d0:	00001e7d 	.word	0x00001e7d
    12d4:	00000da5 	.word	0x00000da5
    12d8:	00000ef5 	.word	0x00000ef5
    12dc:	00000f71 	.word	0x00000f71
    12e0:	00000d8d 	.word	0x00000d8d
    12e4:	00000dbd 	.word	0x00000dbd
    12e8:	00001d79 	.word	0x00001d79
    12ec:	00001e05 	.word	0x00001e05
    12f0:	00001d15 	.word	0x00001d15
    12f4:	00001001 	.word	0x00001001
    12f8:	00001b59 	.word	0x00001b59
    12fc:	00001df5 	.word	0x00001df5
    1300:	00001a31 	.word	0x00001a31

00001304 <xQueueCreateMutex>:
{
    1304:	b570      	push	{r4, r5, r6, lr}
    1306:	0002      	movs	r2, r0
	pxNewQueue = (Queue_t *)xQueueGenericCreate(uxMutexLength, uxMutexSize, ucQueueType);
    1308:	2100      	movs	r1, #0
    130a:	2001      	movs	r0, #1
    130c:	4b06      	ldr	r3, [pc, #24]	; (1328 <xQueueCreateMutex+0x24>)
    130e:	4798      	blx	r3
    1310:	1e04      	subs	r4, r0, #0
	if (pxNewQueue != NULL) {
    1312:	d007      	beq.n	1324 <xQueueCreateMutex+0x20>
		pxNewQueue->pxMutexHolder = NULL;
    1314:	2300      	movs	r3, #0
    1316:	6043      	str	r3, [r0, #4]
		pxNewQueue->uxQueueType   = queueQUEUE_IS_MUTEX;
    1318:	6003      	str	r3, [r0, #0]
		pxNewQueue->u.uxRecursiveCallCount = 0;
    131a:	60c3      	str	r3, [r0, #12]
		(void)xQueueGenericSend(pxNewQueue, NULL, (TickType_t)0U, queueSEND_TO_BACK);
    131c:	2200      	movs	r2, #0
    131e:	2100      	movs	r1, #0
    1320:	4d02      	ldr	r5, [pc, #8]	; (132c <xQueueCreateMutex+0x28>)
    1322:	47a8      	blx	r5
}
    1324:	0020      	movs	r0, r4
    1326:	bd70      	pop	{r4, r5, r6, pc}
    1328:	0000112d 	.word	0x0000112d
    132c:	00001179 	.word	0x00001179

00001330 <xQueueGenericSendFromISR>:
{
    1330:	b5f0      	push	{r4, r5, r6, r7, lr}
    1332:	b083      	sub	sp, #12
    1334:	0004      	movs	r4, r0
    1336:	9101      	str	r1, [sp, #4]
    1338:	0016      	movs	r6, r2
    133a:	001d      	movs	r5, r3
	configASSERT(pxQueue);
    133c:	2800      	cmp	r0, #0
    133e:	d012      	beq.n	1366 <xQueueGenericSendFromISR+0x36>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    1340:	9b01      	ldr	r3, [sp, #4]
    1342:	2b00      	cmp	r3, #0
    1344:	d011      	beq.n	136a <xQueueGenericSendFromISR+0x3a>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    1346:	2d02      	cmp	r5, #2
    1348:	d014      	beq.n	1374 <xQueueGenericSendFromISR+0x44>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    134a:	4b28      	ldr	r3, [pc, #160]	; (13ec <xQueueGenericSendFromISR+0xbc>)
    134c:	4798      	blx	r3
    134e:	9000      	str	r0, [sp, #0]
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    1350:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    1352:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    1354:	429a      	cmp	r2, r3
    1356:	d82f      	bhi.n	13b8 <xQueueGenericSendFromISR+0x88>
			xReturn = errQUEUE_FULL;
    1358:	2500      	movs	r5, #0
	portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);
    135a:	9800      	ldr	r0, [sp, #0]
    135c:	4b24      	ldr	r3, [pc, #144]	; (13f0 <xQueueGenericSendFromISR+0xc0>)
    135e:	4798      	blx	r3
}
    1360:	0028      	movs	r0, r5
    1362:	b003      	add	sp, #12
    1364:	bdf0      	pop	{r4, r5, r6, r7, pc}
	configASSERT(pxQueue);
    1366:	b672      	cpsid	i
    1368:	e7fe      	b.n	1368 <xQueueGenericSendFromISR+0x38>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    136a:	6c03      	ldr	r3, [r0, #64]	; 0x40
    136c:	2b00      	cmp	r3, #0
    136e:	d0ea      	beq.n	1346 <xQueueGenericSendFromISR+0x16>
    1370:	b672      	cpsid	i
    1372:	e7fe      	b.n	1372 <xQueueGenericSendFromISR+0x42>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    1374:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    1376:	2b01      	cmp	r3, #1
    1378:	d01a      	beq.n	13b0 <xQueueGenericSendFromISR+0x80>
    137a:	b672      	cpsid	i
    137c:	e7fe      	b.n	137c <xQueueGenericSendFromISR+0x4c>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    137e:	6a63      	ldr	r3, [r4, #36]	; 0x24
			xReturn = pdPASS;
    1380:	2501      	movs	r5, #1
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    1382:	2b00      	cmp	r3, #0
    1384:	d0e9      	beq.n	135a <xQueueGenericSendFromISR+0x2a>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    1386:	0020      	movs	r0, r4
    1388:	3024      	adds	r0, #36	; 0x24
    138a:	4b1a      	ldr	r3, [pc, #104]	; (13f4 <xQueueGenericSendFromISR+0xc4>)
    138c:	4798      	blx	r3
    138e:	2800      	cmp	r0, #0
    1390:	d0e3      	beq.n	135a <xQueueGenericSendFromISR+0x2a>
								if (pxHigherPriorityTaskWoken != NULL) {
    1392:	2e00      	cmp	r6, #0
    1394:	d00a      	beq.n	13ac <xQueueGenericSendFromISR+0x7c>
									*pxHigherPriorityTaskWoken = pdTRUE;
    1396:	2301      	movs	r3, #1
    1398:	6033      	str	r3, [r6, #0]
    139a:	e7de      	b.n	135a <xQueueGenericSendFromISR+0x2a>
				pxQueue->cTxLock = (int8_t)(cTxLock + 1);
    139c:	1c7b      	adds	r3, r7, #1
    139e:	b25b      	sxtb	r3, r3
    13a0:	2245      	movs	r2, #69	; 0x45
    13a2:	54a3      	strb	r3, [r4, r2]
			xReturn = pdPASS;
    13a4:	2501      	movs	r5, #1
    13a6:	e7d8      	b.n	135a <xQueueGenericSendFromISR+0x2a>
    13a8:	2501      	movs	r5, #1
    13aa:	e7d6      	b.n	135a <xQueueGenericSendFromISR+0x2a>
    13ac:	2501      	movs	r5, #1
    13ae:	e7d4      	b.n	135a <xQueueGenericSendFromISR+0x2a>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    13b0:	4b0e      	ldr	r3, [pc, #56]	; (13ec <xQueueGenericSendFromISR+0xbc>)
    13b2:	4798      	blx	r3
    13b4:	9000      	str	r0, [sp, #0]
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    13b6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			const int8_t cTxLock = pxQueue->cTxLock;
    13b8:	2345      	movs	r3, #69	; 0x45
    13ba:	5ce7      	ldrb	r7, [r4, r3]
    13bc:	b27f      	sxtb	r7, r7
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    13be:	002a      	movs	r2, r5
    13c0:	9901      	ldr	r1, [sp, #4]
    13c2:	0020      	movs	r0, r4
    13c4:	4b0c      	ldr	r3, [pc, #48]	; (13f8 <xQueueGenericSendFromISR+0xc8>)
    13c6:	4798      	blx	r3
			if (cTxLock == queueUNLOCKED) {
    13c8:	1c7b      	adds	r3, r7, #1
    13ca:	d1e7      	bne.n	139c <xQueueGenericSendFromISR+0x6c>
					if (pxQueue->pxQueueSetContainer != NULL) {
    13cc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    13ce:	2b00      	cmp	r3, #0
    13d0:	d0d5      	beq.n	137e <xQueueGenericSendFromISR+0x4e>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    13d2:	0029      	movs	r1, r5
    13d4:	0020      	movs	r0, r4
    13d6:	4b09      	ldr	r3, [pc, #36]	; (13fc <xQueueGenericSendFromISR+0xcc>)
    13d8:	4798      	blx	r3
			xReturn = pdPASS;
    13da:	2501      	movs	r5, #1
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    13dc:	2800      	cmp	r0, #0
    13de:	d0bc      	beq.n	135a <xQueueGenericSendFromISR+0x2a>
							if (pxHigherPriorityTaskWoken != NULL) {
    13e0:	2e00      	cmp	r6, #0
    13e2:	d0e1      	beq.n	13a8 <xQueueGenericSendFromISR+0x78>
								*pxHigherPriorityTaskWoken = pdTRUE;
    13e4:	2301      	movs	r3, #1
    13e6:	6033      	str	r3, [r6, #0]
    13e8:	e7b7      	b.n	135a <xQueueGenericSendFromISR+0x2a>
    13ea:	46c0      	nop			; (mov r8, r8)
    13ec:	00000ddd 	.word	0x00000ddd
    13f0:	00000de5 	.word	0x00000de5
    13f4:	00001d79 	.word	0x00001d79
    13f8:	00000ef5 	.word	0x00000ef5
    13fc:	00000f71 	.word	0x00000f71

00001400 <xQueueReceive>:
{
    1400:	b5f0      	push	{r4, r5, r6, r7, lr}
    1402:	46c6      	mov	lr, r8
    1404:	b500      	push	{lr}
    1406:	b084      	sub	sp, #16
    1408:	0004      	movs	r4, r0
    140a:	000f      	movs	r7, r1
    140c:	9201      	str	r2, [sp, #4]
	configASSERT((pxQueue));
    140e:	2800      	cmp	r0, #0
    1410:	d00a      	beq.n	1428 <xQueueReceive+0x28>
	configASSERT(!(((pvBuffer) == NULL) && ((pxQueue)->uxItemSize != (UBaseType_t)0U)));
    1412:	2900      	cmp	r1, #0
    1414:	d00a      	beq.n	142c <xQueueReceive+0x2c>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    1416:	4b42      	ldr	r3, [pc, #264]	; (1520 <xQueueReceive+0x120>)
    1418:	4798      	blx	r3
    141a:	2800      	cmp	r0, #0
    141c:	d10b      	bne.n	1436 <xQueueReceive+0x36>
    141e:	9b01      	ldr	r3, [sp, #4]
    1420:	2b00      	cmp	r3, #0
    1422:	d00c      	beq.n	143e <xQueueReceive+0x3e>
    1424:	b672      	cpsid	i
    1426:	e7fe      	b.n	1426 <xQueueReceive+0x26>
	configASSERT((pxQueue));
    1428:	b672      	cpsid	i
    142a:	e7fe      	b.n	142a <xQueueReceive+0x2a>
	configASSERT(!(((pvBuffer) == NULL) && ((pxQueue)->uxItemSize != (UBaseType_t)0U)));
    142c:	6c03      	ldr	r3, [r0, #64]	; 0x40
    142e:	2b00      	cmp	r3, #0
    1430:	d0f1      	beq.n	1416 <xQueueReceive+0x16>
    1432:	b672      	cpsid	i
    1434:	e7fe      	b.n	1434 <xQueueReceive+0x34>
    1436:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
    1438:	4b3a      	ldr	r3, [pc, #232]	; (1524 <xQueueReceive+0x124>)
    143a:	4698      	mov	r8, r3
    143c:	e02f      	b.n	149e <xQueueReceive+0x9e>
    143e:	2600      	movs	r6, #0
    1440:	e7fa      	b.n	1438 <xQueueReceive+0x38>
				prvCopyDataFromQueue(pxQueue, pvBuffer);
    1442:	0039      	movs	r1, r7
    1444:	0020      	movs	r0, r4
    1446:	4b38      	ldr	r3, [pc, #224]	; (1528 <xQueueReceive+0x128>)
    1448:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - (UBaseType_t)1;
    144a:	3d01      	subs	r5, #1
    144c:	63a5      	str	r5, [r4, #56]	; 0x38
				if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    144e:	6923      	ldr	r3, [r4, #16]
    1450:	2b00      	cmp	r3, #0
    1452:	d007      	beq.n	1464 <xQueueReceive+0x64>
					if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    1454:	0020      	movs	r0, r4
    1456:	3010      	adds	r0, #16
    1458:	4b34      	ldr	r3, [pc, #208]	; (152c <xQueueReceive+0x12c>)
    145a:	4798      	blx	r3
    145c:	2800      	cmp	r0, #0
    145e:	d001      	beq.n	1464 <xQueueReceive+0x64>
						queueYIELD_IF_USING_PREEMPTION();
    1460:	4b33      	ldr	r3, [pc, #204]	; (1530 <xQueueReceive+0x130>)
    1462:	4798      	blx	r3
				taskEXIT_CRITICAL();
    1464:	4b33      	ldr	r3, [pc, #204]	; (1534 <xQueueReceive+0x134>)
    1466:	4798      	blx	r3
				return pdPASS;
    1468:	2001      	movs	r0, #1
}
    146a:	b004      	add	sp, #16
    146c:	bc04      	pop	{r2}
    146e:	4690      	mov	r8, r2
    1470:	bdf0      	pop	{r4, r5, r6, r7, pc}
					taskEXIT_CRITICAL();
    1472:	4b30      	ldr	r3, [pc, #192]	; (1534 <xQueueReceive+0x134>)
    1474:	4798      	blx	r3
					return errQUEUE_EMPTY;
    1476:	2000      	movs	r0, #0
    1478:	e7f7      	b.n	146a <xQueueReceive+0x6a>
					vTaskInternalSetTimeOutState(&xTimeOut);
    147a:	a802      	add	r0, sp, #8
    147c:	4b2e      	ldr	r3, [pc, #184]	; (1538 <xQueueReceive+0x138>)
    147e:	4798      	blx	r3
    1480:	e016      	b.n	14b0 <xQueueReceive+0xb0>
		prvLockQueue(pxQueue);
    1482:	2200      	movs	r2, #0
    1484:	2344      	movs	r3, #68	; 0x44
    1486:	54e2      	strb	r2, [r4, r3]
    1488:	e01d      	b.n	14c6 <xQueueReceive+0xc6>
    148a:	2200      	movs	r2, #0
    148c:	2345      	movs	r3, #69	; 0x45
    148e:	54e2      	strb	r2, [r4, r3]
    1490:	e01e      	b.n	14d0 <xQueueReceive+0xd0>
				prvUnlockQueue(pxQueue);
    1492:	0020      	movs	r0, r4
    1494:	4b29      	ldr	r3, [pc, #164]	; (153c <xQueueReceive+0x13c>)
    1496:	4798      	blx	r3
				(void)xTaskResumeAll();
    1498:	4b29      	ldr	r3, [pc, #164]	; (1540 <xQueueReceive+0x140>)
    149a:	4798      	blx	r3
    149c:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    149e:	47c0      	blx	r8
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    14a0:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if (uxMessagesWaiting > (UBaseType_t)0) {
    14a2:	2d00      	cmp	r5, #0
    14a4:	d1cd      	bne.n	1442 <xQueueReceive+0x42>
				if (xTicksToWait == (TickType_t)0) {
    14a6:	9b01      	ldr	r3, [sp, #4]
    14a8:	2b00      	cmp	r3, #0
    14aa:	d0e2      	beq.n	1472 <xQueueReceive+0x72>
				} else if (xEntryTimeSet == pdFALSE) {
    14ac:	2e00      	cmp	r6, #0
    14ae:	d0e4      	beq.n	147a <xQueueReceive+0x7a>
		taskEXIT_CRITICAL();
    14b0:	4b20      	ldr	r3, [pc, #128]	; (1534 <xQueueReceive+0x134>)
    14b2:	4798      	blx	r3
		vTaskSuspendAll();
    14b4:	4b23      	ldr	r3, [pc, #140]	; (1544 <xQueueReceive+0x144>)
    14b6:	4798      	blx	r3
		prvLockQueue(pxQueue);
    14b8:	4b1a      	ldr	r3, [pc, #104]	; (1524 <xQueueReceive+0x124>)
    14ba:	4798      	blx	r3
    14bc:	2344      	movs	r3, #68	; 0x44
    14be:	5ce3      	ldrb	r3, [r4, r3]
    14c0:	b25b      	sxtb	r3, r3
    14c2:	3301      	adds	r3, #1
    14c4:	d0dd      	beq.n	1482 <xQueueReceive+0x82>
    14c6:	2345      	movs	r3, #69	; 0x45
    14c8:	5ce3      	ldrb	r3, [r4, r3]
    14ca:	b25b      	sxtb	r3, r3
    14cc:	3301      	adds	r3, #1
    14ce:	d0dc      	beq.n	148a <xQueueReceive+0x8a>
    14d0:	4b18      	ldr	r3, [pc, #96]	; (1534 <xQueueReceive+0x134>)
    14d2:	4798      	blx	r3
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    14d4:	a901      	add	r1, sp, #4
    14d6:	a802      	add	r0, sp, #8
    14d8:	4b1b      	ldr	r3, [pc, #108]	; (1548 <xQueueReceive+0x148>)
    14da:	4798      	blx	r3
    14dc:	2800      	cmp	r0, #0
    14de:	d113      	bne.n	1508 <xQueueReceive+0x108>
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    14e0:	0020      	movs	r0, r4
    14e2:	4b1a      	ldr	r3, [pc, #104]	; (154c <xQueueReceive+0x14c>)
    14e4:	4798      	blx	r3
    14e6:	2800      	cmp	r0, #0
    14e8:	d0d3      	beq.n	1492 <xQueueReceive+0x92>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
    14ea:	0020      	movs	r0, r4
    14ec:	3024      	adds	r0, #36	; 0x24
    14ee:	9901      	ldr	r1, [sp, #4]
    14f0:	4b17      	ldr	r3, [pc, #92]	; (1550 <xQueueReceive+0x150>)
    14f2:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    14f4:	0020      	movs	r0, r4
    14f6:	4b11      	ldr	r3, [pc, #68]	; (153c <xQueueReceive+0x13c>)
    14f8:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    14fa:	4b11      	ldr	r3, [pc, #68]	; (1540 <xQueueReceive+0x140>)
    14fc:	4798      	blx	r3
    14fe:	2800      	cmp	r0, #0
    1500:	d1cc      	bne.n	149c <xQueueReceive+0x9c>
					portYIELD_WITHIN_API();
    1502:	4b0b      	ldr	r3, [pc, #44]	; (1530 <xQueueReceive+0x130>)
    1504:	4798      	blx	r3
    1506:	e7c9      	b.n	149c <xQueueReceive+0x9c>
			prvUnlockQueue(pxQueue);
    1508:	0020      	movs	r0, r4
    150a:	4b0c      	ldr	r3, [pc, #48]	; (153c <xQueueReceive+0x13c>)
    150c:	4798      	blx	r3
			(void)xTaskResumeAll();
    150e:	4b0c      	ldr	r3, [pc, #48]	; (1540 <xQueueReceive+0x140>)
    1510:	4798      	blx	r3
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    1512:	0020      	movs	r0, r4
    1514:	4b0d      	ldr	r3, [pc, #52]	; (154c <xQueueReceive+0x14c>)
    1516:	4798      	blx	r3
    1518:	2800      	cmp	r0, #0
    151a:	d0bf      	beq.n	149c <xQueueReceive+0x9c>
				return errQUEUE_EMPTY;
    151c:	2000      	movs	r0, #0
    151e:	e7a4      	b.n	146a <xQueueReceive+0x6a>
    1520:	00001e7d 	.word	0x00001e7d
    1524:	00000da5 	.word	0x00000da5
    1528:	00000fd9 	.word	0x00000fd9
    152c:	00001d79 	.word	0x00001d79
    1530:	00000d8d 	.word	0x00000d8d
    1534:	00000dbd 	.word	0x00000dbd
    1538:	00001df5 	.word	0x00001df5
    153c:	00001001 	.word	0x00001001
    1540:	00001b59 	.word	0x00001b59
    1544:	00001a31 	.word	0x00001a31
    1548:	00001e05 	.word	0x00001e05
    154c:	00000ed9 	.word	0x00000ed9
    1550:	00001d15 	.word	0x00001d15

00001554 <xQueueSemaphoreTake>:
{
    1554:	b5f0      	push	{r4, r5, r6, r7, lr}
    1556:	b085      	sub	sp, #20
    1558:	1e04      	subs	r4, r0, #0
    155a:	9101      	str	r1, [sp, #4]
	configASSERT((pxQueue));
    155c:	d004      	beq.n	1568 <xQueueSemaphoreTake+0x14>
	configASSERT(pxQueue->uxItemSize == 0);
    155e:	6c03      	ldr	r3, [r0, #64]	; 0x40
    1560:	2b00      	cmp	r3, #0
    1562:	d003      	beq.n	156c <xQueueSemaphoreTake+0x18>
    1564:	b672      	cpsid	i
    1566:	e7fe      	b.n	1566 <xQueueSemaphoreTake+0x12>
	configASSERT((pxQueue));
    1568:	b672      	cpsid	i
    156a:	e7fe      	b.n	156a <xQueueSemaphoreTake+0x16>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    156c:	4b50      	ldr	r3, [pc, #320]	; (16b0 <xQueueSemaphoreTake+0x15c>)
    156e:	4798      	blx	r3
    1570:	2800      	cmp	r0, #0
    1572:	d104      	bne.n	157e <xQueueSemaphoreTake+0x2a>
    1574:	9b01      	ldr	r3, [sp, #4]
    1576:	2b00      	cmp	r3, #0
    1578:	d005      	beq.n	1586 <xQueueSemaphoreTake+0x32>
    157a:	b672      	cpsid	i
    157c:	e7fe      	b.n	157c <xQueueSemaphoreTake+0x28>
    157e:	2500      	movs	r5, #0
    1580:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
    1582:	4f4c      	ldr	r7, [pc, #304]	; (16b4 <xQueueSemaphoreTake+0x160>)
    1584:	e048      	b.n	1618 <xQueueSemaphoreTake+0xc4>
    1586:	2500      	movs	r5, #0
    1588:	2600      	movs	r6, #0
    158a:	e7fa      	b.n	1582 <xQueueSemaphoreTake+0x2e>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - (UBaseType_t)1;
    158c:	3b01      	subs	r3, #1
    158e:	63a3      	str	r3, [r4, #56]	; 0x38
					if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
    1590:	6823      	ldr	r3, [r4, #0]
    1592:	2b00      	cmp	r3, #0
    1594:	d102      	bne.n	159c <xQueueSemaphoreTake+0x48>
						    = (int8_t *)pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as
    1596:	4b48      	ldr	r3, [pc, #288]	; (16b8 <xQueueSemaphoreTake+0x164>)
    1598:	4798      	blx	r3
    159a:	6060      	str	r0, [r4, #4]
				if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    159c:	6923      	ldr	r3, [r4, #16]
    159e:	2b00      	cmp	r3, #0
    15a0:	d007      	beq.n	15b2 <xQueueSemaphoreTake+0x5e>
					if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    15a2:	0020      	movs	r0, r4
    15a4:	3010      	adds	r0, #16
    15a6:	4b45      	ldr	r3, [pc, #276]	; (16bc <xQueueSemaphoreTake+0x168>)
    15a8:	4798      	blx	r3
    15aa:	2800      	cmp	r0, #0
    15ac:	d001      	beq.n	15b2 <xQueueSemaphoreTake+0x5e>
						queueYIELD_IF_USING_PREEMPTION();
    15ae:	4b44      	ldr	r3, [pc, #272]	; (16c0 <xQueueSemaphoreTake+0x16c>)
    15b0:	4798      	blx	r3
				taskEXIT_CRITICAL();
    15b2:	4b44      	ldr	r3, [pc, #272]	; (16c4 <xQueueSemaphoreTake+0x170>)
    15b4:	4798      	blx	r3
				return pdPASS;
    15b6:	2501      	movs	r5, #1
}
    15b8:	0028      	movs	r0, r5
    15ba:	b005      	add	sp, #20
    15bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
						configASSERT(xInheritanceOccurred == pdFALSE);
    15be:	2d00      	cmp	r5, #0
    15c0:	d001      	beq.n	15c6 <xQueueSemaphoreTake+0x72>
    15c2:	b672      	cpsid	i
    15c4:	e7fe      	b.n	15c4 <xQueueSemaphoreTake+0x70>
					taskEXIT_CRITICAL();
    15c6:	4b3f      	ldr	r3, [pc, #252]	; (16c4 <xQueueSemaphoreTake+0x170>)
    15c8:	4798      	blx	r3
					return errQUEUE_EMPTY;
    15ca:	e7f5      	b.n	15b8 <xQueueSemaphoreTake+0x64>
					vTaskInternalSetTimeOutState(&xTimeOut);
    15cc:	a802      	add	r0, sp, #8
    15ce:	4b3e      	ldr	r3, [pc, #248]	; (16c8 <xQueueSemaphoreTake+0x174>)
    15d0:	4798      	blx	r3
    15d2:	e02a      	b.n	162a <xQueueSemaphoreTake+0xd6>
		prvLockQueue(pxQueue);
    15d4:	2200      	movs	r2, #0
    15d6:	2344      	movs	r3, #68	; 0x44
    15d8:	54e2      	strb	r2, [r4, r3]
    15da:	e031      	b.n	1640 <xQueueSemaphoreTake+0xec>
    15dc:	2200      	movs	r2, #0
    15de:	2345      	movs	r3, #69	; 0x45
    15e0:	54e2      	strb	r2, [r4, r3]
    15e2:	e032      	b.n	164a <xQueueSemaphoreTake+0xf6>
						taskENTER_CRITICAL();
    15e4:	4b33      	ldr	r3, [pc, #204]	; (16b4 <xQueueSemaphoreTake+0x160>)
    15e6:	4798      	blx	r3
							xInheritanceOccurred = xTaskPriorityInherit((void *)pxQueue->pxMutexHolder);
    15e8:	6860      	ldr	r0, [r4, #4]
    15ea:	4b38      	ldr	r3, [pc, #224]	; (16cc <xQueueSemaphoreTake+0x178>)
    15ec:	4798      	blx	r3
    15ee:	0005      	movs	r5, r0
						taskEXIT_CRITICAL();
    15f0:	4b34      	ldr	r3, [pc, #208]	; (16c4 <xQueueSemaphoreTake+0x170>)
    15f2:	4798      	blx	r3
    15f4:	e039      	b.n	166a <xQueueSemaphoreTake+0x116>
				prvUnlockQueue(pxQueue);
    15f6:	0020      	movs	r0, r4
    15f8:	4b35      	ldr	r3, [pc, #212]	; (16d0 <xQueueSemaphoreTake+0x17c>)
    15fa:	4798      	blx	r3
				(void)xTaskResumeAll();
    15fc:	4b35      	ldr	r3, [pc, #212]	; (16d4 <xQueueSemaphoreTake+0x180>)
    15fe:	4798      	blx	r3
    1600:	e009      	b.n	1616 <xQueueSemaphoreTake+0xc2>
			prvUnlockQueue(pxQueue);
    1602:	0020      	movs	r0, r4
    1604:	4b32      	ldr	r3, [pc, #200]	; (16d0 <xQueueSemaphoreTake+0x17c>)
    1606:	4798      	blx	r3
			(void)xTaskResumeAll();
    1608:	4b32      	ldr	r3, [pc, #200]	; (16d4 <xQueueSemaphoreTake+0x180>)
    160a:	4798      	blx	r3
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    160c:	0020      	movs	r0, r4
    160e:	4b32      	ldr	r3, [pc, #200]	; (16d8 <xQueueSemaphoreTake+0x184>)
    1610:	4798      	blx	r3
    1612:	2800      	cmp	r0, #0
    1614:	d138      	bne.n	1688 <xQueueSemaphoreTake+0x134>
    1616:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    1618:	47b8      	blx	r7
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    161a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if (uxSemaphoreCount > (UBaseType_t)0) {
    161c:	2b00      	cmp	r3, #0
    161e:	d1b5      	bne.n	158c <xQueueSemaphoreTake+0x38>
				if (xTicksToWait == (TickType_t)0) {
    1620:	9b01      	ldr	r3, [sp, #4]
    1622:	2b00      	cmp	r3, #0
    1624:	d0cb      	beq.n	15be <xQueueSemaphoreTake+0x6a>
				} else if (xEntryTimeSet == pdFALSE) {
    1626:	2e00      	cmp	r6, #0
    1628:	d0d0      	beq.n	15cc <xQueueSemaphoreTake+0x78>
		taskEXIT_CRITICAL();
    162a:	4b26      	ldr	r3, [pc, #152]	; (16c4 <xQueueSemaphoreTake+0x170>)
    162c:	4798      	blx	r3
		vTaskSuspendAll();
    162e:	4b2b      	ldr	r3, [pc, #172]	; (16dc <xQueueSemaphoreTake+0x188>)
    1630:	4798      	blx	r3
		prvLockQueue(pxQueue);
    1632:	4b20      	ldr	r3, [pc, #128]	; (16b4 <xQueueSemaphoreTake+0x160>)
    1634:	4798      	blx	r3
    1636:	2344      	movs	r3, #68	; 0x44
    1638:	5ce3      	ldrb	r3, [r4, r3]
    163a:	b25b      	sxtb	r3, r3
    163c:	3301      	adds	r3, #1
    163e:	d0c9      	beq.n	15d4 <xQueueSemaphoreTake+0x80>
    1640:	2345      	movs	r3, #69	; 0x45
    1642:	5ce3      	ldrb	r3, [r4, r3]
    1644:	b25b      	sxtb	r3, r3
    1646:	3301      	adds	r3, #1
    1648:	d0c8      	beq.n	15dc <xQueueSemaphoreTake+0x88>
    164a:	4b1e      	ldr	r3, [pc, #120]	; (16c4 <xQueueSemaphoreTake+0x170>)
    164c:	4798      	blx	r3
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    164e:	a901      	add	r1, sp, #4
    1650:	a802      	add	r0, sp, #8
    1652:	4b23      	ldr	r3, [pc, #140]	; (16e0 <xQueueSemaphoreTake+0x18c>)
    1654:	4798      	blx	r3
    1656:	2800      	cmp	r0, #0
    1658:	d1d3      	bne.n	1602 <xQueueSemaphoreTake+0xae>
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    165a:	0020      	movs	r0, r4
    165c:	4b1e      	ldr	r3, [pc, #120]	; (16d8 <xQueueSemaphoreTake+0x184>)
    165e:	4798      	blx	r3
    1660:	2800      	cmp	r0, #0
    1662:	d0c8      	beq.n	15f6 <xQueueSemaphoreTake+0xa2>
					if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
    1664:	6823      	ldr	r3, [r4, #0]
    1666:	2b00      	cmp	r3, #0
    1668:	d0bc      	beq.n	15e4 <xQueueSemaphoreTake+0x90>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
    166a:	0020      	movs	r0, r4
    166c:	3024      	adds	r0, #36	; 0x24
    166e:	9901      	ldr	r1, [sp, #4]
    1670:	4b1c      	ldr	r3, [pc, #112]	; (16e4 <xQueueSemaphoreTake+0x190>)
    1672:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    1674:	0020      	movs	r0, r4
    1676:	4b16      	ldr	r3, [pc, #88]	; (16d0 <xQueueSemaphoreTake+0x17c>)
    1678:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    167a:	4b16      	ldr	r3, [pc, #88]	; (16d4 <xQueueSemaphoreTake+0x180>)
    167c:	4798      	blx	r3
    167e:	2800      	cmp	r0, #0
    1680:	d1c9      	bne.n	1616 <xQueueSemaphoreTake+0xc2>
					portYIELD_WITHIN_API();
    1682:	4b0f      	ldr	r3, [pc, #60]	; (16c0 <xQueueSemaphoreTake+0x16c>)
    1684:	4798      	blx	r3
    1686:	e7c6      	b.n	1616 <xQueueSemaphoreTake+0xc2>
					if (xInheritanceOccurred != pdFALSE) {
    1688:	2d00      	cmp	r5, #0
    168a:	d100      	bne.n	168e <xQueueSemaphoreTake+0x13a>
    168c:	e794      	b.n	15b8 <xQueueSemaphoreTake+0x64>
						taskENTER_CRITICAL();
    168e:	4b09      	ldr	r3, [pc, #36]	; (16b4 <xQueueSemaphoreTake+0x160>)
    1690:	4798      	blx	r3
	if (listCURRENT_LIST_LENGTH(&(pxQueue->xTasksWaitingToReceive)) > 0) {
    1692:	6a63      	ldr	r3, [r4, #36]	; 0x24
		uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    1694:	2100      	movs	r1, #0
	if (listCURRENT_LIST_LENGTH(&(pxQueue->xTasksWaitingToReceive)) > 0) {
    1696:	2b00      	cmp	r3, #0
    1698:	d003      	beq.n	16a2 <xQueueSemaphoreTake+0x14e>
		    = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY(&(pxQueue->xTasksWaitingToReceive));
    169a:	6b23      	ldr	r3, [r4, #48]	; 0x30
    169c:	681b      	ldr	r3, [r3, #0]
    169e:	3105      	adds	r1, #5
    16a0:	1ac9      	subs	r1, r1, r3
							vTaskPriorityDisinheritAfterTimeout((void *)pxQueue->pxMutexHolder,
    16a2:	6860      	ldr	r0, [r4, #4]
    16a4:	4b10      	ldr	r3, [pc, #64]	; (16e8 <xQueueSemaphoreTake+0x194>)
    16a6:	4798      	blx	r3
						taskEXIT_CRITICAL();
    16a8:	4b06      	ldr	r3, [pc, #24]	; (16c4 <xQueueSemaphoreTake+0x170>)
    16aa:	4798      	blx	r3
				return errQUEUE_EMPTY;
    16ac:	2500      	movs	r5, #0
    16ae:	e783      	b.n	15b8 <xQueueSemaphoreTake+0x64>
    16b0:	00001e7d 	.word	0x00001e7d
    16b4:	00000da5 	.word	0x00000da5
    16b8:	00002039 	.word	0x00002039
    16bc:	00001d79 	.word	0x00001d79
    16c0:	00000d8d 	.word	0x00000d8d
    16c4:	00000dbd 	.word	0x00000dbd
    16c8:	00001df5 	.word	0x00001df5
    16cc:	00001e99 	.word	0x00001e99
    16d0:	00001001 	.word	0x00001001
    16d4:	00001b59 	.word	0x00001b59
    16d8:	00000ed9 	.word	0x00000ed9
    16dc:	00001a31 	.word	0x00001a31
    16e0:	00001e05 	.word	0x00001e05
    16e4:	00001d15 	.word	0x00001d15
    16e8:	00001fad 	.word	0x00001fad

000016ec <vQueueWaitForMessageRestricted>:
{
    16ec:	b570      	push	{r4, r5, r6, lr}
    16ee:	0004      	movs	r4, r0
    16f0:	000d      	movs	r5, r1
    16f2:	0016      	movs	r6, r2
	prvLockQueue(pxQueue);
    16f4:	4b11      	ldr	r3, [pc, #68]	; (173c <vQueueWaitForMessageRestricted+0x50>)
    16f6:	4798      	blx	r3
    16f8:	2344      	movs	r3, #68	; 0x44
    16fa:	5ce3      	ldrb	r3, [r4, r3]
    16fc:	b25b      	sxtb	r3, r3
    16fe:	3301      	adds	r3, #1
    1700:	d00d      	beq.n	171e <vQueueWaitForMessageRestricted+0x32>
    1702:	2345      	movs	r3, #69	; 0x45
    1704:	5ce3      	ldrb	r3, [r4, r3]
    1706:	b25b      	sxtb	r3, r3
    1708:	3301      	adds	r3, #1
    170a:	d00c      	beq.n	1726 <vQueueWaitForMessageRestricted+0x3a>
    170c:	4b0c      	ldr	r3, [pc, #48]	; (1740 <vQueueWaitForMessageRestricted+0x54>)
    170e:	4798      	blx	r3
	if (pxQueue->uxMessagesWaiting == (UBaseType_t)0U) {
    1710:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    1712:	2b00      	cmp	r3, #0
    1714:	d00b      	beq.n	172e <vQueueWaitForMessageRestricted+0x42>
	prvUnlockQueue(pxQueue);
    1716:	0020      	movs	r0, r4
    1718:	4b0a      	ldr	r3, [pc, #40]	; (1744 <vQueueWaitForMessageRestricted+0x58>)
    171a:	4798      	blx	r3
}
    171c:	bd70      	pop	{r4, r5, r6, pc}
	prvLockQueue(pxQueue);
    171e:	2200      	movs	r2, #0
    1720:	2344      	movs	r3, #68	; 0x44
    1722:	54e2      	strb	r2, [r4, r3]
    1724:	e7ed      	b.n	1702 <vQueueWaitForMessageRestricted+0x16>
    1726:	2200      	movs	r2, #0
    1728:	2345      	movs	r3, #69	; 0x45
    172a:	54e2      	strb	r2, [r4, r3]
    172c:	e7ee      	b.n	170c <vQueueWaitForMessageRestricted+0x20>
		vTaskPlaceOnEventListRestricted(&(pxQueue->xTasksWaitingToReceive), xTicksToWait, xWaitIndefinitely);
    172e:	0020      	movs	r0, r4
    1730:	3024      	adds	r0, #36	; 0x24
    1732:	0032      	movs	r2, r6
    1734:	0029      	movs	r1, r5
    1736:	4b04      	ldr	r3, [pc, #16]	; (1748 <vQueueWaitForMessageRestricted+0x5c>)
    1738:	4798      	blx	r3
    173a:	e7ec      	b.n	1716 <vQueueWaitForMessageRestricted+0x2a>
    173c:	00000da5 	.word	0x00000da5
    1740:	00000dbd 	.word	0x00000dbd
    1744:	00001001 	.word	0x00001001
    1748:	00001d41 	.word	0x00001d41

0000174c <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime(void)
{
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    174c:	4b08      	ldr	r3, [pc, #32]	; (1770 <prvResetNextTaskUnblockTime+0x24>)
    174e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1750:	681b      	ldr	r3, [r3, #0]
    1752:	2b00      	cmp	r3, #0
    1754:	d006      	beq.n	1764 <prvResetNextTaskUnblockTime+0x18>
	} else {
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    1756:	4b06      	ldr	r3, [pc, #24]	; (1770 <prvResetNextTaskUnblockTime+0x24>)
    1758:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    175a:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
    175c:	68d2      	ldr	r2, [r2, #12]
    175e:	6852      	ldr	r2, [r2, #4]
    1760:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
    1762:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
    1764:	2201      	movs	r2, #1
    1766:	4252      	negs	r2, r2
    1768:	4b01      	ldr	r3, [pc, #4]	; (1770 <prvResetNextTaskUnblockTime+0x24>)
    176a:	62da      	str	r2, [r3, #44]	; 0x2c
    176c:	e7f9      	b.n	1762 <prvResetNextTaskUnblockTime+0x16>
    176e:	46c0      	nop			; (mov r8, r8)
    1770:	200009b0 	.word	0x200009b0

00001774 <prvIdleTask>:
{
    1774:	b570      	push	{r4, r5, r6, lr}
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
    1776:	4c03      	ldr	r4, [pc, #12]	; (1784 <prvIdleTask+0x10>)
				taskYIELD();
    1778:	4d03      	ldr	r5, [pc, #12]	; (1788 <prvIdleTask+0x14>)
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
    177a:	6b23      	ldr	r3, [r4, #48]	; 0x30
    177c:	2b01      	cmp	r3, #1
    177e:	d9fc      	bls.n	177a <prvIdleTask+0x6>
				taskYIELD();
    1780:	47a8      	blx	r5
    1782:	e7fa      	b.n	177a <prvIdleTask+0x6>
    1784:	200009b0 	.word	0x200009b0
    1788:	00000d8d 	.word	0x00000d8d

0000178c <prvAddCurrentTaskToDelayedList>:

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely)
{
    178c:	b570      	push	{r4, r5, r6, lr}
    178e:	0004      	movs	r4, r0
    1790:	000d      	movs	r5, r1
	TickType_t       xTimeToWake;
	const TickType_t xConstTickCount = xTickCount;
    1792:	4b15      	ldr	r3, [pc, #84]	; (17e8 <prvAddCurrentTaskToDelayedList+0x5c>)
    1794:	695e      	ldr	r6, [r3, #20]
	}
#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
    1796:	6998      	ldr	r0, [r3, #24]
    1798:	3004      	adds	r0, #4
    179a:	4b14      	ldr	r3, [pc, #80]	; (17ec <prvAddCurrentTaskToDelayedList+0x60>)
    179c:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

#if (INCLUDE_vTaskSuspend == 1)
	{
		if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
    179e:	1c63      	adds	r3, r4, #1
    17a0:	d012      	beq.n	17c8 <prvAddCurrentTaskToDelayedList+0x3c>
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
		} else {
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    17a2:	1934      	adds	r4, r6, r4

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
    17a4:	4b10      	ldr	r3, [pc, #64]	; (17e8 <prvAddCurrentTaskToDelayedList+0x5c>)
    17a6:	699b      	ldr	r3, [r3, #24]
    17a8:	605c      	str	r4, [r3, #4]

			if (xTimeToWake < xConstTickCount) {
    17aa:	42a6      	cmp	r6, r4
    17ac:	d815      	bhi.n	17da <prvAddCurrentTaskToDelayedList+0x4e>
				list. */
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
			} else {
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
    17ae:	4d10      	ldr	r5, [pc, #64]	; (17f0 <prvAddCurrentTaskToDelayedList+0x64>)
    17b0:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    17b2:	4b0d      	ldr	r3, [pc, #52]	; (17e8 <prvAddCurrentTaskToDelayedList+0x5c>)
    17b4:	6999      	ldr	r1, [r3, #24]
    17b6:	3104      	adds	r1, #4
    17b8:	4b0e      	ldr	r3, [pc, #56]	; (17f4 <prvAddCurrentTaskToDelayedList+0x68>)
    17ba:	4798      	blx	r3

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if (xTimeToWake < xNextTaskUnblockTime) {
    17bc:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    17be:	429c      	cmp	r4, r3
    17c0:	d211      	bcs.n	17e6 <prvAddCurrentTaskToDelayedList+0x5a>
					xNextTaskUnblockTime = xTimeToWake;
    17c2:	4b0b      	ldr	r3, [pc, #44]	; (17f0 <prvAddCurrentTaskToDelayedList+0x64>)
    17c4:	62dc      	str	r4, [r3, #44]	; 0x2c

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		(void)xCanBlockIndefinitely;
	}
#endif /* INCLUDE_vTaskSuspend */
}
    17c6:	e00e      	b.n	17e6 <prvAddCurrentTaskToDelayedList+0x5a>
		if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
    17c8:	2d00      	cmp	r5, #0
    17ca:	d0ea      	beq.n	17a2 <prvAddCurrentTaskToDelayedList+0x16>
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
    17cc:	4b06      	ldr	r3, [pc, #24]	; (17e8 <prvAddCurrentTaskToDelayedList+0x5c>)
    17ce:	6999      	ldr	r1, [r3, #24]
    17d0:	3104      	adds	r1, #4
    17d2:	4807      	ldr	r0, [pc, #28]	; (17f0 <prvAddCurrentTaskToDelayedList+0x64>)
    17d4:	4b08      	ldr	r3, [pc, #32]	; (17f8 <prvAddCurrentTaskToDelayedList+0x6c>)
    17d6:	4798      	blx	r3
    17d8:	e005      	b.n	17e6 <prvAddCurrentTaskToDelayedList+0x5a>
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
    17da:	4b03      	ldr	r3, [pc, #12]	; (17e8 <prvAddCurrentTaskToDelayedList+0x5c>)
    17dc:	69d8      	ldr	r0, [r3, #28]
    17de:	6999      	ldr	r1, [r3, #24]
    17e0:	3104      	adds	r1, #4
    17e2:	4b04      	ldr	r3, [pc, #16]	; (17f4 <prvAddCurrentTaskToDelayedList+0x68>)
    17e4:	4798      	blx	r3
}
    17e6:	bd70      	pop	{r4, r5, r6, pc}
    17e8:	20000a30 	.word	0x20000a30
    17ec:	00000c7f 	.word	0x00000c7f
    17f0:	200009b0 	.word	0x200009b0
    17f4:	00000c51 	.word	0x00000c51
    17f8:	00000c39 	.word	0x00000c39

000017fc <xTaskCreate>:
{
    17fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    17fe:	46d6      	mov	lr, sl
    1800:	464f      	mov	r7, r9
    1802:	4646      	mov	r6, r8
    1804:	b5c0      	push	{r6, r7, lr}
    1806:	b084      	sub	sp, #16
    1808:	9001      	str	r0, [sp, #4]
    180a:	000d      	movs	r5, r1
    180c:	9302      	str	r3, [sp, #8]
		pxStack = (StackType_t *)pvPortMalloc(
    180e:	0097      	lsls	r7, r2, #2
    1810:	0038      	movs	r0, r7
    1812:	4b61      	ldr	r3, [pc, #388]	; (1998 <xTaskCreate+0x19c>)
    1814:	4798      	blx	r3
    1816:	1e06      	subs	r6, r0, #0
		if (pxStack != NULL) {
    1818:	d100      	bne.n	181c <xTaskCreate+0x20>
    181a:	e089      	b.n	1930 <xTaskCreate+0x134>
			pxNewTCB = (TCB_t *)pvPortMalloc(
    181c:	2054      	movs	r0, #84	; 0x54
    181e:	4b5e      	ldr	r3, [pc, #376]	; (1998 <xTaskCreate+0x19c>)
    1820:	4798      	blx	r3
    1822:	1e04      	subs	r4, r0, #0
			if (pxNewTCB != NULL) {
    1824:	d100      	bne.n	1828 <xTaskCreate+0x2c>
    1826:	e080      	b.n	192a <xTaskCreate+0x12e>
				pxNewTCB->pxStack = pxStack;
    1828:	6306      	str	r6, [r0, #48]	; 0x30
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
    182a:	003a      	movs	r2, r7
    182c:	21a5      	movs	r1, #165	; 0xa5
    182e:	0030      	movs	r0, r6
    1830:	4b5a      	ldr	r3, [pc, #360]	; (199c <xTaskCreate+0x1a0>)
    1832:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
    1834:	1f3a      	subs	r2, r7, #4
    1836:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1838:	469c      	mov	ip, r3
    183a:	4462      	add	r2, ip
		                      & (~(
    183c:	2307      	movs	r3, #7
    183e:	439a      	bics	r2, r3
    1840:	4690      	mov	r8, r2
		pxNewTCB->pcTaskName[x] = pcName[x];
    1842:	782a      	ldrb	r2, [r5, #0]
    1844:	332d      	adds	r3, #45	; 0x2d
    1846:	54e2      	strb	r2, [r4, r3]
		if (pcName[x] == 0x00) {
    1848:	782b      	ldrb	r3, [r5, #0]
    184a:	2b00      	cmp	r3, #0
    184c:	d00d      	beq.n	186a <xTaskCreate+0x6e>
    184e:	3501      	adds	r5, #1
    1850:	0023      	movs	r3, r4
    1852:	3335      	adds	r3, #53	; 0x35
    1854:	0020      	movs	r0, r4
    1856:	303c      	adds	r0, #60	; 0x3c
		pxNewTCB->pcTaskName[x] = pcName[x];
    1858:	782a      	ldrb	r2, [r5, #0]
    185a:	701a      	strb	r2, [r3, #0]
		if (pcName[x] == 0x00) {
    185c:	782a      	ldrb	r2, [r5, #0]
    185e:	2a00      	cmp	r2, #0
    1860:	d003      	beq.n	186a <xTaskCreate+0x6e>
    1862:	3501      	adds	r5, #1
    1864:	3301      	adds	r3, #1
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
    1866:	4283      	cmp	r3, r0
    1868:	d1f6      	bne.n	1858 <xTaskCreate+0x5c>
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
    186a:	2200      	movs	r2, #0
    186c:	233b      	movs	r3, #59	; 0x3b
    186e:	54e2      	strb	r2, [r4, r3]
    1870:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    1872:	2f04      	cmp	r7, #4
    1874:	d900      	bls.n	1878 <xTaskCreate+0x7c>
    1876:	2704      	movs	r7, #4
	pxNewTCB->uxPriority = uxPriority;
    1878:	62e7      	str	r7, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
    187a:	6467      	str	r7, [r4, #68]	; 0x44
		pxNewTCB->uxMutexesHeld  = 0;
    187c:	2600      	movs	r6, #0
    187e:	64a6      	str	r6, [r4, #72]	; 0x48
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
    1880:	1d23      	adds	r3, r4, #4
    1882:	9303      	str	r3, [sp, #12]
    1884:	0018      	movs	r0, r3
    1886:	4d46      	ldr	r5, [pc, #280]	; (19a0 <xTaskCreate+0x1a4>)
    1888:	47a8      	blx	r5
	vListInitialiseItem(&(pxNewTCB->xEventListItem));
    188a:	0020      	movs	r0, r4
    188c:	3018      	adds	r0, #24
    188e:	47a8      	blx	r5
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
    1890:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE(
    1892:	2305      	movs	r3, #5
    1894:	1bdb      	subs	r3, r3, r7
    1896:	61a3      	str	r3, [r4, #24]
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
    1898:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
    189a:	64e6      	str	r6, [r4, #76]	; 0x4c
		pxNewTCB->ucNotifyState   = taskNOT_WAITING_NOTIFICATION;
    189c:	2350      	movs	r3, #80	; 0x50
    189e:	54e6      	strb	r6, [r4, r3]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    18a0:	9a02      	ldr	r2, [sp, #8]
    18a2:	9901      	ldr	r1, [sp, #4]
    18a4:	4640      	mov	r0, r8
    18a6:	4b3f      	ldr	r3, [pc, #252]	; (19a4 <xTaskCreate+0x1a8>)
    18a8:	4798      	blx	r3
    18aa:	6020      	str	r0, [r4, #0]
	if ((void *)pxCreatedTask != NULL) {
    18ac:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    18ae:	2b00      	cmp	r3, #0
    18b0:	d000      	beq.n	18b4 <xTaskCreate+0xb8>
		*pxCreatedTask = (TaskHandle_t)pxNewTCB;
    18b2:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
    18b4:	4b3c      	ldr	r3, [pc, #240]	; (19a8 <xTaskCreate+0x1ac>)
    18b6:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
    18b8:	4b3c      	ldr	r3, [pc, #240]	; (19ac <xTaskCreate+0x1b0>)
    18ba:	6a1a      	ldr	r2, [r3, #32]
    18bc:	3201      	adds	r2, #1
    18be:	621a      	str	r2, [r3, #32]
		if (pxCurrentTCB == NULL) {
    18c0:	699b      	ldr	r3, [r3, #24]
    18c2:	2b00      	cmp	r3, #0
    18c4:	d037      	beq.n	1936 <xTaskCreate+0x13a>
			if (xSchedulerRunning == pdFALSE) {
    18c6:	4b39      	ldr	r3, [pc, #228]	; (19ac <xTaskCreate+0x1b0>)
    18c8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    18ca:	2b00      	cmp	r3, #0
    18cc:	d107      	bne.n	18de <xTaskCreate+0xe2>
				if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
    18ce:	4b37      	ldr	r3, [pc, #220]	; (19ac <xTaskCreate+0x1b0>)
    18d0:	699b      	ldr	r3, [r3, #24]
    18d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    18d4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    18d6:	4293      	cmp	r3, r2
    18d8:	d801      	bhi.n	18de <xTaskCreate+0xe2>
					pxCurrentTCB = pxNewTCB;
    18da:	4b34      	ldr	r3, [pc, #208]	; (19ac <xTaskCreate+0x1b0>)
    18dc:	619c      	str	r4, [r3, #24]
		uxTaskNumber++;
    18de:	4933      	ldr	r1, [pc, #204]	; (19ac <xTaskCreate+0x1b0>)
    18e0:	6d0b      	ldr	r3, [r1, #80]	; 0x50
    18e2:	3301      	adds	r3, #1
    18e4:	650b      	str	r3, [r1, #80]	; 0x50
			pxNewTCB->uxTCBNumber = uxTaskNumber;
    18e6:	63e3      	str	r3, [r4, #60]	; 0x3c
		prvAddTaskToReadyList(pxNewTCB);
    18e8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    18ea:	6d4b      	ldr	r3, [r1, #84]	; 0x54
    18ec:	429a      	cmp	r2, r3
    18ee:	d900      	bls.n	18f2 <xTaskCreate+0xf6>
    18f0:	654a      	str	r2, [r1, #84]	; 0x54
    18f2:	0090      	lsls	r0, r2, #2
    18f4:	1882      	adds	r2, r0, r2
    18f6:	0092      	lsls	r2, r2, #2
    18f8:	482d      	ldr	r0, [pc, #180]	; (19b0 <xTaskCreate+0x1b4>)
    18fa:	3030      	adds	r0, #48	; 0x30
    18fc:	1880      	adds	r0, r0, r2
    18fe:	9903      	ldr	r1, [sp, #12]
    1900:	4b2c      	ldr	r3, [pc, #176]	; (19b4 <xTaskCreate+0x1b8>)
    1902:	4798      	blx	r3
	taskEXIT_CRITICAL();
    1904:	4b2c      	ldr	r3, [pc, #176]	; (19b8 <xTaskCreate+0x1bc>)
    1906:	4798      	blx	r3
	if (xSchedulerRunning != pdFALSE) {
    1908:	4b28      	ldr	r3, [pc, #160]	; (19ac <xTaskCreate+0x1b0>)
    190a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
		xReturn = pdPASS;
    190c:	2001      	movs	r0, #1
	if (xSchedulerRunning != pdFALSE) {
    190e:	2b00      	cmp	r3, #0
    1910:	d005      	beq.n	191e <xTaskCreate+0x122>
		if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
    1912:	4b26      	ldr	r3, [pc, #152]	; (19ac <xTaskCreate+0x1b0>)
    1914:	699b      	ldr	r3, [r3, #24]
    1916:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1918:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    191a:	429a      	cmp	r2, r3
    191c:	d338      	bcc.n	1990 <xTaskCreate+0x194>
}
    191e:	b004      	add	sp, #16
    1920:	bc1c      	pop	{r2, r3, r4}
    1922:	4690      	mov	r8, r2
    1924:	4699      	mov	r9, r3
    1926:	46a2      	mov	sl, r4
    1928:	bdf0      	pop	{r4, r5, r6, r7, pc}
				vPortFree(pxStack);
    192a:	0030      	movs	r0, r6
    192c:	4b23      	ldr	r3, [pc, #140]	; (19bc <xTaskCreate+0x1c0>)
    192e:	4798      	blx	r3
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1930:	2001      	movs	r0, #1
    1932:	4240      	negs	r0, r0
    1934:	e7f3      	b.n	191e <xTaskCreate+0x122>
			pxCurrentTCB = pxNewTCB;
    1936:	4b1d      	ldr	r3, [pc, #116]	; (19ac <xTaskCreate+0x1b0>)
    1938:	619c      	str	r4, [r3, #24]
			if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
    193a:	6a1b      	ldr	r3, [r3, #32]
    193c:	2b01      	cmp	r3, #1
    193e:	d1ce      	bne.n	18de <xTaskCreate+0xe2>
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
    1940:	4f1b      	ldr	r7, [pc, #108]	; (19b0 <xTaskCreate+0x1b4>)
    1942:	0038      	movs	r0, r7
    1944:	3030      	adds	r0, #48	; 0x30
    1946:	4e1e      	ldr	r6, [pc, #120]	; (19c0 <xTaskCreate+0x1c4>)
    1948:	47b0      	blx	r6
    194a:	0038      	movs	r0, r7
    194c:	3044      	adds	r0, #68	; 0x44
    194e:	47b0      	blx	r6
    1950:	0038      	movs	r0, r7
    1952:	3058      	adds	r0, #88	; 0x58
    1954:	47b0      	blx	r6
    1956:	0038      	movs	r0, r7
    1958:	306c      	adds	r0, #108	; 0x6c
    195a:	47b0      	blx	r6
    195c:	0038      	movs	r0, r7
    195e:	3080      	adds	r0, #128	; 0x80
    1960:	47b0      	blx	r6
	vListInitialise(&xDelayedTaskList1);
    1962:	4b12      	ldr	r3, [pc, #72]	; (19ac <xTaskCreate+0x1b0>)
    1964:	4698      	mov	r8, r3
    1966:	2324      	movs	r3, #36	; 0x24
    1968:	4443      	add	r3, r8
    196a:	469a      	mov	sl, r3
    196c:	0018      	movs	r0, r3
    196e:	47b0      	blx	r6
	vListInitialise(&xDelayedTaskList2);
    1970:	2338      	movs	r3, #56	; 0x38
    1972:	4443      	add	r3, r8
    1974:	4699      	mov	r9, r3
    1976:	0018      	movs	r0, r3
    1978:	47b0      	blx	r6
	vListInitialise(&xPendingReadyList);
    197a:	0038      	movs	r0, r7
    197c:	3014      	adds	r0, #20
    197e:	47b0      	blx	r6
		vListInitialise(&xSuspendedTaskList);
    1980:	0038      	movs	r0, r7
    1982:	47b0      	blx	r6
	pxDelayedTaskList         = &xDelayedTaskList1;
    1984:	4653      	mov	r3, sl
    1986:	62bb      	str	r3, [r7, #40]	; 0x28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1988:	4643      	mov	r3, r8
    198a:	464a      	mov	r2, r9
    198c:	61da      	str	r2, [r3, #28]
    198e:	e7a6      	b.n	18de <xTaskCreate+0xe2>
			taskYIELD_IF_USING_PREEMPTION();
    1990:	4b0c      	ldr	r3, [pc, #48]	; (19c4 <xTaskCreate+0x1c8>)
    1992:	4798      	blx	r3
		xReturn = pdPASS;
    1994:	2001      	movs	r0, #1
    1996:	e7c2      	b.n	191e <xTaskCreate+0x122>
    1998:	00000e65 	.word	0x00000e65
    199c:	00002427 	.word	0x00002427
    19a0:	00000c33 	.word	0x00000c33
    19a4:	00000d05 	.word	0x00000d05
    19a8:	00000da5 	.word	0x00000da5
    19ac:	20000a30 	.word	0x20000a30
    19b0:	200009b0 	.word	0x200009b0
    19b4:	00000c39 	.word	0x00000c39
    19b8:	00000dbd 	.word	0x00000dbd
    19bc:	00000ecd 	.word	0x00000ecd
    19c0:	00000c1d 	.word	0x00000c1d
    19c4:	00000d8d 	.word	0x00000d8d

000019c8 <vTaskStartScheduler>:
{
    19c8:	b510      	push	{r4, lr}
    19ca:	b082      	sub	sp, #8
		xReturn = xTaskCreate(prvIdleTask,
    19cc:	4b11      	ldr	r3, [pc, #68]	; (1a14 <vTaskStartScheduler+0x4c>)
    19ce:	335c      	adds	r3, #92	; 0x5c
    19d0:	9301      	str	r3, [sp, #4]
    19d2:	2300      	movs	r3, #0
    19d4:	9300      	str	r3, [sp, #0]
    19d6:	2240      	movs	r2, #64	; 0x40
    19d8:	490f      	ldr	r1, [pc, #60]	; (1a18 <vTaskStartScheduler+0x50>)
    19da:	4810      	ldr	r0, [pc, #64]	; (1a1c <vTaskStartScheduler+0x54>)
    19dc:	4c10      	ldr	r4, [pc, #64]	; (1a20 <vTaskStartScheduler+0x58>)
    19de:	47a0      	blx	r4
		if (xReturn == pdPASS) {
    19e0:	2801      	cmp	r0, #1
    19e2:	d003      	beq.n	19ec <vTaskStartScheduler+0x24>
		configASSERT(xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY);
    19e4:	1c43      	adds	r3, r0, #1
    19e6:	d012      	beq.n	1a0e <vTaskStartScheduler+0x46>
}
    19e8:	b002      	add	sp, #8
    19ea:	bd10      	pop	{r4, pc}
			xReturn = xTimerCreateTimerTask();
    19ec:	4b0d      	ldr	r3, [pc, #52]	; (1a24 <vTaskStartScheduler+0x5c>)
    19ee:	4798      	blx	r3
	if (xReturn == pdPASS) {
    19f0:	2801      	cmp	r0, #1
    19f2:	d1f7      	bne.n	19e4 <vTaskStartScheduler+0x1c>
		portDISABLE_INTERRUPTS();
    19f4:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
    19f6:	2201      	movs	r2, #1
    19f8:	4252      	negs	r2, r2
    19fa:	4b0b      	ldr	r3, [pc, #44]	; (1a28 <vTaskStartScheduler+0x60>)
    19fc:	62da      	str	r2, [r3, #44]	; 0x2c
		xSchedulerRunning    = pdTRUE;
    19fe:	4b05      	ldr	r3, [pc, #20]	; (1a14 <vTaskStartScheduler+0x4c>)
    1a00:	3202      	adds	r2, #2
    1a02:	64da      	str	r2, [r3, #76]	; 0x4c
		xTickCount           = (TickType_t)0U;
    1a04:	2200      	movs	r2, #0
    1a06:	615a      	str	r2, [r3, #20]
		if (xPortStartScheduler() != pdFALSE) {
    1a08:	4b08      	ldr	r3, [pc, #32]	; (1a2c <vTaskStartScheduler+0x64>)
    1a0a:	4798      	blx	r3
    1a0c:	e7ec      	b.n	19e8 <vTaskStartScheduler+0x20>
		configASSERT(xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY);
    1a0e:	b672      	cpsid	i
    1a10:	e7fe      	b.n	1a10 <vTaskStartScheduler+0x48>
    1a12:	46c0      	nop			; (mov r8, r8)
    1a14:	20000a30 	.word	0x20000a30
    1a18:	000024ec 	.word	0x000024ec
    1a1c:	00001775 	.word	0x00001775
    1a20:	000017fd 	.word	0x000017fd
    1a24:	000020e9 	.word	0x000020e9
    1a28:	200009b0 	.word	0x200009b0
    1a2c:	00000d29 	.word	0x00000d29

00001a30 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    1a30:	4a02      	ldr	r2, [pc, #8]	; (1a3c <vTaskSuspendAll+0xc>)
    1a32:	6d93      	ldr	r3, [r2, #88]	; 0x58
    1a34:	3301      	adds	r3, #1
    1a36:	6593      	str	r3, [r2, #88]	; 0x58
}
    1a38:	4770      	bx	lr
    1a3a:	46c0      	nop			; (mov r8, r8)
    1a3c:	20000a30 	.word	0x20000a30

00001a40 <xTaskGetTickCount>:
		xTicks = xTickCount;
    1a40:	4b01      	ldr	r3, [pc, #4]	; (1a48 <xTaskGetTickCount+0x8>)
    1a42:	6958      	ldr	r0, [r3, #20]
}
    1a44:	4770      	bx	lr
    1a46:	46c0      	nop			; (mov r8, r8)
    1a48:	20000a30 	.word	0x20000a30

00001a4c <xTaskIncrementTick>:
{
    1a4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1a4e:	46ce      	mov	lr, r9
    1a50:	4647      	mov	r7, r8
    1a52:	b580      	push	{r7, lr}
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    1a54:	4b3b      	ldr	r3, [pc, #236]	; (1b44 <xTaskIncrementTick+0xf8>)
    1a56:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    1a58:	2b00      	cmp	r3, #0
    1a5a:	d164      	bne.n	1b26 <xTaskIncrementTick+0xda>
		const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
    1a5c:	4b39      	ldr	r3, [pc, #228]	; (1b44 <xTaskIncrementTick+0xf8>)
    1a5e:	695e      	ldr	r6, [r3, #20]
    1a60:	3601      	adds	r6, #1
		xTickCount = xConstTickCount;
    1a62:	615e      	str	r6, [r3, #20]
		if (xConstTickCount
    1a64:	2e00      	cmp	r6, #0
    1a66:	d111      	bne.n	1a8c <xTaskIncrementTick+0x40>
			taskSWITCH_DELAYED_LISTS();
    1a68:	4b37      	ldr	r3, [pc, #220]	; (1b48 <xTaskIncrementTick+0xfc>)
    1a6a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1a6c:	681b      	ldr	r3, [r3, #0]
    1a6e:	2b00      	cmp	r3, #0
    1a70:	d001      	beq.n	1a76 <xTaskIncrementTick+0x2a>
    1a72:	b672      	cpsid	i
    1a74:	e7fe      	b.n	1a74 <xTaskIncrementTick+0x28>
    1a76:	4a34      	ldr	r2, [pc, #208]	; (1b48 <xTaskIncrementTick+0xfc>)
    1a78:	6a91      	ldr	r1, [r2, #40]	; 0x28
    1a7a:	4b32      	ldr	r3, [pc, #200]	; (1b44 <xTaskIncrementTick+0xf8>)
    1a7c:	69d8      	ldr	r0, [r3, #28]
    1a7e:	6290      	str	r0, [r2, #40]	; 0x28
    1a80:	61d9      	str	r1, [r3, #28]
    1a82:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    1a84:	3201      	adds	r2, #1
    1a86:	661a      	str	r2, [r3, #96]	; 0x60
    1a88:	4b30      	ldr	r3, [pc, #192]	; (1b4c <xTaskIncrementTick+0x100>)
    1a8a:	4798      	blx	r3
		if (xConstTickCount >= xNextTaskUnblockTime) {
    1a8c:	4b2e      	ldr	r3, [pc, #184]	; (1b48 <xTaskIncrementTick+0xfc>)
    1a8e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	BaseType_t xSwitchRequired = pdFALSE;
    1a90:	2400      	movs	r4, #0
		if (xConstTickCount >= xNextTaskUnblockTime) {
    1a92:	429e      	cmp	r6, r3
    1a94:	d337      	bcc.n	1b06 <xTaskIncrementTick+0xba>
    1a96:	2400      	movs	r4, #0
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    1a98:	4b2b      	ldr	r3, [pc, #172]	; (1b48 <xTaskIncrementTick+0xfc>)
    1a9a:	4699      	mov	r9, r3
					prvAddTaskToReadyList(pxTCB);
    1a9c:	2230      	movs	r2, #48	; 0x30
    1a9e:	4694      	mov	ip, r2
    1aa0:	4463      	add	r3, ip
    1aa2:	4698      	mov	r8, r3
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    1aa4:	464b      	mov	r3, r9
    1aa6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1aa8:	681b      	ldr	r3, [r3, #0]
    1aaa:	2b00      	cmp	r3, #0
    1aac:	d027      	beq.n	1afe <xTaskIncrementTick+0xb2>
					pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    1aae:	4b26      	ldr	r3, [pc, #152]	; (1b48 <xTaskIncrementTick+0xfc>)
    1ab0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1ab2:	68db      	ldr	r3, [r3, #12]
    1ab4:	68df      	ldr	r7, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
    1ab6:	687b      	ldr	r3, [r7, #4]
					if (xConstTickCount < xItemValue) {
    1ab8:	429e      	cmp	r6, r3
    1aba:	d331      	bcc.n	1b20 <xTaskIncrementTick+0xd4>
					(void)uxListRemove(&(pxTCB->xStateListItem));
    1abc:	1d3d      	adds	r5, r7, #4
    1abe:	0028      	movs	r0, r5
    1ac0:	4b23      	ldr	r3, [pc, #140]	; (1b50 <xTaskIncrementTick+0x104>)
    1ac2:	4798      	blx	r3
					if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
    1ac4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1ac6:	2b00      	cmp	r3, #0
    1ac8:	d003      	beq.n	1ad2 <xTaskIncrementTick+0x86>
						(void)uxListRemove(&(pxTCB->xEventListItem));
    1aca:	0038      	movs	r0, r7
    1acc:	3018      	adds	r0, #24
    1ace:	4b20      	ldr	r3, [pc, #128]	; (1b50 <xTaskIncrementTick+0x104>)
    1ad0:	4798      	blx	r3
					prvAddTaskToReadyList(pxTCB);
    1ad2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1ad4:	4a1b      	ldr	r2, [pc, #108]	; (1b44 <xTaskIncrementTick+0xf8>)
    1ad6:	6d52      	ldr	r2, [r2, #84]	; 0x54
    1ad8:	4293      	cmp	r3, r2
    1ada:	d901      	bls.n	1ae0 <xTaskIncrementTick+0x94>
    1adc:	4a19      	ldr	r2, [pc, #100]	; (1b44 <xTaskIncrementTick+0xf8>)
    1ade:	6553      	str	r3, [r2, #84]	; 0x54
    1ae0:	0098      	lsls	r0, r3, #2
    1ae2:	18c0      	adds	r0, r0, r3
    1ae4:	0080      	lsls	r0, r0, #2
    1ae6:	4440      	add	r0, r8
    1ae8:	0029      	movs	r1, r5
    1aea:	4b1a      	ldr	r3, [pc, #104]	; (1b54 <xTaskIncrementTick+0x108>)
    1aec:	4798      	blx	r3
						if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    1aee:	4b15      	ldr	r3, [pc, #84]	; (1b44 <xTaskIncrementTick+0xf8>)
    1af0:	699b      	ldr	r3, [r3, #24]
    1af2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    1af4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1af6:	429a      	cmp	r2, r3
    1af8:	d3d4      	bcc.n	1aa4 <xTaskIncrementTick+0x58>
							xSwitchRequired = pdTRUE;
    1afa:	2401      	movs	r4, #1
    1afc:	e7d2      	b.n	1aa4 <xTaskIncrementTick+0x58>
					    = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1afe:	2201      	movs	r2, #1
    1b00:	4252      	negs	r2, r2
    1b02:	4b11      	ldr	r3, [pc, #68]	; (1b48 <xTaskIncrementTick+0xfc>)
    1b04:	62da      	str	r2, [r3, #44]	; 0x2c
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
    1b06:	4b0f      	ldr	r3, [pc, #60]	; (1b44 <xTaskIncrementTick+0xf8>)
    1b08:	699b      	ldr	r3, [r3, #24]
    1b0a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1b0c:	0093      	lsls	r3, r2, #2
    1b0e:	189b      	adds	r3, r3, r2
    1b10:	009b      	lsls	r3, r3, #2
    1b12:	4a0d      	ldr	r2, [pc, #52]	; (1b48 <xTaskIncrementTick+0xfc>)
    1b14:	18d3      	adds	r3, r2, r3
    1b16:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    1b18:	2b01      	cmp	r3, #1
    1b1a:	d909      	bls.n	1b30 <xTaskIncrementTick+0xe4>
				xSwitchRequired = pdTRUE;
    1b1c:	2401      	movs	r4, #1
    1b1e:	e007      	b.n	1b30 <xTaskIncrementTick+0xe4>
						xNextTaskUnblockTime = xItemValue;
    1b20:	4a09      	ldr	r2, [pc, #36]	; (1b48 <xTaskIncrementTick+0xfc>)
    1b22:	62d3      	str	r3, [r2, #44]	; 0x2c
						break;
    1b24:	e7ef      	b.n	1b06 <xTaskIncrementTick+0xba>
		++uxPendedTicks;
    1b26:	4a07      	ldr	r2, [pc, #28]	; (1b44 <xTaskIncrementTick+0xf8>)
    1b28:	6e53      	ldr	r3, [r2, #100]	; 0x64
    1b2a:	3301      	adds	r3, #1
    1b2c:	6653      	str	r3, [r2, #100]	; 0x64
	BaseType_t xSwitchRequired = pdFALSE;
    1b2e:	2400      	movs	r4, #0
		if (xYieldPending != pdFALSE) {
    1b30:	4b04      	ldr	r3, [pc, #16]	; (1b44 <xTaskIncrementTick+0xf8>)
    1b32:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    1b34:	2b00      	cmp	r3, #0
    1b36:	d000      	beq.n	1b3a <xTaskIncrementTick+0xee>
			xSwitchRequired = pdTRUE;
    1b38:	2401      	movs	r4, #1
}
    1b3a:	0020      	movs	r0, r4
    1b3c:	bc0c      	pop	{r2, r3}
    1b3e:	4690      	mov	r8, r2
    1b40:	4699      	mov	r9, r3
    1b42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1b44:	20000a30 	.word	0x20000a30
    1b48:	200009b0 	.word	0x200009b0
    1b4c:	0000174d 	.word	0x0000174d
    1b50:	00000c7f 	.word	0x00000c7f
    1b54:	00000c39 	.word	0x00000c39

00001b58 <xTaskResumeAll>:
{
    1b58:	b5f0      	push	{r4, r5, r6, r7, lr}
    1b5a:	b083      	sub	sp, #12
	configASSERT(uxSchedulerSuspended);
    1b5c:	4b31      	ldr	r3, [pc, #196]	; (1c24 <xTaskResumeAll+0xcc>)
    1b5e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    1b60:	2b00      	cmp	r3, #0
    1b62:	d101      	bne.n	1b68 <xTaskResumeAll+0x10>
    1b64:	b672      	cpsid	i
    1b66:	e7fe      	b.n	1b66 <xTaskResumeAll+0xe>
	taskENTER_CRITICAL();
    1b68:	4b2f      	ldr	r3, [pc, #188]	; (1c28 <xTaskResumeAll+0xd0>)
    1b6a:	4798      	blx	r3
		--uxSchedulerSuspended;
    1b6c:	4b2d      	ldr	r3, [pc, #180]	; (1c24 <xTaskResumeAll+0xcc>)
    1b6e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    1b70:	3a01      	subs	r2, #1
    1b72:	659a      	str	r2, [r3, #88]	; 0x58
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    1b74:	6d9b      	ldr	r3, [r3, #88]	; 0x58
	BaseType_t xAlreadyYielded = pdFALSE;
    1b76:	2400      	movs	r4, #0
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    1b78:	2b00      	cmp	r3, #0
    1b7a:	d104      	bne.n	1b86 <xTaskResumeAll+0x2e>
			if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
    1b7c:	4b29      	ldr	r3, [pc, #164]	; (1c24 <xTaskResumeAll+0xcc>)
    1b7e:	6a1b      	ldr	r3, [r3, #32]
    1b80:	2500      	movs	r5, #0
    1b82:	2b00      	cmp	r3, #0
    1b84:	d104      	bne.n	1b90 <xTaskResumeAll+0x38>
	taskEXIT_CRITICAL();
    1b86:	4b29      	ldr	r3, [pc, #164]	; (1c2c <xTaskResumeAll+0xd4>)
    1b88:	4798      	blx	r3
}
    1b8a:	0020      	movs	r0, r4
    1b8c:	b003      	add	sp, #12
    1b8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
    1b90:	4f27      	ldr	r7, [pc, #156]	; (1c30 <xTaskResumeAll+0xd8>)
					prvAddTaskToReadyList(pxTCB);
    1b92:	003e      	movs	r6, r7
    1b94:	3630      	adds	r6, #48	; 0x30
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
    1b96:	697b      	ldr	r3, [r7, #20]
    1b98:	2b00      	cmp	r3, #0
    1b9a:	d022      	beq.n	1be2 <xTaskResumeAll+0x8a>
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
    1b9c:	4b24      	ldr	r3, [pc, #144]	; (1c30 <xTaskResumeAll+0xd8>)
    1b9e:	6a1b      	ldr	r3, [r3, #32]
    1ba0:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xEventListItem));
    1ba2:	0028      	movs	r0, r5
    1ba4:	3018      	adds	r0, #24
    1ba6:	4c23      	ldr	r4, [pc, #140]	; (1c34 <xTaskResumeAll+0xdc>)
    1ba8:	47a0      	blx	r4
					(void)uxListRemove(&(pxTCB->xStateListItem));
    1baa:	1d2b      	adds	r3, r5, #4
    1bac:	9301      	str	r3, [sp, #4]
    1bae:	0018      	movs	r0, r3
    1bb0:	47a0      	blx	r4
					prvAddTaskToReadyList(pxTCB);
    1bb2:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    1bb4:	4a1b      	ldr	r2, [pc, #108]	; (1c24 <xTaskResumeAll+0xcc>)
    1bb6:	6d52      	ldr	r2, [r2, #84]	; 0x54
    1bb8:	4293      	cmp	r3, r2
    1bba:	d901      	bls.n	1bc0 <xTaskResumeAll+0x68>
    1bbc:	4a19      	ldr	r2, [pc, #100]	; (1c24 <xTaskResumeAll+0xcc>)
    1bbe:	6553      	str	r3, [r2, #84]	; 0x54
    1bc0:	0098      	lsls	r0, r3, #2
    1bc2:	18c0      	adds	r0, r0, r3
    1bc4:	0080      	lsls	r0, r0, #2
    1bc6:	1830      	adds	r0, r6, r0
    1bc8:	9901      	ldr	r1, [sp, #4]
    1bca:	4b1b      	ldr	r3, [pc, #108]	; (1c38 <xTaskResumeAll+0xe0>)
    1bcc:	4798      	blx	r3
					if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    1bce:	4b15      	ldr	r3, [pc, #84]	; (1c24 <xTaskResumeAll+0xcc>)
    1bd0:	699b      	ldr	r3, [r3, #24]
    1bd2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1bd4:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    1bd6:	429a      	cmp	r2, r3
    1bd8:	d3dd      	bcc.n	1b96 <xTaskResumeAll+0x3e>
						xYieldPending = pdTRUE;
    1bda:	2201      	movs	r2, #1
    1bdc:	4b11      	ldr	r3, [pc, #68]	; (1c24 <xTaskResumeAll+0xcc>)
    1bde:	669a      	str	r2, [r3, #104]	; 0x68
    1be0:	e7d9      	b.n	1b96 <xTaskResumeAll+0x3e>
				if (pxTCB != NULL) {
    1be2:	2d00      	cmp	r5, #0
    1be4:	d001      	beq.n	1bea <xTaskResumeAll+0x92>
					prvResetNextTaskUnblockTime();
    1be6:	4b15      	ldr	r3, [pc, #84]	; (1c3c <xTaskResumeAll+0xe4>)
    1be8:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    1bea:	4b0e      	ldr	r3, [pc, #56]	; (1c24 <xTaskResumeAll+0xcc>)
    1bec:	6e5c      	ldr	r4, [r3, #100]	; 0x64
					if (uxPendedCounts > (UBaseType_t)0U) {
    1bee:	2c00      	cmp	r4, #0
    1bf0:	d00e      	beq.n	1c10 <xTaskResumeAll+0xb8>
							if (xTaskIncrementTick() != pdFALSE) {
    1bf2:	4f13      	ldr	r7, [pc, #76]	; (1c40 <xTaskResumeAll+0xe8>)
								xYieldPending = pdTRUE;
    1bf4:	001e      	movs	r6, r3
    1bf6:	2501      	movs	r5, #1
    1bf8:	e002      	b.n	1c00 <xTaskResumeAll+0xa8>
							--uxPendedCounts;
    1bfa:	3c01      	subs	r4, #1
						} while (uxPendedCounts > (UBaseType_t)0U);
    1bfc:	2c00      	cmp	r4, #0
    1bfe:	d004      	beq.n	1c0a <xTaskResumeAll+0xb2>
							if (xTaskIncrementTick() != pdFALSE) {
    1c00:	47b8      	blx	r7
    1c02:	2800      	cmp	r0, #0
    1c04:	d0f9      	beq.n	1bfa <xTaskResumeAll+0xa2>
								xYieldPending = pdTRUE;
    1c06:	66b5      	str	r5, [r6, #104]	; 0x68
    1c08:	e7f7      	b.n	1bfa <xTaskResumeAll+0xa2>
						uxPendedTicks = 0;
    1c0a:	2200      	movs	r2, #0
    1c0c:	4b05      	ldr	r3, [pc, #20]	; (1c24 <xTaskResumeAll+0xcc>)
    1c0e:	665a      	str	r2, [r3, #100]	; 0x64
				if (xYieldPending != pdFALSE) {
    1c10:	4b04      	ldr	r3, [pc, #16]	; (1c24 <xTaskResumeAll+0xcc>)
    1c12:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	BaseType_t xAlreadyYielded = pdFALSE;
    1c14:	2400      	movs	r4, #0
				if (xYieldPending != pdFALSE) {
    1c16:	2b00      	cmp	r3, #0
    1c18:	d0b5      	beq.n	1b86 <xTaskResumeAll+0x2e>
					taskYIELD_IF_USING_PREEMPTION();
    1c1a:	4b0a      	ldr	r3, [pc, #40]	; (1c44 <xTaskResumeAll+0xec>)
    1c1c:	4798      	blx	r3
						xAlreadyYielded = pdTRUE;
    1c1e:	3401      	adds	r4, #1
    1c20:	e7b1      	b.n	1b86 <xTaskResumeAll+0x2e>
    1c22:	46c0      	nop			; (mov r8, r8)
    1c24:	20000a30 	.word	0x20000a30
    1c28:	00000da5 	.word	0x00000da5
    1c2c:	00000dbd 	.word	0x00000dbd
    1c30:	200009b0 	.word	0x200009b0
    1c34:	00000c7f 	.word	0x00000c7f
    1c38:	00000c39 	.word	0x00000c39
    1c3c:	0000174d 	.word	0x0000174d
    1c40:	00001a4d 	.word	0x00001a4d
    1c44:	00000d8d 	.word	0x00000d8d

00001c48 <vTaskDelay>:
{
    1c48:	b510      	push	{r4, lr}
    1c4a:	1e04      	subs	r4, r0, #0
	if (xTicksToDelay > (TickType_t)0U) {
    1c4c:	d00f      	beq.n	1c6e <vTaskDelay+0x26>
		configASSERT(uxSchedulerSuspended == 0);
    1c4e:	4b09      	ldr	r3, [pc, #36]	; (1c74 <vTaskDelay+0x2c>)
    1c50:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    1c52:	2b00      	cmp	r3, #0
    1c54:	d001      	beq.n	1c5a <vTaskDelay+0x12>
    1c56:	b672      	cpsid	i
    1c58:	e7fe      	b.n	1c58 <vTaskDelay+0x10>
		vTaskSuspendAll();
    1c5a:	4b07      	ldr	r3, [pc, #28]	; (1c78 <vTaskDelay+0x30>)
    1c5c:	4798      	blx	r3
			prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
    1c5e:	2100      	movs	r1, #0
    1c60:	0020      	movs	r0, r4
    1c62:	4b06      	ldr	r3, [pc, #24]	; (1c7c <vTaskDelay+0x34>)
    1c64:	4798      	blx	r3
		xAlreadyYielded = xTaskResumeAll();
    1c66:	4b06      	ldr	r3, [pc, #24]	; (1c80 <vTaskDelay+0x38>)
    1c68:	4798      	blx	r3
	if (xAlreadyYielded == pdFALSE) {
    1c6a:	2800      	cmp	r0, #0
    1c6c:	d101      	bne.n	1c72 <vTaskDelay+0x2a>
		portYIELD_WITHIN_API();
    1c6e:	4b05      	ldr	r3, [pc, #20]	; (1c84 <vTaskDelay+0x3c>)
    1c70:	4798      	blx	r3
}
    1c72:	bd10      	pop	{r4, pc}
    1c74:	20000a30 	.word	0x20000a30
    1c78:	00001a31 	.word	0x00001a31
    1c7c:	0000178d 	.word	0x0000178d
    1c80:	00001b59 	.word	0x00001b59
    1c84:	00000d8d 	.word	0x00000d8d

00001c88 <vTaskSwitchContext>:
{
    1c88:	b510      	push	{r4, lr}
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
    1c8a:	4b20      	ldr	r3, [pc, #128]	; (1d0c <vTaskSwitchContext+0x84>)
    1c8c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    1c8e:	2b00      	cmp	r3, #0
    1c90:	d119      	bne.n	1cc6 <vTaskSwitchContext+0x3e>
		xYieldPending = pdFALSE;
    1c92:	4b1e      	ldr	r3, [pc, #120]	; (1d0c <vTaskSwitchContext+0x84>)
    1c94:	2200      	movs	r2, #0
    1c96:	669a      	str	r2, [r3, #104]	; 0x68
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1c98:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    1c9a:	009a      	lsls	r2, r3, #2
    1c9c:	18d2      	adds	r2, r2, r3
    1c9e:	0092      	lsls	r2, r2, #2
    1ca0:	491b      	ldr	r1, [pc, #108]	; (1d10 <vTaskSwitchContext+0x88>)
    1ca2:	188a      	adds	r2, r1, r2
    1ca4:	6b12      	ldr	r2, [r2, #48]	; 0x30
    1ca6:	2a00      	cmp	r2, #0
    1ca8:	d111      	bne.n	1cce <vTaskSwitchContext+0x46>
    1caa:	2b00      	cmp	r3, #0
    1cac:	d009      	beq.n	1cc2 <vTaskSwitchContext+0x3a>
    1cae:	3b01      	subs	r3, #1
    1cb0:	009a      	lsls	r2, r3, #2
    1cb2:	18d2      	adds	r2, r2, r3
    1cb4:	0092      	lsls	r2, r2, #2
    1cb6:	188a      	adds	r2, r1, r2
    1cb8:	6b12      	ldr	r2, [r2, #48]	; 0x30
    1cba:	2a00      	cmp	r2, #0
    1cbc:	d107      	bne.n	1cce <vTaskSwitchContext+0x46>
    1cbe:	2b00      	cmp	r3, #0
    1cc0:	d1f5      	bne.n	1cae <vTaskSwitchContext+0x26>
    1cc2:	b672      	cpsid	i
    1cc4:	e7fe      	b.n	1cc4 <vTaskSwitchContext+0x3c>
		xYieldPending = pdTRUE;
    1cc6:	2201      	movs	r2, #1
    1cc8:	4b10      	ldr	r3, [pc, #64]	; (1d0c <vTaskSwitchContext+0x84>)
    1cca:	669a      	str	r2, [r3, #104]	; 0x68
}
    1ccc:	bd10      	pop	{r4, pc}
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1cce:	4a10      	ldr	r2, [pc, #64]	; (1d10 <vTaskSwitchContext+0x88>)
    1cd0:	0099      	lsls	r1, r3, #2
    1cd2:	18c8      	adds	r0, r1, r3
    1cd4:	0080      	lsls	r0, r0, #2
    1cd6:	1810      	adds	r0, r2, r0
    1cd8:	6b44      	ldr	r4, [r0, #52]	; 0x34
    1cda:	6864      	ldr	r4, [r4, #4]
    1cdc:	6344      	str	r4, [r0, #52]	; 0x34
    1cde:	18c9      	adds	r1, r1, r3
    1ce0:	0089      	lsls	r1, r1, #2
    1ce2:	0002      	movs	r2, r0
    1ce4:	3238      	adds	r2, #56	; 0x38
    1ce6:	4294      	cmp	r4, r2
    1ce8:	d00a      	beq.n	1d00 <vTaskSwitchContext+0x78>
    1cea:	009a      	lsls	r2, r3, #2
    1cec:	18d2      	adds	r2, r2, r3
    1cee:	0092      	lsls	r2, r2, #2
    1cf0:	4907      	ldr	r1, [pc, #28]	; (1d10 <vTaskSwitchContext+0x88>)
    1cf2:	188a      	adds	r2, r1, r2
    1cf4:	6b52      	ldr	r2, [r2, #52]	; 0x34
    1cf6:	68d1      	ldr	r1, [r2, #12]
    1cf8:	4a04      	ldr	r2, [pc, #16]	; (1d0c <vTaskSwitchContext+0x84>)
    1cfa:	6191      	str	r1, [r2, #24]
    1cfc:	6553      	str	r3, [r2, #84]	; 0x54
}
    1cfe:	e7e5      	b.n	1ccc <vTaskSwitchContext+0x44>
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1d00:	6860      	ldr	r0, [r4, #4]
    1d02:	000a      	movs	r2, r1
    1d04:	4902      	ldr	r1, [pc, #8]	; (1d10 <vTaskSwitchContext+0x88>)
    1d06:	188a      	adds	r2, r1, r2
    1d08:	6350      	str	r0, [r2, #52]	; 0x34
    1d0a:	e7ee      	b.n	1cea <vTaskSwitchContext+0x62>
    1d0c:	20000a30 	.word	0x20000a30
    1d10:	200009b0 	.word	0x200009b0

00001d14 <vTaskPlaceOnEventList>:
{
    1d14:	b510      	push	{r4, lr}
    1d16:	000c      	movs	r4, r1
	configASSERT(pxEventList);
    1d18:	2800      	cmp	r0, #0
    1d1a:	d101      	bne.n	1d20 <vTaskPlaceOnEventList+0xc>
    1d1c:	b672      	cpsid	i
    1d1e:	e7fe      	b.n	1d1e <vTaskPlaceOnEventList+0xa>
	vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
    1d20:	4b04      	ldr	r3, [pc, #16]	; (1d34 <vTaskPlaceOnEventList+0x20>)
    1d22:	6999      	ldr	r1, [r3, #24]
    1d24:	3118      	adds	r1, #24
    1d26:	4b04      	ldr	r3, [pc, #16]	; (1d38 <vTaskPlaceOnEventList+0x24>)
    1d28:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
    1d2a:	2101      	movs	r1, #1
    1d2c:	0020      	movs	r0, r4
    1d2e:	4b03      	ldr	r3, [pc, #12]	; (1d3c <vTaskPlaceOnEventList+0x28>)
    1d30:	4798      	blx	r3
}
    1d32:	bd10      	pop	{r4, pc}
    1d34:	20000a30 	.word	0x20000a30
    1d38:	00000c51 	.word	0x00000c51
    1d3c:	0000178d 	.word	0x0000178d

00001d40 <vTaskPlaceOnEventListRestricted>:
{
    1d40:	b570      	push	{r4, r5, r6, lr}
    1d42:	000c      	movs	r4, r1
    1d44:	0015      	movs	r5, r2
	configASSERT(pxEventList);
    1d46:	2800      	cmp	r0, #0
    1d48:	d00d      	beq.n	1d66 <vTaskPlaceOnEventListRestricted+0x26>
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
    1d4a:	4b08      	ldr	r3, [pc, #32]	; (1d6c <vTaskPlaceOnEventListRestricted+0x2c>)
    1d4c:	6999      	ldr	r1, [r3, #24]
    1d4e:	3118      	adds	r1, #24
    1d50:	4b07      	ldr	r3, [pc, #28]	; (1d70 <vTaskPlaceOnEventListRestricted+0x30>)
    1d52:	4798      	blx	r3
	if (xWaitIndefinitely != pdFALSE) {
    1d54:	2d00      	cmp	r5, #0
    1d56:	d001      	beq.n	1d5c <vTaskPlaceOnEventListRestricted+0x1c>
		xTicksToWait = portMAX_DELAY;
    1d58:	2401      	movs	r4, #1
    1d5a:	4264      	negs	r4, r4
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
    1d5c:	0029      	movs	r1, r5
    1d5e:	0020      	movs	r0, r4
    1d60:	4b04      	ldr	r3, [pc, #16]	; (1d74 <vTaskPlaceOnEventListRestricted+0x34>)
    1d62:	4798      	blx	r3
}
    1d64:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT(pxEventList);
    1d66:	b672      	cpsid	i
    1d68:	e7fe      	b.n	1d68 <vTaskPlaceOnEventListRestricted+0x28>
    1d6a:	46c0      	nop			; (mov r8, r8)
    1d6c:	20000a30 	.word	0x20000a30
    1d70:	00000c39 	.word	0x00000c39
    1d74:	0000178d 	.word	0x0000178d

00001d78 <xTaskRemoveFromEventList>:
{
    1d78:	b570      	push	{r4, r5, r6, lr}
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
    1d7a:	68c3      	ldr	r3, [r0, #12]
    1d7c:	68dc      	ldr	r4, [r3, #12]
	configASSERT(pxUnblockedTCB);
    1d7e:	2c00      	cmp	r4, #0
    1d80:	d028      	beq.n	1dd4 <xTaskRemoveFromEventList+0x5c>
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
    1d82:	0025      	movs	r5, r4
    1d84:	3518      	adds	r5, #24
    1d86:	0028      	movs	r0, r5
    1d88:	4b16      	ldr	r3, [pc, #88]	; (1de4 <xTaskRemoveFromEventList+0x6c>)
    1d8a:	4798      	blx	r3
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    1d8c:	4b16      	ldr	r3, [pc, #88]	; (1de8 <xTaskRemoveFromEventList+0x70>)
    1d8e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    1d90:	2b00      	cmp	r3, #0
    1d92:	d121      	bne.n	1dd8 <xTaskRemoveFromEventList+0x60>
		(void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
    1d94:	1d25      	adds	r5, r4, #4
    1d96:	0028      	movs	r0, r5
    1d98:	4b12      	ldr	r3, [pc, #72]	; (1de4 <xTaskRemoveFromEventList+0x6c>)
    1d9a:	4798      	blx	r3
		prvAddTaskToReadyList(pxUnblockedTCB);
    1d9c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    1d9e:	4a12      	ldr	r2, [pc, #72]	; (1de8 <xTaskRemoveFromEventList+0x70>)
    1da0:	6d52      	ldr	r2, [r2, #84]	; 0x54
    1da2:	4293      	cmp	r3, r2
    1da4:	d901      	bls.n	1daa <xTaskRemoveFromEventList+0x32>
    1da6:	4a10      	ldr	r2, [pc, #64]	; (1de8 <xTaskRemoveFromEventList+0x70>)
    1da8:	6553      	str	r3, [r2, #84]	; 0x54
    1daa:	0098      	lsls	r0, r3, #2
    1dac:	18c3      	adds	r3, r0, r3
    1dae:	009b      	lsls	r3, r3, #2
    1db0:	480e      	ldr	r0, [pc, #56]	; (1dec <xTaskRemoveFromEventList+0x74>)
    1db2:	3030      	adds	r0, #48	; 0x30
    1db4:	18c0      	adds	r0, r0, r3
    1db6:	0029      	movs	r1, r5
    1db8:	4b0d      	ldr	r3, [pc, #52]	; (1df0 <xTaskRemoveFromEventList+0x78>)
    1dba:	4798      	blx	r3
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
    1dbc:	4b0a      	ldr	r3, [pc, #40]	; (1de8 <xTaskRemoveFromEventList+0x70>)
    1dbe:	699b      	ldr	r3, [r3, #24]
    1dc0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1dc2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
		xReturn = pdFALSE;
    1dc4:	2000      	movs	r0, #0
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
    1dc6:	429a      	cmp	r2, r3
    1dc8:	d903      	bls.n	1dd2 <xTaskRemoveFromEventList+0x5a>
		xYieldPending = pdTRUE;
    1dca:	2201      	movs	r2, #1
    1dcc:	4b06      	ldr	r3, [pc, #24]	; (1de8 <xTaskRemoveFromEventList+0x70>)
    1dce:	669a      	str	r2, [r3, #104]	; 0x68
		xReturn = pdTRUE;
    1dd0:	3001      	adds	r0, #1
}
    1dd2:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT(pxUnblockedTCB);
    1dd4:	b672      	cpsid	i
    1dd6:	e7fe      	b.n	1dd6 <xTaskRemoveFromEventList+0x5e>
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
    1dd8:	0029      	movs	r1, r5
    1dda:	4804      	ldr	r0, [pc, #16]	; (1dec <xTaskRemoveFromEventList+0x74>)
    1ddc:	3014      	adds	r0, #20
    1dde:	4b04      	ldr	r3, [pc, #16]	; (1df0 <xTaskRemoveFromEventList+0x78>)
    1de0:	4798      	blx	r3
    1de2:	e7eb      	b.n	1dbc <xTaskRemoveFromEventList+0x44>
    1de4:	00000c7f 	.word	0x00000c7f
    1de8:	20000a30 	.word	0x20000a30
    1dec:	200009b0 	.word	0x200009b0
    1df0:	00000c39 	.word	0x00000c39

00001df4 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
    1df4:	4b02      	ldr	r3, [pc, #8]	; (1e00 <vTaskInternalSetTimeOutState+0xc>)
    1df6:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    1df8:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    1dfa:	695b      	ldr	r3, [r3, #20]
    1dfc:	6043      	str	r3, [r0, #4]
}
    1dfe:	4770      	bx	lr
    1e00:	20000a30 	.word	0x20000a30

00001e04 <xTaskCheckForTimeOut>:
{
    1e04:	b570      	push	{r4, r5, r6, lr}
    1e06:	0006      	movs	r6, r0
    1e08:	000d      	movs	r5, r1
	configASSERT(pxTimeOut);
    1e0a:	2800      	cmp	r0, #0
    1e0c:	d01b      	beq.n	1e46 <xTaskCheckForTimeOut+0x42>
	configASSERT(pxTicksToWait);
    1e0e:	2900      	cmp	r1, #0
    1e10:	d01b      	beq.n	1e4a <xTaskCheckForTimeOut+0x46>
	taskENTER_CRITICAL();
    1e12:	4b13      	ldr	r3, [pc, #76]	; (1e60 <xTaskCheckForTimeOut+0x5c>)
    1e14:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
    1e16:	4b13      	ldr	r3, [pc, #76]	; (1e64 <xTaskCheckForTimeOut+0x60>)
    1e18:	695a      	ldr	r2, [r3, #20]
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1e1a:	6871      	ldr	r1, [r6, #4]
		    if (*pxTicksToWait == portMAX_DELAY) {
    1e1c:	682b      	ldr	r3, [r5, #0]
    1e1e:	1c58      	adds	r0, r3, #1
    1e20:	d01c      	beq.n	1e5c <xTaskCheckForTimeOut+0x58>
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
    1e22:	4810      	ldr	r0, [pc, #64]	; (1e64 <xTaskCheckForTimeOut+0x60>)
    1e24:	6e00      	ldr	r0, [r0, #96]	; 0x60
    1e26:	6834      	ldr	r4, [r6, #0]
    1e28:	4284      	cmp	r4, r0
    1e2a:	d002      	beq.n	1e32 <xTaskCheckForTimeOut+0x2e>
			xReturn = pdTRUE;
    1e2c:	2401      	movs	r4, #1
		        && (xConstTickCount >= pxTimeOut->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to make
    1e2e:	428a      	cmp	r2, r1
    1e30:	d205      	bcs.n	1e3e <xTaskCheckForTimeOut+0x3a>
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1e32:	1a52      	subs	r2, r2, r1
		} else if (xElapsedTime < *pxTicksToWait) /*lint !e961 Explicit casting is only redundant with some compilers,
    1e34:	429a      	cmp	r2, r3
    1e36:	d30a      	bcc.n	1e4e <xTaskCheckForTimeOut+0x4a>
			*pxTicksToWait = 0;
    1e38:	2300      	movs	r3, #0
    1e3a:	602b      	str	r3, [r5, #0]
			xReturn        = pdTRUE;
    1e3c:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
    1e3e:	4b0a      	ldr	r3, [pc, #40]	; (1e68 <xTaskCheckForTimeOut+0x64>)
    1e40:	4798      	blx	r3
}
    1e42:	0020      	movs	r0, r4
    1e44:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT(pxTimeOut);
    1e46:	b672      	cpsid	i
    1e48:	e7fe      	b.n	1e48 <xTaskCheckForTimeOut+0x44>
	configASSERT(pxTicksToWait);
    1e4a:	b672      	cpsid	i
    1e4c:	e7fe      	b.n	1e4c <xTaskCheckForTimeOut+0x48>
			*pxTicksToWait -= xElapsedTime;
    1e4e:	1a9b      	subs	r3, r3, r2
    1e50:	602b      	str	r3, [r5, #0]
			vTaskInternalSetTimeOutState(pxTimeOut);
    1e52:	0030      	movs	r0, r6
    1e54:	4b05      	ldr	r3, [pc, #20]	; (1e6c <xTaskCheckForTimeOut+0x68>)
    1e56:	4798      	blx	r3
			xReturn = pdFALSE;
    1e58:	2400      	movs	r4, #0
    1e5a:	e7f0      	b.n	1e3e <xTaskCheckForTimeOut+0x3a>
			xReturn = pdFALSE;
    1e5c:	2400      	movs	r4, #0
    1e5e:	e7ee      	b.n	1e3e <xTaskCheckForTimeOut+0x3a>
    1e60:	00000da5 	.word	0x00000da5
    1e64:	20000a30 	.word	0x20000a30
    1e68:	00000dbd 	.word	0x00000dbd
    1e6c:	00001df5 	.word	0x00001df5

00001e70 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    1e70:	2201      	movs	r2, #1
    1e72:	4b01      	ldr	r3, [pc, #4]	; (1e78 <vTaskMissedYield+0x8>)
    1e74:	669a      	str	r2, [r3, #104]	; 0x68
}
    1e76:	4770      	bx	lr
    1e78:	20000a30 	.word	0x20000a30

00001e7c <xTaskGetSchedulerState>:
	if (xSchedulerRunning == pdFALSE) {
    1e7c:	4b05      	ldr	r3, [pc, #20]	; (1e94 <xTaskGetSchedulerState+0x18>)
    1e7e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
		xReturn = taskSCHEDULER_NOT_STARTED;
    1e80:	2001      	movs	r0, #1
	if (xSchedulerRunning == pdFALSE) {
    1e82:	2b00      	cmp	r3, #0
    1e84:	d004      	beq.n	1e90 <xTaskGetSchedulerState+0x14>
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    1e86:	4b03      	ldr	r3, [pc, #12]	; (1e94 <xTaskGetSchedulerState+0x18>)
    1e88:	6d98      	ldr	r0, [r3, #88]	; 0x58
			xReturn = taskSCHEDULER_SUSPENDED;
    1e8a:	4243      	negs	r3, r0
    1e8c:	4158      	adcs	r0, r3
    1e8e:	0040      	lsls	r0, r0, #1
}
    1e90:	4770      	bx	lr
    1e92:	46c0      	nop			; (mov r8, r8)
    1e94:	20000a30 	.word	0x20000a30

00001e98 <xTaskPriorityInherit>:
{
    1e98:	b570      	push	{r4, r5, r6, lr}
    1e9a:	1e04      	subs	r4, r0, #0
	if (pxMutexHolder != NULL) {
    1e9c:	d03d      	beq.n	1f1a <xTaskPriorityInherit+0x82>
		if (pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority) {
    1e9e:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
    1ea0:	4b1f      	ldr	r3, [pc, #124]	; (1f20 <xTaskPriorityInherit+0x88>)
    1ea2:	699b      	ldr	r3, [r3, #24]
    1ea4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1ea6:	4299      	cmp	r1, r3
    1ea8:	d22f      	bcs.n	1f0a <xTaskPriorityInherit+0x72>
			if ((listGET_LIST_ITEM_VALUE(&(pxMutexHolderTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE)
    1eaa:	6983      	ldr	r3, [r0, #24]
    1eac:	2b00      	cmp	r3, #0
    1eae:	db05      	blt.n	1ebc <xTaskPriorityInherit+0x24>
				listSET_LIST_ITEM_VALUE(
    1eb0:	4b1b      	ldr	r3, [pc, #108]	; (1f20 <xTaskPriorityInherit+0x88>)
    1eb2:	699b      	ldr	r3, [r3, #24]
    1eb4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1eb6:	2305      	movs	r3, #5
    1eb8:	1a9b      	subs	r3, r3, r2
    1eba:	6183      	str	r3, [r0, #24]
			if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[pxMutexHolderTCB->uxPriority]),
    1ebc:	008b      	lsls	r3, r1, #2
    1ebe:	1859      	adds	r1, r3, r1
    1ec0:	0089      	lsls	r1, r1, #2
    1ec2:	4b18      	ldr	r3, [pc, #96]	; (1f24 <xTaskPriorityInherit+0x8c>)
    1ec4:	3330      	adds	r3, #48	; 0x30
    1ec6:	185b      	adds	r3, r3, r1
    1ec8:	6962      	ldr	r2, [r4, #20]
    1eca:	429a      	cmp	r2, r3
    1ecc:	d005      	beq.n	1eda <xTaskPriorityInherit+0x42>
				pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    1ece:	4b14      	ldr	r3, [pc, #80]	; (1f20 <xTaskPriorityInherit+0x88>)
    1ed0:	699b      	ldr	r3, [r3, #24]
    1ed2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1ed4:	62e3      	str	r3, [r4, #44]	; 0x2c
			xReturn = pdTRUE;
    1ed6:	2001      	movs	r0, #1
    1ed8:	e01e      	b.n	1f18 <xTaskPriorityInherit+0x80>
				if (uxListRemove(&(pxMutexHolderTCB->xStateListItem)) == (UBaseType_t)0) {
    1eda:	1d25      	adds	r5, r4, #4
    1edc:	0028      	movs	r0, r5
    1ede:	4b12      	ldr	r3, [pc, #72]	; (1f28 <xTaskPriorityInherit+0x90>)
    1ee0:	4798      	blx	r3
				pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    1ee2:	4b0f      	ldr	r3, [pc, #60]	; (1f20 <xTaskPriorityInherit+0x88>)
    1ee4:	699a      	ldr	r2, [r3, #24]
    1ee6:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    1ee8:	62e2      	str	r2, [r4, #44]	; 0x2c
				prvAddTaskToReadyList(pxMutexHolderTCB);
    1eea:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    1eec:	429a      	cmp	r2, r3
    1eee:	d901      	bls.n	1ef4 <xTaskPriorityInherit+0x5c>
    1ef0:	4b0b      	ldr	r3, [pc, #44]	; (1f20 <xTaskPriorityInherit+0x88>)
    1ef2:	655a      	str	r2, [r3, #84]	; 0x54
    1ef4:	0090      	lsls	r0, r2, #2
    1ef6:	1882      	adds	r2, r0, r2
    1ef8:	0092      	lsls	r2, r2, #2
    1efa:	480a      	ldr	r0, [pc, #40]	; (1f24 <xTaskPriorityInherit+0x8c>)
    1efc:	3030      	adds	r0, #48	; 0x30
    1efe:	1880      	adds	r0, r0, r2
    1f00:	0029      	movs	r1, r5
    1f02:	4b0a      	ldr	r3, [pc, #40]	; (1f2c <xTaskPriorityInherit+0x94>)
    1f04:	4798      	blx	r3
			xReturn = pdTRUE;
    1f06:	2001      	movs	r0, #1
    1f08:	e006      	b.n	1f18 <xTaskPriorityInherit+0x80>
			if (pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority) {
    1f0a:	4b05      	ldr	r3, [pc, #20]	; (1f20 <xTaskPriorityInherit+0x88>)
    1f0c:	699b      	ldr	r3, [r3, #24]
    1f0e:	6c40      	ldr	r0, [r0, #68]	; 0x44
    1f10:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1f12:	4298      	cmp	r0, r3
    1f14:	4180      	sbcs	r0, r0
    1f16:	4240      	negs	r0, r0
}
    1f18:	bd70      	pop	{r4, r5, r6, pc}
	BaseType_t   xReturn          = pdFALSE;
    1f1a:	2000      	movs	r0, #0
	return xReturn;
    1f1c:	e7fc      	b.n	1f18 <xTaskPriorityInherit+0x80>
    1f1e:	46c0      	nop			; (mov r8, r8)
    1f20:	20000a30 	.word	0x20000a30
    1f24:	200009b0 	.word	0x200009b0
    1f28:	00000c7f 	.word	0x00000c7f
    1f2c:	00000c39 	.word	0x00000c39

00001f30 <xTaskPriorityDisinherit>:
{
    1f30:	b570      	push	{r4, r5, r6, lr}
    1f32:	1e04      	subs	r4, r0, #0
	if (pxMutexHolder != NULL) {
    1f34:	d02d      	beq.n	1f92 <xTaskPriorityDisinherit+0x62>
		configASSERT(pxTCB == pxCurrentTCB);
    1f36:	4b19      	ldr	r3, [pc, #100]	; (1f9c <xTaskPriorityDisinherit+0x6c>)
    1f38:	699b      	ldr	r3, [r3, #24]
    1f3a:	4298      	cmp	r0, r3
    1f3c:	d001      	beq.n	1f42 <xTaskPriorityDisinherit+0x12>
    1f3e:	b672      	cpsid	i
    1f40:	e7fe      	b.n	1f40 <xTaskPriorityDisinherit+0x10>
		configASSERT(pxTCB->uxMutexesHeld);
    1f42:	6c83      	ldr	r3, [r0, #72]	; 0x48
    1f44:	2b00      	cmp	r3, #0
    1f46:	d101      	bne.n	1f4c <xTaskPriorityDisinherit+0x1c>
    1f48:	b672      	cpsid	i
    1f4a:	e7fe      	b.n	1f4a <xTaskPriorityDisinherit+0x1a>
		(pxTCB->uxMutexesHeld)--;
    1f4c:	3b01      	subs	r3, #1
    1f4e:	6483      	str	r3, [r0, #72]	; 0x48
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
    1f50:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    1f52:	6c41      	ldr	r1, [r0, #68]	; 0x44
    1f54:	428a      	cmp	r2, r1
    1f56:	d01e      	beq.n	1f96 <xTaskPriorityDisinherit+0x66>
	BaseType_t   xReturn = pdFALSE;
    1f58:	2000      	movs	r0, #0
			if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
    1f5a:	2b00      	cmp	r3, #0
    1f5c:	d118      	bne.n	1f90 <xTaskPriorityDisinherit+0x60>
				if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
    1f5e:	1d25      	adds	r5, r4, #4
    1f60:	0028      	movs	r0, r5
    1f62:	4b0f      	ldr	r3, [pc, #60]	; (1fa0 <xTaskPriorityDisinherit+0x70>)
    1f64:	4798      	blx	r3
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    1f66:	6c63      	ldr	r3, [r4, #68]	; 0x44
    1f68:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE(
    1f6a:	2205      	movs	r2, #5
    1f6c:	1ad2      	subs	r2, r2, r3
    1f6e:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyList(pxTCB);
    1f70:	4a0a      	ldr	r2, [pc, #40]	; (1f9c <xTaskPriorityDisinherit+0x6c>)
    1f72:	6d52      	ldr	r2, [r2, #84]	; 0x54
    1f74:	4293      	cmp	r3, r2
    1f76:	d901      	bls.n	1f7c <xTaskPriorityDisinherit+0x4c>
    1f78:	4a08      	ldr	r2, [pc, #32]	; (1f9c <xTaskPriorityDisinherit+0x6c>)
    1f7a:	6553      	str	r3, [r2, #84]	; 0x54
    1f7c:	0098      	lsls	r0, r3, #2
    1f7e:	18c3      	adds	r3, r0, r3
    1f80:	009b      	lsls	r3, r3, #2
    1f82:	4808      	ldr	r0, [pc, #32]	; (1fa4 <xTaskPriorityDisinherit+0x74>)
    1f84:	3030      	adds	r0, #48	; 0x30
    1f86:	18c0      	adds	r0, r0, r3
    1f88:	0029      	movs	r1, r5
    1f8a:	4b07      	ldr	r3, [pc, #28]	; (1fa8 <xTaskPriorityDisinherit+0x78>)
    1f8c:	4798      	blx	r3
				xReturn = pdTRUE;
    1f8e:	2001      	movs	r0, #1
}
    1f90:	bd70      	pop	{r4, r5, r6, pc}
	BaseType_t   xReturn = pdFALSE;
    1f92:	2000      	movs	r0, #0
    1f94:	e7fc      	b.n	1f90 <xTaskPriorityDisinherit+0x60>
    1f96:	2000      	movs	r0, #0
    1f98:	e7fa      	b.n	1f90 <xTaskPriorityDisinherit+0x60>
    1f9a:	46c0      	nop			; (mov r8, r8)
    1f9c:	20000a30 	.word	0x20000a30
    1fa0:	00000c7f 	.word	0x00000c7f
    1fa4:	200009b0 	.word	0x200009b0
    1fa8:	00000c39 	.word	0x00000c39

00001fac <vTaskPriorityDisinheritAfterTimeout>:
{
    1fac:	b570      	push	{r4, r5, r6, lr}
    1fae:	1e04      	subs	r4, r0, #0
	if (pxMutexHolder != NULL) {
    1fb0:	d00d      	beq.n	1fce <vTaskPriorityDisinheritAfterTimeout+0x22>
		configASSERT(pxTCB->uxMutexesHeld);
    1fb2:	6c83      	ldr	r3, [r0, #72]	; 0x48
    1fb4:	2b00      	cmp	r3, #0
    1fb6:	d101      	bne.n	1fbc <vTaskPriorityDisinheritAfterTimeout+0x10>
    1fb8:	b672      	cpsid	i
    1fba:	e7fe      	b.n	1fba <vTaskPriorityDisinheritAfterTimeout+0xe>
    1fbc:	6c40      	ldr	r0, [r0, #68]	; 0x44
    1fbe:	4288      	cmp	r0, r1
    1fc0:	d200      	bcs.n	1fc4 <vTaskPriorityDisinheritAfterTimeout+0x18>
    1fc2:	0008      	movs	r0, r1
		if (pxTCB->uxPriority != uxPriorityToUse) {
    1fc4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1fc6:	4282      	cmp	r2, r0
    1fc8:	d001      	beq.n	1fce <vTaskPriorityDisinheritAfterTimeout+0x22>
			if (pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld) {
    1fca:	2b01      	cmp	r3, #1
    1fcc:	d000      	beq.n	1fd0 <vTaskPriorityDisinheritAfterTimeout+0x24>
}
    1fce:	bd70      	pop	{r4, r5, r6, pc}
				configASSERT(pxTCB != pxCurrentTCB);
    1fd0:	4b15      	ldr	r3, [pc, #84]	; (2028 <STACK_SIZE+0x28>)
    1fd2:	699b      	ldr	r3, [r3, #24]
    1fd4:	429c      	cmp	r4, r3
    1fd6:	d101      	bne.n	1fdc <vTaskPriorityDisinheritAfterTimeout+0x30>
    1fd8:	b672      	cpsid	i
    1fda:	e7fe      	b.n	1fda <vTaskPriorityDisinheritAfterTimeout+0x2e>
				pxTCB->uxPriority     = uxPriorityToUse;
    1fdc:	62e0      	str	r0, [r4, #44]	; 0x2c
				if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL) {
    1fde:	69a3      	ldr	r3, [r4, #24]
    1fe0:	2b00      	cmp	r3, #0
    1fe2:	db02      	blt.n	1fea <vTaskPriorityDisinheritAfterTimeout+0x3e>
					listSET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem),
    1fe4:	2305      	movs	r3, #5
    1fe6:	1a18      	subs	r0, r3, r0
    1fe8:	61a0      	str	r0, [r4, #24]
				if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[uxPriorityUsedOnEntry]), &(pxTCB->xStateListItem))
    1fea:	0093      	lsls	r3, r2, #2
    1fec:	189a      	adds	r2, r3, r2
    1fee:	0092      	lsls	r2, r2, #2
    1ff0:	4b0e      	ldr	r3, [pc, #56]	; (202c <STACK_SIZE+0x2c>)
    1ff2:	3330      	adds	r3, #48	; 0x30
    1ff4:	189b      	adds	r3, r3, r2
    1ff6:	6962      	ldr	r2, [r4, #20]
    1ff8:	429a      	cmp	r2, r3
    1ffa:	d1e8      	bne.n	1fce <vTaskPriorityDisinheritAfterTimeout+0x22>
					if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
    1ffc:	1d25      	adds	r5, r4, #4
    1ffe:	0028      	movs	r0, r5
    2000:	4b0b      	ldr	r3, [pc, #44]	; (2030 <STACK_SIZE+0x30>)
    2002:	4798      	blx	r3
					prvAddTaskToReadyList(pxTCB);
    2004:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2006:	4a08      	ldr	r2, [pc, #32]	; (2028 <STACK_SIZE+0x28>)
    2008:	6d52      	ldr	r2, [r2, #84]	; 0x54
    200a:	4293      	cmp	r3, r2
    200c:	d901      	bls.n	2012 <STACK_SIZE+0x12>
    200e:	4a06      	ldr	r2, [pc, #24]	; (2028 <STACK_SIZE+0x28>)
    2010:	6553      	str	r3, [r2, #84]	; 0x54
    2012:	0098      	lsls	r0, r3, #2
    2014:	18c3      	adds	r3, r0, r3
    2016:	009b      	lsls	r3, r3, #2
    2018:	4804      	ldr	r0, [pc, #16]	; (202c <STACK_SIZE+0x2c>)
    201a:	3030      	adds	r0, #48	; 0x30
    201c:	18c0      	adds	r0, r0, r3
    201e:	0029      	movs	r1, r5
    2020:	4b04      	ldr	r3, [pc, #16]	; (2034 <STACK_SIZE+0x34>)
    2022:	4798      	blx	r3
}
    2024:	e7d3      	b.n	1fce <vTaskPriorityDisinheritAfterTimeout+0x22>
    2026:	46c0      	nop			; (mov r8, r8)
    2028:	20000a30 	.word	0x20000a30
    202c:	200009b0 	.word	0x200009b0
    2030:	00000c7f 	.word	0x00000c7f
    2034:	00000c39 	.word	0x00000c39

00002038 <pvTaskIncrementMutexHeldCount>:
	if (pxCurrentTCB != NULL) {
    2038:	4b05      	ldr	r3, [pc, #20]	; (2050 <pvTaskIncrementMutexHeldCount+0x18>)
    203a:	699b      	ldr	r3, [r3, #24]
    203c:	2b00      	cmp	r3, #0
    203e:	d004      	beq.n	204a <pvTaskIncrementMutexHeldCount+0x12>
		(pxCurrentTCB->uxMutexesHeld)++;
    2040:	4b03      	ldr	r3, [pc, #12]	; (2050 <pvTaskIncrementMutexHeldCount+0x18>)
    2042:	699a      	ldr	r2, [r3, #24]
    2044:	6c93      	ldr	r3, [r2, #72]	; 0x48
    2046:	3301      	adds	r3, #1
    2048:	6493      	str	r3, [r2, #72]	; 0x48
	return pxCurrentTCB;
    204a:	4b01      	ldr	r3, [pc, #4]	; (2050 <pvTaskIncrementMutexHeldCount+0x18>)
    204c:	6998      	ldr	r0, [r3, #24]
}
    204e:	4770      	bx	lr
    2050:	20000a30 	.word	0x20000a30

00002054 <prvInsertTimerInActiveList>:
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList(Timer_t *const pxTimer, const TickType_t xNextExpiryTime,
                                             const TickType_t xTimeNow, const TickType_t xCommandTime)
{
    2054:	b510      	push	{r4, lr}
	BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
    2056:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    2058:	6100      	str	r0, [r0, #16]

	if (xNextExpiryTime <= xTimeNow) {
    205a:	4291      	cmp	r1, r2
    205c:	d80b      	bhi.n	2076 <prvInsertTimerInActiveList+0x22>
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if (((TickType_t)(xTimeNow - xCommandTime))
    205e:	1ad2      	subs	r2, r2, r3
		    >= pxTimer->xTimerPeriodInTicks) /*lint !e961 MISRA exception as the casts are only redundant for some
		                                        ports. */
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    2060:	2401      	movs	r4, #1
		if (((TickType_t)(xTimeNow - xCommandTime))
    2062:	6983      	ldr	r3, [r0, #24]
    2064:	429a      	cmp	r2, r3
    2066:	d211      	bcs.n	208c <prvInsertTimerInActiveList+0x38>
		} else {
			vListInsert(pxOverflowTimerList, &(pxTimer->xTimerListItem));
    2068:	1d01      	adds	r1, r0, #4
    206a:	4b09      	ldr	r3, [pc, #36]	; (2090 <prvInsertTimerInActiveList+0x3c>)
    206c:	6818      	ldr	r0, [r3, #0]
    206e:	4b09      	ldr	r3, [pc, #36]	; (2094 <prvInsertTimerInActiveList+0x40>)
    2070:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    2072:	2400      	movs	r4, #0
    2074:	e00a      	b.n	208c <prvInsertTimerInActiveList+0x38>
		}
	} else {
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
    2076:	429a      	cmp	r2, r3
    2078:	d202      	bcs.n	2080 <prvInsertTimerInActiveList+0x2c>
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    207a:	2401      	movs	r4, #1
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
    207c:	4299      	cmp	r1, r3
    207e:	d205      	bcs.n	208c <prvInsertTimerInActiveList+0x38>
		} else {
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    2080:	1d01      	adds	r1, r0, #4
    2082:	4b03      	ldr	r3, [pc, #12]	; (2090 <prvInsertTimerInActiveList+0x3c>)
    2084:	6858      	ldr	r0, [r3, #4]
    2086:	4b03      	ldr	r3, [pc, #12]	; (2094 <prvInsertTimerInActiveList+0x40>)
    2088:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    208a:	2400      	movs	r4, #0
		}
	}

	return xProcessTimerNow;
}
    208c:	0020      	movs	r0, r4
    208e:	bd10      	pop	{r4, pc}
    2090:	20000a9c 	.word	0x20000a9c
    2094:	00000c51 	.word	0x00000c51

00002098 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue(void)
{
    2098:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    209a:	4b0e      	ldr	r3, [pc, #56]	; (20d4 <prvCheckForValidListAndQueue+0x3c>)
    209c:	4798      	blx	r3
	{
		if (xTimerQueue == NULL) {
    209e:	4b0e      	ldr	r3, [pc, #56]	; (20d8 <prvCheckForValidListAndQueue+0x40>)
    20a0:	689b      	ldr	r3, [r3, #8]
    20a2:	2b00      	cmp	r3, #0
    20a4:	d002      	beq.n	20ac <prvCheckForValidListAndQueue+0x14>
#endif /* configQUEUE_REGISTRY_SIZE */
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    20a6:	4b0d      	ldr	r3, [pc, #52]	; (20dc <prvCheckForValidListAndQueue+0x44>)
    20a8:	4798      	blx	r3
}
    20aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			vListInitialise(&xActiveTimerList1);
    20ac:	4c0a      	ldr	r4, [pc, #40]	; (20d8 <prvCheckForValidListAndQueue+0x40>)
    20ae:	0026      	movs	r6, r4
    20b0:	360c      	adds	r6, #12
    20b2:	0030      	movs	r0, r6
    20b4:	4f0a      	ldr	r7, [pc, #40]	; (20e0 <prvCheckForValidListAndQueue+0x48>)
    20b6:	47b8      	blx	r7
			vListInitialise(&xActiveTimerList2);
    20b8:	0025      	movs	r5, r4
    20ba:	3520      	adds	r5, #32
    20bc:	0028      	movs	r0, r5
    20be:	47b8      	blx	r7
			pxCurrentTimerList  = &xActiveTimerList1;
    20c0:	6066      	str	r6, [r4, #4]
			pxOverflowTimerList = &xActiveTimerList2;
    20c2:	6025      	str	r5, [r4, #0]
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    20c4:	2200      	movs	r2, #0
    20c6:	210c      	movs	r1, #12
    20c8:	2002      	movs	r0, #2
    20ca:	4b06      	ldr	r3, [pc, #24]	; (20e4 <prvCheckForValidListAndQueue+0x4c>)
    20cc:	4798      	blx	r3
    20ce:	60a0      	str	r0, [r4, #8]
    20d0:	e7e9      	b.n	20a6 <prvCheckForValidListAndQueue+0xe>
    20d2:	46c0      	nop			; (mov r8, r8)
    20d4:	00000da5 	.word	0x00000da5
    20d8:	20000a9c 	.word	0x20000a9c
    20dc:	00000dbd 	.word	0x00000dbd
    20e0:	00000c1d 	.word	0x00000c1d
    20e4:	0000112d 	.word	0x0000112d

000020e8 <xTimerCreateTimerTask>:
{
    20e8:	b510      	push	{r4, lr}
    20ea:	b082      	sub	sp, #8
	prvCheckForValidListAndQueue();
    20ec:	4b0b      	ldr	r3, [pc, #44]	; (211c <xTimerCreateTimerTask+0x34>)
    20ee:	4798      	blx	r3
	if (xTimerQueue != NULL) {
    20f0:	4b0b      	ldr	r3, [pc, #44]	; (2120 <xTimerCreateTimerTask+0x38>)
    20f2:	689b      	ldr	r3, [r3, #8]
    20f4:	2b00      	cmp	r3, #0
    20f6:	d00e      	beq.n	2116 <xTimerCreateTimerTask+0x2e>
			xReturn = xTaskCreate(prvTimerTask,
    20f8:	4b09      	ldr	r3, [pc, #36]	; (2120 <xTimerCreateTimerTask+0x38>)
    20fa:	3334      	adds	r3, #52	; 0x34
    20fc:	9301      	str	r3, [sp, #4]
    20fe:	2302      	movs	r3, #2
    2100:	9300      	str	r3, [sp, #0]
    2102:	2300      	movs	r3, #0
    2104:	2240      	movs	r2, #64	; 0x40
    2106:	4907      	ldr	r1, [pc, #28]	; (2124 <xTimerCreateTimerTask+0x3c>)
    2108:	4807      	ldr	r0, [pc, #28]	; (2128 <xTimerCreateTimerTask+0x40>)
    210a:	4c08      	ldr	r4, [pc, #32]	; (212c <xTimerCreateTimerTask+0x44>)
    210c:	47a0      	blx	r4
	configASSERT(xReturn);
    210e:	2800      	cmp	r0, #0
    2110:	d001      	beq.n	2116 <xTimerCreateTimerTask+0x2e>
}
    2112:	b002      	add	sp, #8
    2114:	bd10      	pop	{r4, pc}
	configASSERT(xReturn);
    2116:	b672      	cpsid	i
    2118:	e7fe      	b.n	2118 <xTimerCreateTimerTask+0x30>
    211a:	46c0      	nop			; (mov r8, r8)
    211c:	00002099 	.word	0x00002099
    2120:	20000a9c 	.word	0x20000a9c
    2124:	0000252c 	.word	0x0000252c
    2128:	0000224d 	.word	0x0000224d
    212c:	000017fd 	.word	0x000017fd

00002130 <xTimerGenericCommand>:
{
    2130:	b530      	push	{r4, r5, lr}
    2132:	b085      	sub	sp, #20
    2134:	0004      	movs	r4, r0
    2136:	001d      	movs	r5, r3
	configASSERT(xTimer);
    2138:	2800      	cmp	r0, #0
    213a:	d014      	beq.n	2166 <xTimerGenericCommand+0x36>
	if (xTimerQueue != NULL) {
    213c:	4b13      	ldr	r3, [pc, #76]	; (218c <xTimerGenericCommand+0x5c>)
    213e:	6898      	ldr	r0, [r3, #8]
    2140:	2800      	cmp	r0, #0
    2142:	d021      	beq.n	2188 <xTimerGenericCommand+0x58>
		xMessage.xMessageID                       = xCommandID;
    2144:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    2146:	9202      	str	r2, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer       = (Timer_t *)xTimer;
    2148:	9403      	str	r4, [sp, #12]
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    214a:	2905      	cmp	r1, #5
    214c:	dc15      	bgt.n	217a <xTimerGenericCommand+0x4a>
			if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
    214e:	4b10      	ldr	r3, [pc, #64]	; (2190 <xTimerGenericCommand+0x60>)
    2150:	4798      	blx	r3
    2152:	2802      	cmp	r0, #2
    2154:	d009      	beq.n	216a <xTimerGenericCommand+0x3a>
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, tmrNO_DELAY);
    2156:	4b0d      	ldr	r3, [pc, #52]	; (218c <xTimerGenericCommand+0x5c>)
    2158:	6898      	ldr	r0, [r3, #8]
    215a:	2300      	movs	r3, #0
    215c:	2200      	movs	r2, #0
    215e:	a901      	add	r1, sp, #4
    2160:	4c0c      	ldr	r4, [pc, #48]	; (2194 <xTimerGenericCommand+0x64>)
    2162:	47a0      	blx	r4
    2164:	e00e      	b.n	2184 <xTimerGenericCommand+0x54>
	configASSERT(xTimer);
    2166:	b672      	cpsid	i
    2168:	e7fe      	b.n	2168 <xTimerGenericCommand+0x38>
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, xTicksToWait);
    216a:	4b08      	ldr	r3, [pc, #32]	; (218c <xTimerGenericCommand+0x5c>)
    216c:	6898      	ldr	r0, [r3, #8]
    216e:	2300      	movs	r3, #0
    2170:	9a08      	ldr	r2, [sp, #32]
    2172:	a901      	add	r1, sp, #4
    2174:	4c07      	ldr	r4, [pc, #28]	; (2194 <xTimerGenericCommand+0x64>)
    2176:	47a0      	blx	r4
    2178:	e004      	b.n	2184 <xTimerGenericCommand+0x54>
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    217a:	2300      	movs	r3, #0
    217c:	002a      	movs	r2, r5
    217e:	a901      	add	r1, sp, #4
    2180:	4c05      	ldr	r4, [pc, #20]	; (2198 <xTimerGenericCommand+0x68>)
    2182:	47a0      	blx	r4
}
    2184:	b005      	add	sp, #20
    2186:	bd30      	pop	{r4, r5, pc}
	BaseType_t          xReturn = pdFAIL;
    2188:	2000      	movs	r0, #0
	return xReturn;
    218a:	e7fb      	b.n	2184 <xTimerGenericCommand+0x54>
    218c:	20000a9c 	.word	0x20000a9c
    2190:	00001e7d 	.word	0x00001e7d
    2194:	00001179 	.word	0x00001179
    2198:	00001331 	.word	0x00001331

0000219c <prvSampleTimeNow>:
{
    219c:	b5f0      	push	{r4, r5, r6, r7, lr}
    219e:	46d6      	mov	lr, sl
    21a0:	464f      	mov	r7, r9
    21a2:	4646      	mov	r6, r8
    21a4:	b5c0      	push	{r6, r7, lr}
    21a6:	b082      	sub	sp, #8
    21a8:	4680      	mov	r8, r0
	xTimeNow = xTaskGetTickCount();
    21aa:	4b23      	ldr	r3, [pc, #140]	; (2238 <prvSampleTimeNow+0x9c>)
    21ac:	4798      	blx	r3
    21ae:	4682      	mov	sl, r0
	if (xTimeNow < xLastTime) {
    21b0:	4b22      	ldr	r3, [pc, #136]	; (223c <prvSampleTimeNow+0xa0>)
    21b2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    21b4:	4298      	cmp	r0, r3
    21b6:	d317      	bcc.n	21e8 <prvSampleTimeNow+0x4c>
		*pxTimerListsWereSwitched = pdFALSE;
    21b8:	2300      	movs	r3, #0
    21ba:	4642      	mov	r2, r8
    21bc:	6013      	str	r3, [r2, #0]
	xLastTime = xTimeNow;
    21be:	4b1f      	ldr	r3, [pc, #124]	; (223c <prvSampleTimeNow+0xa0>)
    21c0:	4652      	mov	r2, sl
    21c2:	639a      	str	r2, [r3, #56]	; 0x38
}
    21c4:	4650      	mov	r0, sl
    21c6:	b002      	add	sp, #8
    21c8:	bc1c      	pop	{r2, r3, r4}
    21ca:	4690      	mov	r8, r2
    21cc:	4699      	mov	r9, r3
    21ce:	46a2      	mov	sl, r4
    21d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    21d2:	2300      	movs	r3, #0
    21d4:	9300      	str	r3, [sp, #0]
    21d6:	003a      	movs	r2, r7
    21d8:	2100      	movs	r1, #0
    21da:	0020      	movs	r0, r4
    21dc:	4c18      	ldr	r4, [pc, #96]	; (2240 <prvSampleTimeNow+0xa4>)
    21de:	47a0      	blx	r4
				configASSERT(xResult);
    21e0:	2800      	cmp	r0, #0
    21e2:	d104      	bne.n	21ee <prvSampleTimeNow+0x52>
    21e4:	b672      	cpsid	i
    21e6:	e7fe      	b.n	21e6 <prvSampleTimeNow+0x4a>
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    21e8:	4d14      	ldr	r5, [pc, #80]	; (223c <prvSampleTimeNow+0xa0>)
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    21ea:	4b16      	ldr	r3, [pc, #88]	; (2244 <prvSampleTimeNow+0xa8>)
    21ec:	4699      	mov	r9, r3
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    21ee:	686b      	ldr	r3, [r5, #4]
    21f0:	681a      	ldr	r2, [r3, #0]
    21f2:	2a00      	cmp	r2, #0
    21f4:	d017      	beq.n	2226 <prvSampleTimeNow+0x8a>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    21f6:	68db      	ldr	r3, [r3, #12]
    21f8:	681f      	ldr	r7, [r3, #0]
		pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    21fa:	68dc      	ldr	r4, [r3, #12]
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    21fc:	1d26      	adds	r6, r4, #4
    21fe:	0030      	movs	r0, r6
    2200:	47c8      	blx	r9
		pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    2202:	0020      	movs	r0, r4
    2204:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2206:	4798      	blx	r3
		if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    2208:	69e3      	ldr	r3, [r4, #28]
    220a:	2b01      	cmp	r3, #1
    220c:	d1ef      	bne.n	21ee <prvSampleTimeNow+0x52>
			xReloadTime = (xNextExpireTime + pxTimer->xTimerPeriodInTicks);
    220e:	69a3      	ldr	r3, [r4, #24]
    2210:	18fb      	adds	r3, r7, r3
			if (xReloadTime > xNextExpireTime) {
    2212:	429f      	cmp	r7, r3
    2214:	d2dd      	bcs.n	21d2 <prvSampleTimeNow+0x36>
				listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xReloadTime);
    2216:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    2218:	6124      	str	r4, [r4, #16]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    221a:	4b08      	ldr	r3, [pc, #32]	; (223c <prvSampleTimeNow+0xa0>)
    221c:	6858      	ldr	r0, [r3, #4]
    221e:	0031      	movs	r1, r6
    2220:	4b09      	ldr	r3, [pc, #36]	; (2248 <prvSampleTimeNow+0xac>)
    2222:	4798      	blx	r3
    2224:	e7e3      	b.n	21ee <prvSampleTimeNow+0x52>
	pxCurrentTimerList  = pxOverflowTimerList;
    2226:	4a05      	ldr	r2, [pc, #20]	; (223c <prvSampleTimeNow+0xa0>)
    2228:	6811      	ldr	r1, [r2, #0]
    222a:	6051      	str	r1, [r2, #4]
	pxOverflowTimerList = pxTemp;
    222c:	6013      	str	r3, [r2, #0]
		*pxTimerListsWereSwitched = pdTRUE;
    222e:	2301      	movs	r3, #1
    2230:	4642      	mov	r2, r8
    2232:	6013      	str	r3, [r2, #0]
    2234:	e7c3      	b.n	21be <prvSampleTimeNow+0x22>
    2236:	46c0      	nop			; (mov r8, r8)
    2238:	00001a41 	.word	0x00001a41
    223c:	20000a9c 	.word	0x20000a9c
    2240:	00002131 	.word	0x00002131
    2244:	00000c7f 	.word	0x00000c7f
    2248:	00000c51 	.word	0x00000c51

0000224c <prvTimerTask>:
{
    224c:	b5f0      	push	{r4, r5, r6, r7, lr}
    224e:	b089      	sub	sp, #36	; 0x24
				(void)uxListRemove(&(pxTimer->xTimerListItem));
    2250:	4f52      	ldr	r7, [pc, #328]	; (239c <prvTimerTask+0x150>)
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
    2252:	4b53      	ldr	r3, [pc, #332]	; (23a0 <prvTimerTask+0x154>)
    2254:	685b      	ldr	r3, [r3, #4]
    2256:	681a      	ldr	r2, [r3, #0]
	if (*pxListWasEmpty == pdFALSE) {
    2258:	2a00      	cmp	r2, #0
    225a:	d00e      	beq.n	227a <prvTimerTask+0x2e>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    225c:	68db      	ldr	r3, [r3, #12]
    225e:	681c      	ldr	r4, [r3, #0]
	vTaskSuspendAll();
    2260:	4b50      	ldr	r3, [pc, #320]	; (23a4 <prvTimerTask+0x158>)
    2262:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    2264:	a805      	add	r0, sp, #20
    2266:	4b50      	ldr	r3, [pc, #320]	; (23a8 <prvTimerTask+0x15c>)
    2268:	4798      	blx	r3
    226a:	0005      	movs	r5, r0
		if (xTimerListsWereSwitched == pdFALSE) {
    226c:	9b05      	ldr	r3, [sp, #20]
    226e:	2b00      	cmp	r3, #0
    2270:	d15f      	bne.n	2332 <prvTimerTask+0xe6>
			if ((xListWasEmpty == pdFALSE) && (xNextExpireTime <= xTimeNow)) {
    2272:	42a0      	cmp	r0, r4
    2274:	d236      	bcs.n	22e4 <prvTimerTask+0x98>
    2276:	2200      	movs	r2, #0
    2278:	e00f      	b.n	229a <prvTimerTask+0x4e>
	vTaskSuspendAll();
    227a:	4b4a      	ldr	r3, [pc, #296]	; (23a4 <prvTimerTask+0x158>)
    227c:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    227e:	a805      	add	r0, sp, #20
    2280:	4b49      	ldr	r3, [pc, #292]	; (23a8 <prvTimerTask+0x15c>)
    2282:	4798      	blx	r3
    2284:	0005      	movs	r5, r0
		if (xTimerListsWereSwitched == pdFALSE) {
    2286:	9b05      	ldr	r3, [sp, #20]
    2288:	2b00      	cmp	r3, #0
    228a:	d152      	bne.n	2332 <prvTimerTask+0xe6>
					xListWasEmpty = listLIST_IS_EMPTY(pxOverflowTimerList);
    228c:	4b44      	ldr	r3, [pc, #272]	; (23a0 <prvTimerTask+0x154>)
    228e:	681b      	ldr	r3, [r3, #0]
    2290:	681b      	ldr	r3, [r3, #0]
    2292:	425a      	negs	r2, r3
    2294:	415a      	adcs	r2, r3
    2296:	b2d2      	uxtb	r2, r2
    2298:	2400      	movs	r4, #0
				vQueueWaitForMessageRestricted(xTimerQueue, (xNextExpireTime - xTimeNow), xListWasEmpty);
    229a:	1b61      	subs	r1, r4, r5
    229c:	4b40      	ldr	r3, [pc, #256]	; (23a0 <prvTimerTask+0x154>)
    229e:	6898      	ldr	r0, [r3, #8]
    22a0:	4b42      	ldr	r3, [pc, #264]	; (23ac <prvTimerTask+0x160>)
    22a2:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    22a4:	4b42      	ldr	r3, [pc, #264]	; (23b0 <prvTimerTask+0x164>)
    22a6:	4798      	blx	r3
    22a8:	2800      	cmp	r0, #0
    22aa:	d03f      	beq.n	232c <prvTimerTask+0xe0>
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    22ac:	4d3c      	ldr	r5, [pc, #240]	; (23a0 <prvTimerTask+0x154>)
    22ae:	4c41      	ldr	r4, [pc, #260]	; (23b4 <prvTimerTask+0x168>)
    22b0:	2200      	movs	r2, #0
    22b2:	a905      	add	r1, sp, #20
    22b4:	68a8      	ldr	r0, [r5, #8]
    22b6:	47a0      	blx	r4
    22b8:	2800      	cmp	r0, #0
    22ba:	d0ca      	beq.n	2252 <prvTimerTask+0x6>
		if (xMessage.xMessageID >= (BaseType_t)0) {
    22bc:	9b05      	ldr	r3, [sp, #20]
    22be:	9303      	str	r3, [sp, #12]
    22c0:	2b00      	cmp	r3, #0
    22c2:	dbf5      	blt.n	22b0 <prvTimerTask+0x64>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    22c4:	9e07      	ldr	r6, [sp, #28]
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTimer->xTimerListItem))
    22c6:	6973      	ldr	r3, [r6, #20]
    22c8:	2b00      	cmp	r3, #0
    22ca:	d001      	beq.n	22d0 <prvTimerTask+0x84>
				(void)uxListRemove(&(pxTimer->xTimerListItem));
    22cc:	1d30      	adds	r0, r6, #4
    22ce:	47b8      	blx	r7
			xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    22d0:	a804      	add	r0, sp, #16
    22d2:	4b35      	ldr	r3, [pc, #212]	; (23a8 <prvTimerTask+0x15c>)
    22d4:	4798      	blx	r3
			switch (xMessage.xMessageID) {
    22d6:	9b05      	ldr	r3, [sp, #20]
    22d8:	2b09      	cmp	r3, #9
    22da:	d8e9      	bhi.n	22b0 <prvTimerTask+0x64>
    22dc:	009b      	lsls	r3, r3, #2
    22de:	4a36      	ldr	r2, [pc, #216]	; (23b8 <prvTimerTask+0x16c>)
    22e0:	58d3      	ldr	r3, [r2, r3]
    22e2:	469f      	mov	pc, r3
				(void)xTaskResumeAll();
    22e4:	4b32      	ldr	r3, [pc, #200]	; (23b0 <prvTimerTask+0x164>)
    22e6:	4798      	blx	r3
	Timer_t *const pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    22e8:	4b2d      	ldr	r3, [pc, #180]	; (23a0 <prvTimerTask+0x154>)
    22ea:	685b      	ldr	r3, [r3, #4]
    22ec:	68db      	ldr	r3, [r3, #12]
    22ee:	68de      	ldr	r6, [r3, #12]
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    22f0:	1d30      	adds	r0, r6, #4
    22f2:	4b2a      	ldr	r3, [pc, #168]	; (239c <prvTimerTask+0x150>)
    22f4:	4798      	blx	r3
	if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    22f6:	69f3      	ldr	r3, [r6, #28]
    22f8:	2b01      	cmp	r3, #1
    22fa:	d003      	beq.n	2304 <prvTimerTask+0xb8>
	pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    22fc:	6a73      	ldr	r3, [r6, #36]	; 0x24
    22fe:	0030      	movs	r0, r6
    2300:	4798      	blx	r3
    2302:	e7d3      	b.n	22ac <prvTimerTask+0x60>
		if (prvInsertTimerInActiveList(
    2304:	69b3      	ldr	r3, [r6, #24]
    2306:	18e1      	adds	r1, r4, r3
    2308:	0023      	movs	r3, r4
    230a:	002a      	movs	r2, r5
    230c:	0030      	movs	r0, r6
    230e:	4d2b      	ldr	r5, [pc, #172]	; (23bc <prvTimerTask+0x170>)
    2310:	47a8      	blx	r5
    2312:	2800      	cmp	r0, #0
    2314:	d0f2      	beq.n	22fc <prvTimerTask+0xb0>
			xResult = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    2316:	2300      	movs	r3, #0
    2318:	9300      	str	r3, [sp, #0]
    231a:	0022      	movs	r2, r4
    231c:	2100      	movs	r1, #0
    231e:	0030      	movs	r0, r6
    2320:	4c27      	ldr	r4, [pc, #156]	; (23c0 <prvTimerTask+0x174>)
    2322:	47a0      	blx	r4
			configASSERT(xResult);
    2324:	2800      	cmp	r0, #0
    2326:	d1e9      	bne.n	22fc <prvTimerTask+0xb0>
    2328:	b672      	cpsid	i
    232a:	e7fe      	b.n	232a <prvTimerTask+0xde>
					portYIELD_WITHIN_API();
    232c:	4b25      	ldr	r3, [pc, #148]	; (23c4 <prvTimerTask+0x178>)
    232e:	4798      	blx	r3
    2330:	e7bc      	b.n	22ac <prvTimerTask+0x60>
			(void)xTaskResumeAll();
    2332:	4b1f      	ldr	r3, [pc, #124]	; (23b0 <prvTimerTask+0x164>)
    2334:	4798      	blx	r3
    2336:	e7b9      	b.n	22ac <prvTimerTask+0x60>
				if (prvInsertTimerInActiveList(pxTimer,
    2338:	9b06      	ldr	r3, [sp, #24]
    233a:	69b2      	ldr	r2, [r6, #24]
    233c:	4694      	mov	ip, r2
    233e:	4463      	add	r3, ip
    2340:	0019      	movs	r1, r3
    2342:	9b06      	ldr	r3, [sp, #24]
    2344:	0002      	movs	r2, r0
    2346:	0030      	movs	r0, r6
    2348:	4c1c      	ldr	r4, [pc, #112]	; (23bc <prvTimerTask+0x170>)
    234a:	47a0      	blx	r4
    234c:	2800      	cmp	r0, #0
    234e:	d0ae      	beq.n	22ae <prvTimerTask+0x62>
					pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    2350:	0030      	movs	r0, r6
    2352:	6a73      	ldr	r3, [r6, #36]	; 0x24
    2354:	4798      	blx	r3
					if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    2356:	69f3      	ldr	r3, [r6, #28]
    2358:	2b01      	cmp	r3, #1
    235a:	d1a8      	bne.n	22ae <prvTimerTask+0x62>
						xResult = xTimerGenericCommand(pxTimer,
    235c:	9b06      	ldr	r3, [sp, #24]
    235e:	69b1      	ldr	r1, [r6, #24]
    2360:	468c      	mov	ip, r1
    2362:	4463      	add	r3, ip
    2364:	001a      	movs	r2, r3
    2366:	2300      	movs	r3, #0
    2368:	9300      	str	r3, [sp, #0]
    236a:	2100      	movs	r1, #0
    236c:	0030      	movs	r0, r6
    236e:	4c14      	ldr	r4, [pc, #80]	; (23c0 <prvTimerTask+0x174>)
    2370:	47a0      	blx	r4
						configASSERT(xResult);
    2372:	2800      	cmp	r0, #0
    2374:	d19b      	bne.n	22ae <prvTimerTask+0x62>
    2376:	b672      	cpsid	i
    2378:	e7fe      	b.n	2378 <prvTimerTask+0x12c>
				pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    237a:	9906      	ldr	r1, [sp, #24]
    237c:	61b1      	str	r1, [r6, #24]
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
    237e:	2900      	cmp	r1, #0
    2380:	d006      	beq.n	2390 <prvTimerTask+0x144>
				(void)prvInsertTimerInActiveList(
    2382:	1841      	adds	r1, r0, r1
    2384:	0003      	movs	r3, r0
    2386:	0002      	movs	r2, r0
    2388:	0030      	movs	r0, r6
    238a:	4c0c      	ldr	r4, [pc, #48]	; (23bc <prvTimerTask+0x170>)
    238c:	47a0      	blx	r4
    238e:	e78e      	b.n	22ae <prvTimerTask+0x62>
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
    2390:	b672      	cpsid	i
    2392:	e7fe      	b.n	2392 <prvTimerTask+0x146>
				vPortFree(pxTimer);
    2394:	0030      	movs	r0, r6
    2396:	4b0c      	ldr	r3, [pc, #48]	; (23c8 <prvTimerTask+0x17c>)
    2398:	4798      	blx	r3
    239a:	e788      	b.n	22ae <prvTimerTask+0x62>
    239c:	00000c7f 	.word	0x00000c7f
    23a0:	20000a9c 	.word	0x20000a9c
    23a4:	00001a31 	.word	0x00001a31
    23a8:	0000219d 	.word	0x0000219d
    23ac:	000016ed 	.word	0x000016ed
    23b0:	00001b59 	.word	0x00001b59
    23b4:	00001401 	.word	0x00001401
    23b8:	00002504 	.word	0x00002504
    23bc:	00002055 	.word	0x00002055
    23c0:	00002131 	.word	0x00002131
    23c4:	00000d8d 	.word	0x00000d8d
    23c8:	00000ecd 	.word	0x00000ecd

000023cc <__libc_init_array>:
    23cc:	b570      	push	{r4, r5, r6, lr}
    23ce:	2600      	movs	r6, #0
    23d0:	4d0c      	ldr	r5, [pc, #48]	; (2404 <__libc_init_array+0x38>)
    23d2:	4c0d      	ldr	r4, [pc, #52]	; (2408 <__libc_init_array+0x3c>)
    23d4:	1b64      	subs	r4, r4, r5
    23d6:	10a4      	asrs	r4, r4, #2
    23d8:	42a6      	cmp	r6, r4
    23da:	d109      	bne.n	23f0 <__libc_init_array+0x24>
    23dc:	2600      	movs	r6, #0
    23de:	f000 f8a9 	bl	2534 <_init>
    23e2:	4d0a      	ldr	r5, [pc, #40]	; (240c <__libc_init_array+0x40>)
    23e4:	4c0a      	ldr	r4, [pc, #40]	; (2410 <__libc_init_array+0x44>)
    23e6:	1b64      	subs	r4, r4, r5
    23e8:	10a4      	asrs	r4, r4, #2
    23ea:	42a6      	cmp	r6, r4
    23ec:	d105      	bne.n	23fa <__libc_init_array+0x2e>
    23ee:	bd70      	pop	{r4, r5, r6, pc}
    23f0:	00b3      	lsls	r3, r6, #2
    23f2:	58eb      	ldr	r3, [r5, r3]
    23f4:	4798      	blx	r3
    23f6:	3601      	adds	r6, #1
    23f8:	e7ee      	b.n	23d8 <__libc_init_array+0xc>
    23fa:	00b3      	lsls	r3, r6, #2
    23fc:	58eb      	ldr	r3, [r5, r3]
    23fe:	4798      	blx	r3
    2400:	3601      	adds	r6, #1
    2402:	e7f2      	b.n	23ea <__libc_init_array+0x1e>
    2404:	00002540 	.word	0x00002540
    2408:	00002540 	.word	0x00002540
    240c:	00002540 	.word	0x00002540
    2410:	00002544 	.word	0x00002544

00002414 <memcpy>:
    2414:	2300      	movs	r3, #0
    2416:	b510      	push	{r4, lr}
    2418:	429a      	cmp	r2, r3
    241a:	d100      	bne.n	241e <memcpy+0xa>
    241c:	bd10      	pop	{r4, pc}
    241e:	5ccc      	ldrb	r4, [r1, r3]
    2420:	54c4      	strb	r4, [r0, r3]
    2422:	3301      	adds	r3, #1
    2424:	e7f8      	b.n	2418 <memcpy+0x4>

00002426 <memset>:
    2426:	0003      	movs	r3, r0
    2428:	1882      	adds	r2, r0, r2
    242a:	4293      	cmp	r3, r2
    242c:	d100      	bne.n	2430 <memset+0xa>
    242e:	4770      	bx	lr
    2430:	7019      	strb	r1, [r3, #0]
    2432:	3301      	adds	r3, #1
    2434:	e7f9      	b.n	242a <memset+0x4>
    2436:	0000      	movs	r0, r0
    2438:	682f2e2e 	.word	0x682f2e2e
    243c:	732f6c61 	.word	0x732f6c61
    2440:	682f6372 	.word	0x682f6372
    2444:	695f6c61 	.word	0x695f6c61
    2448:	00632e6f 	.word	0x00632e6f
    244c:	682f2e2e 	.word	0x682f2e2e
    2450:	732f6c61 	.word	0x732f6c61
    2454:	682f6372 	.word	0x682f6372
    2458:	755f6c61 	.word	0x755f6c61
    245c:	74726173 	.word	0x74726173
    2460:	7973615f 	.word	0x7973615f
    2464:	632e636e 	.word	0x632e636e
    2468:	00000000 	.word	0x00000000
    246c:	682f2e2e 	.word	0x682f2e2e
    2470:	752f6c61 	.word	0x752f6c61
    2474:	736c6974 	.word	0x736c6974
    2478:	6372732f 	.word	0x6372732f
    247c:	6974752f 	.word	0x6974752f
    2480:	725f736c 	.word	0x725f736c
    2484:	62676e69 	.word	0x62676e69
    2488:	65666675 	.word	0x65666675
    248c:	00632e72 	.word	0x00632e72
    2490:	42000400 	.word	0x42000400
    2494:	42000800 	.word	0x42000800
    2498:	42000c00 	.word	0x42000c00
    249c:	42001000 	.word	0x42001000
    24a0:	42001400 	.word	0x42001400
    24a4:	42001800 	.word	0x42001800
    24a8:	43000000 	.word	0x43000000
    24ac:	43000400 	.word	0x43000400

000024b0 <_i2cms>:
	...
    24c8:	682f2e2e 732f6c70 6f637265 70682f6d     ../hpl/sercom/hp
    24d8:	65735f6c 6d6f6372 0000632e 6d617845     l_sercom.c..Exam
    24e8:	00656c70 454c4449 00000000 09632509     ple.IDLE.....%c.
    24f8:	25097525 75250975 00000a0d 00002338     %u.%u.%u....8#..
    2508:	00002338 00002338 000022b0 0000237a     8#..8#..."..z#..
    2518:	00002394 00002338 00002338 000022b0     .#..8#..8#..."..
    2528:	0000237a 20726d54 00637653              z#..Tmr Svc.

00002534 <_init>:
    2534:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2536:	46c0      	nop			; (mov r8, r8)
    2538:	bcf8      	pop	{r3, r4, r5, r6, r7}
    253a:	bc08      	pop	{r3}
    253c:	469e      	mov	lr, r3
    253e:	4770      	bx	lr

00002540 <__init_array_start>:
    2540:	000000e5 	.word	0x000000e5

00002544 <_fini>:
    2544:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2546:	46c0      	nop			; (mov r8, r8)
    2548:	bcf8      	pop	{r3, r4, r5, r6, r7}
    254a:	bc08      	pop	{r3}
    254c:	469e      	mov	lr, r3
    254e:	4770      	bx	lr

00002550 <__fini_array_start>:
    2550:	000000bd 	.word	0x000000bd
